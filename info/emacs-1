This is ../info/emacs, produced by makeinfo version 4.11 from
emacs.texi.

This is the Sixteenth edition of the `GNU Emacs Manual',
updated for Emacs version 22.3.

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You are free to copy and modify
     this GNU Manual. Buying copies from GNU Press supports the FSF in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


File: emacs,  Node: Top,  Next: Distrib,  Prev: (dir),  Up: (dir)

The Emacs Editor
****************

Emacs is the extensible, customizable, self-documenting real-time
display editor.  This Info file describes how to edit with Emacs and
some of how to customize it; it corresponds to GNU Emacs version
22.3.

   To learn more about the Info documentation system, type `h', and
Emacs will take you to a programmed instruction sequence for the Info
commands.

   For information on extending Emacs, see *note Emacs Lisp: (elisp)Top.

* Menu:

* Distrib::	        How to get the latest Emacs distribution.
* Copying::	        The GNU General Public License gives you permission
			  to redistribute GNU Emacs on certain terms;
			  it also explains that there is no warranty.
* GNU Free Documentation License:: The license for this documentation.
* Intro::	        An introduction to Emacs concepts.
* Glossary::	        Terms used in this manual.
* Antinews::	        Information about Emacs version 21.
* Mac OS::              Using Emacs in the Mac.
* Microsoft Windows::   Using Emacs on Microsoft Windows and MS-DOS.
* Manifesto::	        What's GNU?  Gnu's Not Unix!
* Acknowledgments::     Major contributors to GNU Emacs.

Indexes (each index contains a large menu)
* Key Index::	        An item for each standard Emacs key sequence.
* Option Index::        An item for every command-line option.
* Command Index::       An item for each command name.
* Variable Index::      An item for each documented variable.
* Concept Index::       An item for each concept.

Important General Concepts
* Screen::	        How to interpret what you see on the screen.
* User Input::	        Kinds of input events (characters, buttons,
                          function keys).
* Keys::	        Key sequences: what you type to request one
                          editing action.
* Commands::	        Named functions run by key sequences to do editing.
* Text Characters::     Character set for text (the contents of buffers
			  and strings).
* Entering Emacs::      Starting Emacs from the shell.
* Exiting::	        Stopping or killing Emacs.
* Emacs Invocation::    Hairy startup options.

Fundamental Editing Commands
* Basic::	        The most basic editing commands.
* Minibuffer::	        Entering arguments that are prompted for.
* M-x::		        Invoking commands by their names.
* Help::	        Commands for asking Emacs about its commands.

Important Text-Changing Commands
* Mark::	        The mark: how to delimit a ``region'' of text.
* Killing::	        Killing (cutting) text.
* Yanking::	        Recovering killed text.  Moving text. (Pasting.)
* Accumulating Text::   Other ways of copying text.
* Rectangles::	        Operating on the text inside a rectangle on the screen.
* Registers::	        Saving a text string or a location in the buffer.
* Display::	        Controlling what text is displayed.
* Search::	        Finding or replacing occurrences of a string.
* Fixit::	        Commands especially useful for fixing typos.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single command.

Major Structures of Emacs
* Files::	        All about handling files.
* Buffers::	        Multiple buffers; editing several files at once.
* Windows::	        Viewing two pieces of text at once.
* Frames::	        Running the same Emacs session in multiple X windows.
* International::       Using non-ASCII character sets (the MULE features).

Advanced Features
* Major Modes::	        Text mode vs. Lisp mode vs. C mode ...
* Indentation::	        Editing the white space at the beginnings of lines.
* Text::	        Commands and modes for editing English.
* Programs::	        Commands and modes for editing programs.
* Building::	        Compiling, running and debugging programs.
* Maintaining::         Features for maintaining large programs.
* Abbrevs::	        How to define text abbreviations to reduce
			  the number of characters you must type.

* Picture Mode::        Editing pictures made up of characters using
                          the quarter-plane screen model.
* Sending Mail::        Sending mail in Emacs.
* Rmail::	        Reading mail in Emacs.
* Dired::	        You can ``edit'' a directory to manage files in it.
* Calendar/Diary::      The calendar and diary facilities.
* Gnus::	        How to read netnews with Emacs.
* Shell::	        Executing shell commands from Emacs.
* Emacs Server::        Using Emacs as an editing server for `mail', etc.
* Printing::	        Printing hardcopies of buffers or regions.
* Sorting::	        Sorting lines, paragraphs or pages within Emacs.
* Narrowing::	        Restricting display and editing to a portion
		          of the buffer.
* Two-Column::	        Splitting apart columns to edit them
		          in side-by-side windows.
* Editing Binary Files::Using Hexl mode to edit binary files.
* Saving Emacs Sessions:: Saving Emacs state from one session to the next.
* Recursive Edit::      A command can allow you to do editing
			  "within the command".  This is called a
			  "recursive editing level".
* Emulation::	        Emulating some other editors with Emacs.
* Hyperlinking::        Following links in buffers.
* Dissociated Press::   Dissociating text for fun.
* Amusements::	        Various games and hacks.
* Customization::       Modifying the behavior of Emacs.
* X Resources::         X resources for customizing Emacs.

Recovery from Problems
* Quitting::	        Quitting and aborting.
* Lossage::	        What to do if Emacs is hung or malfunctioning.
* Bugs::	        How and when to report a bug.
* Contributing::        How to contribute improvements to Emacs.
* Service::	        How to get help for your own Emacs needs.


 --- The Detailed Node Listing ---
 ---------------------------------

Here are some other nodes which are really inferiors of the ones
already listed, mentioned here so you can get to them in one step:

The Organization of the Screen

* Point::	        The place in the text where editing commands operate.
* Echo Area::           Short messages appear at the bottom of the screen.
* Mode Line::	        Interpreting the mode line.
* Menu Bar::            How to use the menu bar.

Basic Editing Commands

* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        How to move the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Basic Undo::	        Undoing recent changes in the text.
* Basic Files::         Visiting, creating, and saving files.
* Basic Help::          Asking what a character does.
* Blank Lines::	        Commands to make or delete blank lines.
* Continuation Lines::  Lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command.
* Repeating::           A short-cut for repeating the previous command.

The Minibuffer

* Minibuffer File::     Entering file names with the minibuffer.
* Minibuffer Edit::     How to edit in the minibuffer.
* Completion::		An abbreviation facility for minibuffer input.
* Minibuffer History::	Reusing recent minibuffer arguments.
* Repetition::		Re-executing commands that used the minibuffer.

Completion

* Example: Completion Example.    Examples of using completion.
* Commands: Completion Commands.  A list of completion commands.
* Strict Completion::             Different types of completion.
* Options: Completion Options.    Options for completion.

Help

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in Emacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Help Mode::           Special features of Help mode and Help buffers.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Misc Help::		Other help commands.
* Help Files::          Commands to display pre-written help files.
* Help Echo::           Help on active text and tooltips (`balloon help')

The Mark and the Region

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Momentary Mark::      Enabling Transient Mark mode momentarily.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::		Previous mark positions saved so you can go back there.
* Global Mark Ring::	Previous mark positions in various buffers.

Killing and Moving Text

* Deletion::		Commands for deleting small amounts of text and
			  blank areas.
* Killing by Lines::	How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
			  syntactic units such as words and sentences.
* CUA Bindings::        Using C-x, C-c, C-v for copy
                          and paste, with enhanced rectangle support.

Yanking

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.

Registers

* RegPos::      	Saving positions in registers.
* RegText::     	Saving text in registers.
* RegRect::     	Saving rectangles in registers.
* RegConfig::           Saving window configurations in registers.
* RegNumbers::          Numbers in registers.
* RegFiles::    	File names in registers.
* Bookmarks::           Bookmarks are like registers, but persistent.

Controlling the Display

* Scrolling::	           Moving text up and down in a window.
* Auto Scrolling::         Redisplay scrolls text automatically when needed.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Faces::	           How to change the display style using faces.
* Standard Faces::         Emacs' predefined faces.
* Font Lock::              Minor mode for syntactic highlighting using faces.
* Highlight Interactively:: Tell Emacs what text to highlight.
* Fringes::                Enabling or disabling window fringes.
* Displaying Boundaries::  Displaying top and bottom of the buffer.
* Useless Whitespace::     Showing possibly-spurious trailing whitespace.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Cursor Display::         Features for displaying the cursor.
* Line Truncation::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* Display Custom::         Information on variables for customizing display.

Searching and Replacement

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Regexp Backslash::       Regular expression constructs starting with `\'.
* Regexp Example::         A complex regular expression explained.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.

Incremental Search

* Basic Isearch::       Basic incremental search commands.
* Repeat Isearch::      Searching for the same string again.
* Error in Isearch::    When your string is not found.
* Special Isearch::     Special input in incremental search.
* Non-ASCII Isearch::   How to search for non-ASCII characters.
* Isearch Yank::        Commands that grab text into the search string
                          or else edit the search string.
* Highlight Isearch::   Isearch highlights the other possible matches.
* Isearch Scroll::      Scrolling during an incremental search.
* Slow Isearch::        Incremental search features for slow terminals.

Replacement Commands

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::	   Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::	   How to use querying.

Commands for Fixing Typos

* Undo::                Full details of Emacs undo commands.
* Kill Errors::         Commands to kill a batch of recently entered text.
* Transpose::	        Exchanging two characters, words, lines, lists...
* Fixing Case::         Correcting case of last word entered.
* Spelling::	        Apply spelling checker to a word or a whole buffer.

Keyboard Macros

* Basic Keyboard Macro::     Defining and running keyboard macros.
* Keyboard Macro Ring::      Where previous keyboard macros are saved.
* Keyboard Macro Counter::   Inserting incrementing numbers in macros.
* Keyboard Macro Query::     Making keyboard macros do different things each time.
* Save Keyboard Macro::      Giving keyboard macros names; saving them in files.
* Edit Keyboard Macro::      Editing keyboard macros.
* Keyboard Macro Step-Edit:: Interactively executing and editing a keyboard
                                macro.

File Handling

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.
* Autorevert::          Auto Reverting non-file buffers.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Diff Mode::           Editing diff output.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* File Archives::       Operating on tar, zip, jar etc. archive files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.
* File Name Cache::     Completion against a list of files you often use.
* File Conveniences::   Convenience Features for Finding Files.
* Filesets::            Handling sets of files.

Saving Files

* Save Commands::       Commands for saving files.
* Backup::              How Emacs saves the old version of your file.
* Customize Save::      Customizing the saving of files.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.
* File Shadowing::      Copying files to "shadows" automatically.
* Time Stamps::         Emacs can update time stamps on saved files.

Backup Files

* One or Many: Numbered Backups. Whether to make one backup file or many.
* Names: Backup Names.		How backup files are named.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.

Auto-Saving: Protection Against Disasters

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.

Version Control

* Introduction to VC::  How version control works in general.
* VC Mode Line::        How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands:: The commands used a little less frequently.
* Branches::            Multiple lines of development.
* Remote Repositories:: Efficient access to remote CVS servers.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.

Using Multiple Buffers

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::	        Renaming; changing read-onliness; copying text.
* Kill Buffer::	        Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
			  and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer.
* Buffer Convenience::  Convenience and customization features for
                          buffer handling.

Multiple Windows

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.
* Window Convenience::  Convenience functions for window handling.

Frames and Graphical Displays

* Cut and Paste::       Mouse commands for cut and paste.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Frame Commands::      Iconifying, deleting, and switching frames.
* Speedbar::            How to make and use a speedbar frame.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Wheeled Mice::        Using mouse wheels for scrolling.
* Drag and Drop::       Using drag and drop to open files and insert text.
* Menu Bars::	        Enabling and disabling the menu bar.
* Tool Bars::           Enabling and disabling the tool bar.
* Dialog Boxes::        Controlling use of dialog boxes.
* Tooltips::            Showing "tooltips", AKA "balloon help" for active text.
* Mouse Avoidance::     Moving the mouse pointer out of the way.
* Non-Window Terminals::  Multiple frames on terminals that show only one.
* Text-Only Mouse::     Using the mouse in text-only terminals.

International Character Set Support

* International Chars::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Multibyte Conversion::    How single-byte characters convert to multibyte.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Specifying a file's coding system explicitly.
* Output Coding::           Choosing coding systems for output.
* Text Coding::             Choosing conversion to use for file text.
* Communication Coding::    Coding systems for interprocess communication.
* File Name Coding::        Coding systems for file _names_.
* Terminal Coding::         Specifying coding systems for converting
                              terminal input and output.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Undisplayable Characters::When characters don't display.
* Unibyte Mode::            You can pick one European character set
                              to use without multibyte characters.
* Charsets::                How Emacs groups its internal character codes.

Major Modes

* Choosing Modes::      How major modes are specified or chosen.

Indentation

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::		  You can set arbitrary "tab stops" and then
			    indent to the next tab stop when you want to.
* Just Spaces::		  You can request indentation using just spaces.

Commands for Human Languages

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* HTML Mode::           Editing HTML, SGML, and XML files.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.
* Text Based Tables::   Editing text-based tables in WYSIWYG fashion.

Filling Text

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Refill::              Keeping paragraphs filled.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.
* Longlines::           Editing text with very long lines.

Outline Mode

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines.
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.
* Foldout::                        Folding means zooming in on outlines.

TeX Mode

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.
* Misc: TeX Misc.         Customization of TeX mode, and related features.

Editing Formatted Text

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the
                                  left or right margin, etc.
* Other: Format Properties.     The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.

Editing Text-based Tables

* Table Definition::    What is a text based table.
* Table Creation::      How to create a table.
* Table Recognition::   How to activate and deactivate tables.
* Cell Commands::       Cell-oriented commands in a table.
* Cell Justification::  Justifying cell contents.
* Row Commands::        Manipulating rows of table cell.
* Column Commands::     Manipulating columns of table cell.
* Fixed Width Mode::    Fixing cell width.
* Table Conversion::    Converting between plain text and tables.
* Measuring Tables::    Analyzing table dimension.
* Table Misc::          Table miscellany.

Editing Programs

* Program Modes::       Major modes for editing programs.
* Defuns::              Commands to operate on major top-level parts
                          of a program.
* Program Indent::      Adjusting indentation to show the nesting.
* Parentheses::         Commands that operate on parentheses.
* Comments::	        Inserting, killing, and aligning comments.
* Documentation::       Getting documentation of functions you plan to call.
* Hideshow::            Displaying blocks selectively.
* Symbol Completion::   Completion on symbol names of your program or language.
* Glasses::             Making identifiersLikeThis more readable.
* Misc for Programs::   Other Emacs features useful for editing programs.
* C Modes::             Special commands of C, C++, Objective-C,
                          Java, and Pike modes.
* Asm Mode::            Asm mode and its special features.
* Fortran::             Fortran mode and its special features.

Top-Level Definitions, or Defuns

* Left Margin Paren::   An open-paren or similar opening delimiter
                          starts a defun if it is at the left margin.
* Moving by Defuns::    Commands to move over or mark a major definition.
* Imenu::               Making buffer indexes as menus.
* Which Function::      Which Function mode shows which function you are in.

Indentation for Programs

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C and related modes.
* Custom C Indent::	Controlling indentation style for C and related modes.

Commands for Editing with Parentheses

* Expressions::         Expressions with balanced parentheses.
* Moving by Parens::    Commands for moving up, down and across
                          in the structure of parentheses.
* Matching::	        Insertion of a close-delimiter flashes matching open.

Manipulating Comments

* Comment Commands::    Inserting, killing, and aligning comments.
* Multi-Line Comments:: Commands for adding and editing multi-line comments.
* Options for Comments::Customizing the comment features.

Documentation Lookup

* Info Lookup::         Looking up library functions and commands
                          in Info files.
* Man Page::            Looking up man pages of library functions and commands.
* Lisp Doc::            Looking up Emacs Lisp functions, etc.

C and Related Modes

* Motion in C::         Commands to move by C statements, etc.
* Electric C::          Colon and other chars can automatically reindent.
* Hungry Delete::       A more powerful DEL command.
* Other C Commands::    Filling comments, viewing expansion of macros,
                          and other neat features.

Compiling and Testing Programs

* Compilation::		Compiling programs in languages other
			  than Lisp (C, Pascal, etc.).
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Grep Searching::      Searching with grep.
* Flymake::             Finding syntax errors on the fly.
* Debuggers::		Running symbolic debuggers for non-Lisp programs.
* Executing Lisp::	Various modes for editing Lisp programs,
			  with different facilities for running
			  the Lisp programs.
* Lisp Libraries::      Creating Lisp programs to run in Emacs.
* Lisp Eval::		Executing a single Lisp expression in Emacs.
* Lisp Interaction::    Executing Lisp in an Emacs buffer.
* External Lisp::	Communicating through Emacs with a separate Lisp.

Running Debuggers Under Emacs

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.
* GDB Graphical Interface::  An enhanced mode that uses GDB features to
                          implement a graphical debugging environment through
                          Emacs.

Maintaining Large Programs

* Change Log::	        Maintaining a change history for your program.
* Format of ChangeLog:: What the change log file looks like.
* Tags::	        Go directly to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::              A convenient way of merging two versions of a program.

Tags Tables

* Tag Syntax::		Tag syntax for various types of code and text files.
* Create Tags Table::	Creating a tags table with `etags'.
* Etags Regexps::       Create arbitrary tags using regular expressions.
* Select Tags Table::	How to visit a tags table.
* Find Tag::		Commands to find the definition of a specific tag.
* Tags Search::		Using a tags table for searching and replacing.
* List Tags::		Listing and finding tags defined in a file.

Abbrevs

* Abbrev Concepts::     Fundamentals of defined abbrevs.
* Defining Abbrevs::    Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs::   Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::     Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::      Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::     Abbreviations for words already in the buffer.
* Dabbrev Customization:: What is a word, for dynamic abbrevs.  Case handling.


Editing Pictures

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                            after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.

Sending Mail

* Mail Format:: 	Format of the mail being composed.
* Mail Headers::        Details of permitted mail header fields.
* Mail Aliases::        Abbreviating and grouping mail addresses.
* Mail Mode::   	Special commands for editing mail being composed.
* Mail Amusements::     Distract the NSA's attention; add a fortune to a msg.
* Mail Methods::        Using alternative mail-composition methods.

Reading Mail with Rmail

* Rmail Basics::        Basic concepts of Rmail, and simple use.
* Rmail Scrolling::     Scrolling through a message.
* Rmail Motion::        Moving to another message.
* Rmail Deletion::      Deleting and expunging messages.
* Rmail Inbox::         How mail gets into the Rmail file.
* Rmail Files::         Using multiple Rmail files.
* Rmail Output::        Copying message out to files.
* Rmail Labels::        Classifying messages by labeling them.
* Rmail Attributes::    Certain standard labels, called attributes.
* Rmail Reply::         Sending replies to messages you are viewing.
* Rmail Summary::       Summaries show brief info on many messages.
* Rmail Sorting::       Sorting messages in Rmail.
* Rmail Display::       How Rmail displays a message; customization.
* Rmail Coding::        How Rmail handles decoding character sets.
* Rmail Editing::       Editing message text and headers in Rmail.
* Rmail Digest::        Extracting the messages from a digest message.
* Out of Rmail::	Converting an Rmail file to mailbox format.
* Rmail Rot13::         Reading messages encoded in the rot13 code.
* Movemail::            More details of fetching new mail.
* Remote Mailboxes::    Retrieving Mail from Remote Mailboxes.
* Other Mailbox Formats:: Retrieving Mail from Local Mailboxes in
                          Various Formats

Dired, the Directory Editor

* Dired Enter:: 	     How to invoke Dired.
* Dired Navigation::         How to move in the Dired buffer.
* Dired Deletion::           Deleting files with Dired.
* Flagging Many Files::      Flagging files based on their names.
* Dired Visiting::           Other file operations through Dired.
* Marks vs Flags::	     Flagging for deletion vs marking.
* Operating on Files::	     How to copy, rename, print, compress, etc.
			       either one file or several files.
* Shell Commands in Dired::  Running a shell command on the marked files.
* Transforming File Names::  Using patterns to rename multiple files.
* Comparison in Dired::	     Running `diff' by way of Dired.
* Subdirectories in Dired::  Adding subdirectories to the Dired buffer.
* Subdir Switches::          Subdirectory switches in Dired.
* Subdirectory Motion::	     Moving across subdirectories, and up and down.
* Hiding Subdirectories::    Making subdirectories visible or invisible.
* Dired Updating::           Discarding lines for files of no interest.
* Dired and Find::	     Using `find' to choose the files for Dired.
* Wdired::                   Operating on files by editing the Dired buffer.
* Image-Dired::              Viewing image thumbnails in Dired
* Misc Dired Features::      Various other features.

The Calendar and the Diary

* Calendar Motion::     Moving through the calendar; selecting a date.
* Scroll Calendar::     Bringing earlier or later months onto the screen.
* Counting Days::       How many days are there between two dates?
* General Calendar::    Exiting or recomputing the calendar.
* Writing Calendar Files:: Writing calendars to files of various formats.
* Holidays::            Displaying dates of holidays.
* Sunrise/Sunset::      Displaying local times of sunrise and sunset.
* Lunar Phases::        Displaying phases of the moon.
* Other Calendars::     Converting dates to other calendar systems.
* Diary::               Displaying events from your diary.
* Appointments::	Reminders when it's time to do something.
* Importing Diary::     Converting diary events to/from other formats.
* Daylight Saving::    How to specify when daylight saving time is active.
* Time Intervals::      Keeping track of time intervals.
* Advanced Calendar/Diary Usage:: Advanced Calendar/Diary customization.

Movement in the Calendar

* Calendar Unit Motion::      Moving by days, weeks, months, and years.
* Move to Beginning or End::  Moving to start/end of weeks, months, and years.
* Specified Dates::	      Moving to the current date or another
				specific date.

Conversion To and From Other Calendars

* Calendar Systems::	   The calendars Emacs understands
			     (aside from Gregorian).
* To Other Calendar::	   Converting the selected date to various calendars.
* From Other Calendar::	   Moving to a date specified in another calendar.
* Mayan Calendar::	   Moving to a date specified in a Mayan calendar.

The Diary

* Displaying the Diary::   Viewing diary entries and associated calendar dates.
* Format of Diary File::   Entering events in your diary.
* Date Formats::	   Various ways you can specify dates.
* Adding to Diary::	   Commands to create diary entries.
* Special Diary Entries::  Anniversaries, blocks of dates, cyclic entries, etc.

Gnus

* Buffers of Gnus::	The group, summary, and article buffers.
* Gnus Startup::	What you should know about starting Gnus.
* Summary of Gnus::	A short description of the basic Gnus commands.

Running Shell Commands from Emacs

* Single Shell::	How to run one shell command and return.
* Interactive Shell::	Permanent shell taking input via Emacs.
* Shell Mode::		Special Emacs commands used with permanent shell.
* Shell Prompts::       Two ways to recognize shell prompts.
* Shell History::       Repeating previous commands in a shell buffer.
* Directory Tracking::  Keeping track when the subshell changes directory.
* Shell Options::       Options for customizing Shell mode.
* Terminal emulator::   An Emacs window as a terminal emulator.
* Term Mode::           Special Emacs commands used in Term mode.
* Paging in Term::      Paging in the terminal emulator.
* Remote Host::		Connecting to another computer.

Using Emacs as a Server

* Invoking emacsclient:: Emacs client startup options.

Printing Hard Copies

* PostScript::	         Printing buffers or regions as PostScript.
* PostScript Variables:: Customizing the PostScript printing commands.
* Printing Package::     An optional advanced printing interface.

Hyperlinking and Navigation Features

* Browse-URL::          Following URLs.
* Goto-address::        Activating URLs.
* FFAP::                Finding files etc. at point.

Customization

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Easy Customization::  Convenient way to browse and change user options.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Syntax::		The syntax table controls how words and
			  expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file.

Variables

* Examining::	        Examining or setting one variable's value.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.

Customizing Key Bindings

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your init file, `.emacs'.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing <TAB> from C-i, and so on.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.

The Init File, `~/.emacs'

* Init Syntax::	        Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::	        How Emacs finds the init file.
* Init Non-ASCII::      Using non-ASCII characters in an init file.

Dealing with Emacs Trouble

* DEL Does Not Delete:: What to do if <DEL> doesn't delete.
* Stuck Recursive::     `[...]' in mode line around the parentheses.
* Screen Garbled::      Garbage on the screen.
* Text Garbled::        Garbage in the text.
* Memory Full::         How to cope when you run out of memory.
* After a Crash::       Recovering editing in an Emacs session that crashed.
* Emergency Escape::    Emergency escape---
                          What to do if Emacs stops responding.
* Total Frustration::   When you are at your wits' end.

Reporting Bugs

* Bug Criteria::        Have you really found a bug?
* Understanding Bug Reporting::	How to report a bug effectively.
* Checklist::		Steps to follow for a good bug report.
* Sending Patches::	How to send a patch for GNU Emacs.

Command Line Arguments for Emacs Invocation

* Action Arguments::	Arguments to visit files, load libraries,
			  and call functions.
* Initial Options::     Arguments that take effect while starting Emacs.
* Command Example::     Examples of using command line arguments.
* Resume Arguments::	Specifying arguments when you resume a running Emacs.
* Environment::         Environment variables that Emacs uses.
* Display X::           Changing the default display and using remote login.
* Font X::	        Choosing a font for text, under X.
* Colors::	        Choosing display colors.
* Window Size X::       Start-up window size, under X.
* Borders X::	        Internal and external borders, under X.
* Title X::             Specifying the initial frame's title.
* Icons X::             Choosing what sort of icon to use, under X.
* Misc X::              Other display options.

Environment Variables

* General Variables::	Environment variables that all versions of Emacs use.
* Misc Variables::	Certain system specific variables.
* MS-Windows Registry:: An alternative to the environment on MS-Windows.

X Options and Resources

* Resources::           Using X resources with Emacs (in general).
* Table of Resources::  Table of specific X resources that affect Emacs.
* Face Resources::      X resources for customizing faces.
* Lucid Resources::     X resources for Lucid menus.
* LessTif Resources::   X resources for LessTif and Motif menus.
* GTK resources::       Resources for GTK widgets.

Emacs and Mac OS

* Mac Input::           Keyboard and mouse input on Mac.
* Mac International::   International character sets on Mac.
* Mac Environment Variables::  Setting environment variables for Emacs.
* Mac Directories::     Volumes and directories on Mac.
* Mac Font Specs::      Specifying fonts on Mac.
* Mac Functions::       Mac-specific Lisp functions.

Emacs and Microsoft Windows/MS-DOS

* Text and Binary::     Text files use CRLF to terminate lines.
* Windows Files::       File-name conventions on Windows.
* ls in Lisp::          Emulation of `ls' for Dired.
* Windows HOME::        Where Emacs looks for your `.emacs'.
* Windows Keyboard::    Windows-specific keyboard features.
* Windows Mouse::       Windows-specific mouse features.
* Windows Processes::   Running subprocesses on Windows.
* Windows Printing::    How to specify the printer on MS-Windows.
* Windows Misc::        Miscellaneous Windows features.
* MS-DOS::              Using Emacs on MS-DOS (otherwise known as "MS-DOG").


File: emacs,  Node: Distrib,  Next: Intro,  Prev: Top,  Up: Top

Distribution
************

GNU Emacs is "free software"; this means that everyone is free to use
it and free to redistribute it on certain conditions.  GNU Emacs is not
in the public domain; it is copyrighted and there are restrictions on
its distribution, but these restrictions are designed to permit
everything that a good cooperating citizen would want to do.  What is
not allowed is to try to prevent others from further sharing any
version of GNU Emacs that they might get from you.  The precise
conditions are found in the GNU General Public License that comes with
Emacs and also appears in this manual(1).  *Note Copying::.

   One way to get a copy of GNU Emacs is from someone else who has it.
You need not ask for our permission to do so, or tell any one else;
just copy it.  If you have access to the Internet, you can get the
latest distribution version of GNU Emacs by anonymous FTP; see
`http://www.gnu.org/software/emacs' on our website for more information.

   You may also receive GNU Emacs when you buy a computer.  Computer
manufacturers are free to distribute copies on the same terms that
apply to everyone else.  These terms require them to give you the full
sources, including whatever changes they may have made, and to permit
you to redistribute the GNU Emacs received from them under the usual
terms of the General Public License.  In other words, the program must
be free for you when you get it, not just free for the manufacturer.

   You can also order copies of GNU Emacs from the Free Software
Foundation.  This is a convenient and reliable way to get a copy; it is
also a good way to help fund our work.  We also sell hardcopy versions
of this manual and `An Introduction to Programming in Emacs Lisp', by
Robert J. Chassell.  You can find an order form on our web site at
`http://www.gnu.org/order/order.html'.  For further information, write
to

     Free Software Foundation
     51 Franklin Street, Fifth Floor
     Boston, MA 02110-1301
     USA

   The income from distribution fees goes to support the foundation's
purpose: the development of new free software, and improvements to our
existing programs including GNU Emacs.

   If you find GNU Emacs useful, please *send a donation* to the Free
Software Foundation to support our work.  Donations to the Free
Software Foundation are tax deductible in the US.  If you use GNU Emacs
at your workplace, please suggest that the company make a donation.  If
company policy is unsympathetic to the idea of donating to charity, you
might instead suggest ordering a CD-ROM from the Foundation
occasionally, or subscribing to periodic updates.

   ---------- Footnotes ----------

   (1) This manual is itself covered by the GNU Free Documentation
License.  This license is similar in spirit to the General Public
License, but is more suitable for documentation.  *Note GNU Free
Documentation License::.


File: emacs,  Node: Intro,  Next: Glossary,  Prev: Distrib,  Up: Top

Introduction
************

You are reading about GNU Emacs, the GNU incarnation of the advanced,
self-documenting, customizable, extensible editor Emacs.  (The `G' in
`GNU' is not silent.)

   We call Emacs advanced because it provides much more than simple
insertion and deletion.  It can control subprocesses, indent programs
automatically, show two or more files at once, and edit formatted text.
Emacs editing commands operate in terms of characters, words, lines,
sentences, paragraphs, and pages, as well as expressions and comments
in various programming languages.

   "Self-documenting" means that at any time you can type a special
character, `Control-h', to find out what your options are.  You can
also use it to find out what any command does, or to find all the
commands that pertain to a topic.  *Note Help::.

   "Customizable" means that you can alter Emacs commands' behavior in
simple ways.  For example, if you use a programming language in which
comments start with `<**' and end with `**>', you can tell the Emacs
comment manipulation commands to use those strings (*note Comments::).
Another sort of customization is rearrangement of the command set.  For
example, you can rebind the basic cursor motion commands (up, down,
left and right) to any keys on the keyboard that you find comfortable.
*Note Customization::.

   "Extensible" means that you can go beyond simple customization and
write entirely new commands--programs in the Lisp language to be run by
Emacs's own Lisp interpreter.  Emacs is an "on-line extensible" system,
which means that it is divided into many functions that call each
other, any of which can be redefined in the middle of an editing
session.  Almost any part of Emacs can be replaced without making a
separate copy of all of Emacs.  Most of the editing commands of Emacs
are written in Lisp; the few exceptions could have been written in Lisp
but use C instead for efficiency.  Writing an extension is programming,
but non-programmers can use it afterwards.  *Note Emacs Lisp Intro:
(eintr)Top, if you want to learn Emacs Lisp programming.

   When running on a graphical display, Emacs provides its own menus
and convenient handling of mouse buttons.  In addition, Emacs provides
many of the benefits of a graphical display even on a text-only
terminal.  For instance, it can highlight parts of a file, display and
edit several files at once, move text between files, and edit files
while running shell commands.


File: emacs,  Node: Screen,  Next: User Input,  Prev: Acknowledgments,  Up: Top

1 The Organization of the Screen
********************************

On a text-only terminal, the Emacs display occupies the whole screen.
On a graphical display, such as on GNU/Linux using the X Window System,
Emacs creates its own windows to use.  We use the term "frame" to mean
the entire text-only screen or an entire system-level window used by
Emacs.  Emacs uses both kinds of frames, in the same way, to display
your editing.  Emacs normally starts out with just one frame, but you
can create additional frames if you wish.  *Note Frames::.

   When you start Emacs, the main central area of the frame, all except
for the top and bottom and sides, displays the text you are editing.
This area is called "the window".  At the top there is normally a "menu
bar" where you can access a series of menus; then there may be a "tool
bar", a row of icons that perform editing commands if you click on
them.  Below this, the window begins, often with a "scroll bar" on one
side.  Below the window comes the last line of the frame, a special
"echo area" or "minibuffer window", where prompts appear and you enter
information when Emacs asks for it.  See following sections for more
information about these special lines.

   You can subdivide the window horizontally or vertically to make
multiple text windows, each of which can independently display some
file or text (*note Windows::).  In this manual, the word "window"
refers to the initial large window if not subdivided, or any one of the
multiple windows you have subdivided it into.

   At any time, one window is the "selected window".  On graphical
displays, the selected window normally shows a more prominent cursor
(usually solid and blinking) while other windows show a weaker cursor
(such as a hollow box).   Text terminals have just one cursor, so it
always appears in the selected window.

   Most Emacs commands implicitly apply to the text in the selected
window; the text in unselected windows is mostly visible for reference.
However, mouse commands generally operate on whatever window you click
them in, whether selected or not.  If you use multiple frames on a
graphical display, then giving the input focus to a particular frame
selects a window in that frame.

   Each window's last line is a "mode line", which describes what is
going on in that window.  It appears in different color and/or a "3D"
box if the terminal supports them; its contents normally begin with
`--:--  *scratch*' when Emacs starts.  The mode line displays status
information such as what buffer is being displayed above it in the
window, what major and minor modes are in use, and whether the buffer
contains unsaved changes.

* Menu:

* Point::	        The place in the text where editing commands operate.
* Echo Area::           Short messages appear at the bottom of the screen.
* Mode Line::	        Interpreting the mode line.
* Menu Bar::            How to use the menu bar.


File: emacs,  Node: Point,  Next: Echo Area,  Up: Screen

1.1 Point
=========

Within Emacs, the active cursor shows the location at which editing
commands will take effect.  This location is called "point".  Many
Emacs commands move point through the text, so that you can edit at
different places in it.  You can also place point by clicking mouse
button 1 (normally the left button).

   While the cursor appears to be _on_ a character, you should think of
point as _between_ two characters; it points _before_ the character
that appears under the cursor.  For example, if your text looks like
`frob' with the cursor over the `b', then point is between the `o' and
the `b'.  If you insert the character `!' at that position, the result
is `fro!b', with point between the `!' and the `b'.  Thus, the cursor
remains over the `b', as before.

   Sometimes people speak of "the cursor" when they mean "point," or
speak of commands that move point as "cursor motion" commands.

   If you are editing several files in Emacs, each in its own buffer,
each buffer has its own point location.  A buffer that is not currently
displayed remembers its point location in case you display it again
later.  When Emacs displays multiple windows, each window has its own
point location.  If the same buffer appears in more than one window,
each window has its own point position in that buffer, and (when
possible) its own cursor.

   A text-only terminal has just one cursor, in the selected window.
The other windows do not show a cursor, even though they do have their
own position of point.  When Emacs updates the screen on a text-only
terminal, it has to put the cursor temporarily at the place the output
goes.  This doesn't mean point is there, though.  Once display updating
finishes, Emacs puts the cursor where point is.

   On graphical displays, Emacs shows a cursor in each window; the
selected window's cursor is solid and blinking, and the other cursors
are just hollow.  Thus, the most prominent cursor always shows you the
selected window, on all kinds of terminals.

   *Note Cursor Display::, for customizable variables that control
display of the cursor or cursors.

   The term "point" comes from the character `.', which was the command
in TECO (the language in which the original Emacs was written) for
accessing the value now called "point."


File: emacs,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Screen

1.2 The Echo Area
=================

The line at the bottom of the frame (below the mode line) is the "echo
area".  It is used to display small amounts of text for various
purposes.

   "Echoing" means displaying the characters that you type.  At the
command line, the operating system normally echoes all your input.
Emacs handles echoing differently.

   Single-character commands do not echo in Emacs, and multi-character
commands echo only if you pause while typing them.  As soon as you pause
for more than a second in the middle of a command, Emacs echoes all the
characters of the command so far.  This is to "prompt" you for the rest
of the command.  Once echoing has started, the rest of the command
echoes immediately as you type it.  This behavior is designed to give
confident users fast response, while giving hesitant users maximum
feedback.  You can change this behavior by setting a variable (*note
Display Custom::).

   If a command cannot do its job, it may display an "error message" in
the echo area.  Error messages are accompanied by beeping or by
flashing the screen.  The error also discards any input you have typed
ahead.

   Some commands display informative messages in the echo area.  These
messages look much like error messages, but they are not announced with
a beep and do not throw away input.  Sometimes the message tells you
what the command has done, when this is not obvious from looking at the
text being edited.  Sometimes the sole purpose of a command is to show
you a message giving you specific information--for example, `C-x ='
(hold down <CTRL> and type `x', then let go of <CTRL> and type `=')
displays a message describing the character position of point in the
text and its current column in the window.  Commands that take a long
time often display messages ending in `...' while they are working, and
add `done' at the end when they are finished.  They may also indicate
progress with percentages.

   Echo-area informative messages are saved in an editor buffer named
`*Messages*'.  (We have not explained buffers yet; see *note Buffers::,
for more information about them.)  If you miss a message that appears
briefly on the screen, you can switch to the `*Messages*' buffer to see
it again.  (Successive progress messages are often collapsed into one
in that buffer.)

   The size of `*Messages*' is limited to a certain number of lines.
The variable `message-log-max' specifies how many lines.  Once the
buffer has that many lines, adding lines at the end deletes lines from
the beginning, to keep the size constant.  *Note Variables::, for how
to set variables such as `message-log-max'.

   The echo area is also used to display the "minibuffer", a window
where you can input arguments to commands, such as the name of a file
to be edited.  When the minibuffer is in use, the echo area begins with
a prompt string that usually ends with a colon; also, the cursor
appears in that line because it is the selected window.  You can always
get out of the minibuffer by typing `C-g'.  *Note Minibuffer::.


File: emacs,  Node: Mode Line,  Next: Menu Bar,  Prev: Echo Area,  Up: Screen

1.3 The Mode Line
=================

Each text window's last line is a "mode line", which describes what is
going on in that window.  The mode line starts and ends with dashes.
When there is only one text window, the mode line appears right above
the echo area; it is the next-to-last line in the frame.  On a
text-only terminal, the mode line is in inverse video if the terminal
supports that; on a graphics display, the mode line has a 3D box
appearance to help it stand out.  The mode line of the selected window
is highlighted if possible; see *note Optional Mode Line::, for more
information.

   Normally, the mode line looks like this:

     -CS:CH-FR  BUF      POS LINE   (MAJOR MINOR)------

This gives information about the window and the buffer it displays: the
buffer's name, what major and minor modes are in use, whether the
buffer's text has been changed, and how far down the buffer you are
currently looking.

   CH contains two stars `**' if the text in the buffer has been edited
(the buffer is "modified"), or `--' if the buffer has not been edited.
For a read-only buffer, it is `%*' if the buffer is modified, and `%%'
otherwise.

   FR gives the selected frame name (*note Frames::).  It appears only
on text-only terminals.  The initial frame's name is `F1'.

   BUF is the name of the window's "buffer".  Usually this is the same
as the name of a file you are editing.  *Note Buffers::.

   The buffer displayed in the selected window (the window with the
cursor) is the "current buffer", where editing happens.  When a
command's effect applies to "the buffer," we mean it does those things
to the current buffer.

   POS tells you whether there is additional text above the top of the
window, or below the bottom.  If your buffer is small and it is all
visible in the window, POS is `All'.  Otherwise, it is `Top' if you are
looking at the beginning of the buffer, `Bot' if you are looking at the
end of the buffer, or `NN%', where NN is the percentage of the buffer
above the top of the window.  With Size Indication mode, you can
display the size of the buffer as well.  *Note Optional Mode Line::.

   LINE is `L' followed by the current line number of point.  This is
present when Line Number mode is enabled (it normally is).  You can
display the current column number too, by turning on Column Number
mode.  It is not enabled by default because it is somewhat slower.
*Note Optional Mode Line::.

   MAJOR is the name of the "major mode" in effect in the buffer.  A
buffer can only be in one major mode at a time.  The major modes
available include Fundamental mode (the least specialized), Text mode,
Lisp mode, C mode, Texinfo mode, and many others.  *Note Major Modes::,
for details of how the modes differ and how to select them.

   Some major modes display additional information after the major mode
name.  For example, Rmail buffers display the current message number and
the total number of messages.  Compilation buffers and Shell buffers
display the status of the subprocess.

   MINOR is a list of some of the "minor modes" that are turned on at
the moment in the window's chosen buffer.  For example, `Fill' means
that Auto Fill mode is on.  `Abbrev' means that Word Abbrev mode is on.
`Ovwrt' means that Overwrite mode is on.  *Note Minor Modes::, for more
information.

   `Narrow' means that the buffer being displayed has editing
restricted to only a portion of its text.  (This is not really a minor
mode, but is like one.)  *Note Narrowing::.  `Def' means that a
keyboard macro is being defined.  *Note Keyboard Macros::.

   In addition, if Emacs is inside a recursive editing level, square
brackets (`[...]') appear around the parentheses that surround the
modes.  If Emacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since recursive editing
levels affect Emacs globally, not just one buffer, the square brackets
appear in every window's mode line or not in any of them.  *Note
Recursive Edit::.

   CS states the coding system used for the file you are editing.  A
dash indicates the default state of affairs: no code conversion, except
for end-of-line translation if the file contents call for that.  `='
means no conversion whatsoever.  Nontrivial code conversions are
represented by various letters--for example, `1' refers to ISO Latin-1.
*Note Coding Systems::, for more information.

   On a text-only terminal, CS includes two additional characters which
describe the coding system for keyboard input and the coding system for
terminal output.  They come right before the coding system used for the
file you are editing.

   If you are using an input method, a string of the form `I>' is added
to the beginning of CS; I identifies the input method.  (Some input
methods show `+' or `@' instead of `>'.)  *Note Input Methods::.

   When multibyte characters are not enabled, CS does not appear at
all.  *Note Enabling Multibyte::.

   The colon after CS changes to another string in some cases.  Emacs
uses newline characters to separate lines in the buffer.  Some files
use different conventions for separating lines: either carriage-return
linefeed (the MS-DOS convention) or just carriage-return (the Macintosh
convention).  If the buffer's file uses carriage-return linefeed, the
colon changes to either a backslash (`\') or `(DOS)', depending on the
operating system.  If the file uses just carriage-return, the colon
indicator changes to either a forward slash (`/') or `(Mac)'.  On some
systems, Emacs displays `(Unix)' instead of the colon for files that
use newline as the line separator.

   *Note Optional Mode Line::, to add other handy information to the
mode line, such as the size of the buffer, the current column number of
point, and whether new mail for you has arrived.

   The mode line is mouse-sensitive; when you move the mouse across
various parts of it, Emacs displays help text to say what a click in
that place will do.  *Note Mode Line Mouse::.


File: emacs,  Node: Menu Bar,  Prev: Mode Line,  Up: Screen

1.4 The Menu Bar
================

Each Emacs frame normally has a "menu bar" at the top which you can use
to perform common operations.  There's no need to list them here, as
you can more easily see them yourself.

   On a graphical display, you can use the mouse to choose a command
from the menu bar.  A right-arrow at the end of the menu item means it
leads to a subsidiary menu; `...' at the end means that the command
invoked will read arguments (further input from you) before it actually
does anything.

   You can also invoke the first menu bar item by pressing <F10> (to run
the command `menu-bar-open').  You can then navigate the menus with the
arrow keys.  You select an item by pressing <RET> and cancel menu
navigation with <ESC>.

   To view the full command name and documentation for a menu item, type
`C-h k', and then select the menu bar with the mouse in the usual way
(*note Key Help::).

   On text-only terminals with no mouse, you can use the menu bar by
typing `M-`' or <F10> (these run the command `tmm-menubar').  This lets
you select a menu item with the keyboard.  A provisional choice appears
in the echo area.  You can use the up and down arrow keys to move
through the menu to different items, and then you can type <RET> to
select the item.

   Each menu item also has an assigned letter or digit which designates
that item; it is usually the initial of some word in the item's name.
This letter or digit is separated from the item name by `=>'.  You can
type the item's letter or digit to select the item.

   Some of the commands in the menu bar have ordinary key bindings as
well; one such binding is shown in parentheses after the item itself.


File: emacs,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

2 Kinds of User Input
*********************

GNU Emacs is designed for use with keyboard commands because that is
the most efficient way to edit.  You can do editing with the mouse, as
in other editors, and you can give commands with the menu bar and tool
bar, and scroll with the scroll bar.  But if you keep on editing that
way, you won't get the benefits of Emacs.  Therefore, this manual
documents primarily how to edit with the keyboard.  You can force
yourself to practice using the keyboard by using the shell command
`emacs -nw' to start Emacs, so that the mouse won't work.

   Emacs uses an extension of the ASCII character set for keyboard
input; it also accepts non-character input events including function
keys and mouse button actions.

   ASCII consists of 128 character codes.  Some of these codes are
assigned graphic symbols such as `a' and `='; the rest are control
characters, such as `Control-a' (usually written `C-a' for short).
`C-a' gets its name from the fact that you type it by holding down the
<CTRL> key while pressing `a'.

   Some ASCII control characters have special names, and most terminals
have special keys you can type them with: for example, <RET>, <TAB>,
<DEL> and <ESC>.  The space character is usually known as <SPC>, even
though strictly speaking it is a graphic character that is blank.

   Emacs extends the ASCII character set with thousands more printing
characters (*note International::), additional control characters, and a
few more modifiers that can be combined with any character.

   On ASCII terminals, there are only 32 possible control characters.
These are the control variants of letters and `@[]\^_'.  In addition,
the shift key is meaningless with control characters: `C-a' and `C-A'
are the same character, and Emacs cannot distinguish them.

   The Emacs character set has room for control variants of all
printing characters, and distinguishes `C-A' from `C-a'.  Graphical
terminals make it possible to enter all these characters.  For example,
`C--' (that's Control-Minus) and `C-5' are meaningful Emacs commands on
a graphical terminal.

   Another Emacs character-set extension is additional modifier bits.
Only one modifier bit is commonly used; it is called Meta.  Every
character has a Meta variant; examples include `Meta-a' (normally
written `M-a', for short), `M-A' (different from `M-a', but they are
normally equivalent in Emacs), `M-<RET>', and `M-C-a'.  That last means
`a' with both the <CTRL> and <META> modifiers.  We usually write it as
`C-M-a' rather than `M-C-a', for reasons of tradition.

   Some terminals have a <META> key, and allow you to type Meta
characters by holding this key down.  Thus, you can type `Meta-a' by
holding down <META> and pressing `a'.  The <META> key works much like
the <SHIFT> key.  In fact, this key is more often labeled <ALT> or
<EDIT>, instead of <META>; on a Sun keyboard, it may have a diamond on
it.

   If there is no <META> key, you can still type Meta characters using
two-character sequences starting with <ESC>.  Thus, you can enter `M-a'
by typing `<ESC> a'.  You can enter `C-M-a' by typing `<ESC> C-a'.
Unlike <META>, which modifies other characters, <ESC> is a separate
character.  You don't hold down <ESC> while typing the next character;
instead, you press it and release it, then you enter the next character.
<ESC> is allowed on terminals with <META> keys, too, in case you have
formed a habit of using it.

   Emacs defines several other modifier keys that can be applied to any
input character.  These are called <SUPER>, <HYPER> and <ALT>.  We
write `s-', `H-' and `A-' to say that a character uses these modifiers.
Thus, `s-H-C-x' is short for `Super-Hyper-Control-x'.  Not all
graphical terminals actually provide keys for these modifier flags--in
fact, many terminals have a key labeled <ALT> which is really a <META>
key.  The standard key bindings of Emacs do not include any characters
with these modifiers.  But you can assign them meanings of your own by
customizing Emacs.

   If your keyboard lacks one of these modifier keys, you can enter it
using `C-x @': `C-x @ h' adds the "hyper" flag to the next character,
`C-x @ s' adds the "super" flag, and `C-x @ a' adds the "alt" flag.
For instance, `C-x @ h C-a' is a way to enter `Hyper-Control-a'.
(Unfortunately there is no way to add two modifiers by using `C-x @'
twice for the same character, because the first one goes to work on the
`C-x'.)

   Keyboard input includes keyboard keys that are not characters at
all, such as function keys and arrow keys.  Mouse buttons are also not
characters.  However, you can modify these events with the modifier
keys <CTRL>, <META>, <SUPER>, <HYPER> and <ALT>, just like keyboard
characters.

   Input characters and non-character inputs are collectively called
"input events".  *Note Input Events: (elisp)Input Events, for the full
Lisp-level details.  If you are not doing Lisp programming, but simply
want to redefine the meaning of some characters or non-character
events, see *note Customization::.

   ASCII terminals cannot really send anything to the computer except
ASCII characters.  These terminals use a sequence of characters to
represent each function key.  But that is invisible to the Emacs user,
because the keyboard input routines catch these special sequences and
convert them to function key events before any other part of Emacs gets
to see them.

   On graphical displays, the window manager is likely to block the
character `Meta-<TAB>' before Emacs can see it.  It may also block
`Meta-<SPC>', `C-M-d' and `C-M-l'.  If you have these problems, we
recommend that you customize your window manager to turn off those
commands, or put them on key combinations that Emacs does not use.


File: emacs,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

3 Keys
******

A "key sequence" ("key", for short) is a sequence of input events that
is meaningful as a unit--a "single command."  Some Emacs command
sequences are invoked by just one character or one event; for example,
just `C-f' moves forward one character in the buffer.  But Emacs also
has commands that take two or more events to invoke.

   If a sequence of events is enough to invoke a command, it is a
"complete key".  Examples of complete keys include `C-a', `X', <RET>,
<NEXT> (a function key), <DOWN> (an arrow key), `C-x C-f', and `C-x 4
C-f'.  If it isn't long enough to be complete, we call it a "prefix
key".  The above examples show that `C-x' and `C-x 4' are prefix keys.
Every key sequence is either a complete key or a prefix key.

   Most single characters constitute complete keys in the standard Emacs
command bindings.  A few of them are prefix keys.  A prefix key combines
with the following input event to make a longer key sequence, which may
itself be complete or a prefix.  For example, `C-x' is a prefix key, so
`C-x' and the next input event combine to make a two-event key
sequence.  Most of these key sequences are complete keys, including
`C-x C-f' and `C-x b'.  A few, such as `C-x 4' and `C-x r', are
themselves prefix keys that lead to three-event key sequences.  There's
no limit to the length of a key sequence, but in practice people rarely
use sequences longer than four events.

   You can't add input events onto a complete key.  For example, the
two-event sequence `C-f C-k' is not a key, because the `C-f' is a
complete key in itself.  It's impossible to give `C-f C-k' an
independent meaning as a command.  `C-f C-k' is two key sequences, not
one.

   All told, the prefix keys in Emacs are `C-c', `C-h', `C-x', `C-x
<RET>', `C-x @', `C-x a', `C-x n', `C-x r', `C-x v', `C-x 4', `C-x 5',
`C-x 6', <ESC>, `M-g', and `M-o'.  (<F1> and <F2> are aliases for `C-h'
and `C-x 6'.)  This list is not cast in stone; it describes the
standard key bindings.  If you customize Emacs, you can make new prefix
keys, or eliminate some of the standard ones (not recommended for most
users).  *Note Key Bindings::.

   If you make or eliminate prefix keys, that changes the set of
possible key sequences.  For example, if you redefine `C-f' as a
prefix, `C-f C-k' automatically becomes a key (complete, unless you
define that too as a prefix).  Conversely, if you remove the prefix
definition of `C-x 4', then `C-x 4 f' and `C-x 4 ANYTHING' are no
longer keys.

   Typing the help character (`C-h' or <F1>) after a prefix key
displays a list of the commands starting with that prefix.  There are a
few prefix keys after which `C-h' does not work--for historical
reasons, they define other meanings for `C-h' which are painful to
change.  <F1> works after all prefix keys.


File: emacs,  Node: Commands,  Next: Text Characters,  Prev: Keys,  Up: Top

4 Keys and Commands
*******************

This manual is full of passages that tell you what particular keys do.
But Emacs does not assign meanings to keys directly.  Instead, Emacs
assigns meanings to named "commands", and then gives keys their
meanings by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is
usually made of a few English words separated by dashes; for example,
`next-line' or `forward-word'.  A command also has a "function
definition" which is a Lisp program; this is how the command does its
work.  In Emacs Lisp, a command is a Lisp function with special options
to read arguments and for interactive use.  For more information on
commands and functions, see *note What Is a Function: (elisp)What Is a
Function.  (The definition here is simplified slightly.)

   The bindings between keys and commands are recorded in tables called
"keymaps".  *Note Keymaps::.

   When we say that "`C-n' moves down vertically one line" we are
glossing over a subtle distinction that is irrelevant in ordinary use,
but vital for Emacs customization.  The command `next-line' does a
vertical move downward.  `C-n' has this effect _because_ it is bound to
`next-line'.  If you rebind `C-n' to the command `forward-word', `C-n'
will move forward one word instead.  Rebinding keys is an important
method of customization.

   In the rest of this manual, we usually ignore this distinction to
keep things simple.  We will often speak of keys like `C-n' as
commands, even though strictly speaking the key is bound to a command.
Usually we state the name of the command which really does the work in
parentheses after mentioning the key that runs it.  For example, we
will say that "The command `C-n' (`next-line') moves point vertically
down," meaning that the command `next-line' moves vertically down, and
the key `C-n' is normally bound to it.

   Since we are discussing customization, we should tell you about
"variables".  Often the description of a command will say, "To change
this, set the variable `mumble-foo'."  A variable is a name used to
store a value.  Most of the variables documented in this manual are
meant for customization: some command or other part of Emacs examines
the variable and behaves differently according to the value that you
set.  You can ignore the information about variables until you are
interested in customizing them.  Then read the basic information on
variables (*note Variables::) and the information about specific
variables will make sense.


File: emacs,  Node: Text Characters,  Next: Entering Emacs,  Prev: Commands,  Up: Top

5 Character Set for Text
************************

Text in Emacs buffers is a sequence of characters.  In the simplest
case, these are ASCII characters, each stored in one 8-bit byte.  Both
ASCII control characters (octal codes 000 through 037, and 0177) and
ASCII printing characters (codes 040 through 0176) are allowed.  The
other modifier flags used in keyboard input, such as Meta, are not
allowed in buffers.

   Non-ASCII printing characters can also appear in buffers, when
multibyte characters are enabled.  They have character codes starting
at 256, octal 0400, and each one is represented as a sequence of two or
more bytes.  *Note International::.  Single-byte characters with codes
128 through 255 can also appear in multibyte buffers.  However,
non-ASCII control characters cannot appear in a buffer.

   Some ASCII control characters serve special purposes in text, and
have special names.  For example, the newline character (octal code
012) is used in the buffer to end a line, and the tab character (octal
code 011) is used for indenting to the next tab stop column (normally
every 8 columns).  *Note Text Display::.

   If you disable multibyte characters, then you can use only one
alphabet of non-ASCII characters, which all fit in one byte.  They use
octal codes 0200 through 0377.  *Note Unibyte Mode::.


File: emacs,  Node: Entering Emacs,  Next: Exiting,  Prev: Text Characters,  Up: Top

6 Entering and Exiting Emacs
****************************

The usual way to invoke Emacs is with the shell command `emacs'.  Emacs
clears the screen, then displays an initial help message and copyright
notice.  Some operating systems discard your type-ahead when Emacs
starts up; they give Emacs no way to prevent this.  On those systems,
wait for Emacs to clear the screen before you start typing.

   From a shell window under the X Window System, run Emacs in the
background with `emacs&'.  This way, Emacs won't tie up the shell
window, so you can use it to run other shell commands while Emacs is
running.  You can type Emacs commands as soon as you direct your
keyboard input to an Emacs frame.

   When Emacs starts up, it creates a buffer named `*scratch*'.  That's
the buffer you start out in.  The `*scratch*' buffer uses Lisp
Interaction mode; you can use it to type Lisp expressions and evaluate
them.  You can also ignore that capability and just write notes there.
You can specify a different major mode for this buffer by setting the
variable `initial-major-mode' in your init file.  *Note Init File::.

   It is possible to specify files to be visited, Lisp files to be
loaded, and functions to be called through Emacs command-line
arguments.  *Note Emacs Invocation::.  The feature exists mainly for
compatibility with other editors, and for scripts.

   Many editors are designed to edit one file.  When done with that
file, you exit the editor.  The next time you want to edit a file, you
must start the editor again.  Working this way, it is convenient to use
a command-line argument to say which file to edit.

   However, killing Emacs after editing one each and starting it afresh
for the next file is both unnecessary and harmful, since it denies you
the full power of Emacs.  Emacs can visit more than one file in a
single editing session, and that is the right way to use it.  Exiting
the Emacs session loses valuable accumulated context, such as the kill
ring, registers, undo history, and mark ring.  These features are
useful for operating on multiple files, or even continuing to edit one
file.  If you kill Emacs after each file, you don't take advantage of
them.

   The recommended way to use GNU Emacs is to start it only once, just
after you log in, and do all your editing in the same Emacs session.
Each time you edit a file, you visit it with the existing Emacs, which
eventually has many files in it ready for editing.  Usually you do not
kill Emacs until you are about to log out.  *Note Files::, for more
information on visiting more than one file.

   To edit a file from another program while Emacs is running, you can
use the `emacsclient' helper program to open a file in the already
running Emacs.  *Note Emacs Server::.


File: emacs,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

7 Exiting Emacs
***************

There are two commands for exiting Emacs, and three kinds of exiting:
"iconifying" Emacs, "suspending" Emacs, and "killing" Emacs.

   "Iconifying" means replacing the Emacs frame with a small box or
"icon" on the screen.  This is the usual way to exit Emacs when you're
using a graphical display--if you bother to "exit" at all.  (Just
switching to another application is usually sufficient.)

   "Suspending" means stopping Emacs temporarily and returning control
to its parent process (usually a shell), allowing you to resume editing
later in the same Emacs job.  This is the usual way to exit Emacs when
running it on a text terminal.

   "Killing" Emacs means destroying the Emacs job.  You can run Emacs
again later, but you will get a fresh Emacs; there is no way to resume
the same editing session after it has been killed.

`C-z'
     Suspend Emacs (`suspend-emacs') or iconify a frame
     (`iconify-or-deiconify-frame').

`C-x C-c'
     Kill Emacs (`save-buffers-kill-emacs').

   On graphical displays, `C-z' runs the command
`iconify-or-deiconify-frame', which temporarily iconifies (or
"minimizes") the selected Emacs frame (*note Frames::).  You can then
use the window manager to select some other application.  (You could
select another application without iconifying Emacs first, but getting
the Emacs frame out of the way can make it more convenient to find the
other application.)

   On a text terminal, `C-z' runs the command `suspend-emacs'.
Suspending Emacs takes you back to the shell from which you invoked
Emacs.  You can resume Emacs with the shell command `%emacs' in most
common shells.  On systems that don't support suspending programs,
`C-z' starts an inferior shell that communicates directly with the
terminal, and Emacs waits until you exit the subshell.  (The way to do
that is probably with `C-d' or `exit', but it depends on which shell
you use.)  On these systems, you can only get back to the shell from
which Emacs was run (to log out, for example) when you kill Emacs.

   Suspending can fail if you run Emacs under a shell that doesn't
support suspension of its subjobs, even if the system itself does
support it.  In such a case, you can set the variable `cannot-suspend'
to a non-`nil' value to force `C-z' to start an inferior shell.

   To exit and kill Emacs, type `C-x C-c' (`save-buffers-kill-emacs').
A two-character key is used to make it harder to type by accident.
This command first offers to save any modified file-visiting buffers.
If you do not save them all, it asks for confirmation with `yes' before
killing Emacs, since any changes not saved now will be lost forever.
Also, if any subprocesses are still running, `C-x C-c' asks for
confirmation about them, since killing Emacs will also kill the
subprocesses.

   If the value of the variable `confirm-kill-emacs' is non-`nil', `C-x
C-c' assumes that its value is a predicate function, and calls that
function.  If the result is non-`nil', the session is killed, otherwise
Emacs continues to run.  One convenient function to use as the value of
`confirm-kill-emacs' is the function `yes-or-no-p'.  The default value
of `confirm-kill-emacs' is `nil'.

   You can't resume an Emacs session after killing it.  Emacs can,
however, record certain session information when you kill it, such as
which files you visited, so the next time you start Emacs it will try
to visit the same files.  *Note Saving Emacs Sessions::.

   The operating system usually listens for certain special characters
whose meaning is to kill or suspend the program you are running.  This
operating system feature is turned off while you are in Emacs.  The
meanings of `C-z' and `C-x C-c' as keys in Emacs were inspired by the
use of `C-z' and `C-c' on several operating systems as the characters
for stopping or killing a program, but that is their only relationship
with the operating system.  You can customize these keys to run any
commands of your choice (*note Keymaps::).


File: emacs,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

8 Basic Editing Commands
************************

Here we explain the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, we suggest
you first run the Emacs learn-by-doing tutorial, by typing `Control-h
t' inside Emacs.  (`help-with-tutorial').

   To clear and redisplay the screen, type `C-l' (`recenter').

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        Moving the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Basic Undo::	        Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::	        Making and deleting blank lines.
* Continuation Lines::  How Emacs displays lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command N times.
* Repeating::           Repeating the previous command quickly.


File: emacs,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

8.1 Inserting Text
==================

Typing printing characters inserts them into the text you are editing.
It inserts them into the buffer at the cursor; more precisely, it
inserts them at "point", but the cursor normally shows where point is.
*Note Point::.

   Insertion moves the cursor forward, and the following text moves
forward with the cursor.  If the text in the buffer is `FOOBAR', with
the cursor before the `B', and you type `XX', you get `FOOXXBAR', with
the cursor still before the `B'.

   To "delete" text you have just inserted, use the large key labeled
<DEL>, <BACKSPACE> or <DELETE> which is a short distance above the
<RET> or <ENTER> key.  Regardless of the label on that key, Emacs
thinks of it as <DEL>, and that's what we call it in this manual.
<DEL> is the key you normally use outside Emacs to erase the last
character that you typed.

   The <DEL> key deletes the character _before_ the cursor.  As a
consequence, the cursor and all the characters after it move backwards.
If you type a printing character and then type <DEL>, they cancel out.

   On most computers, Emacs sets up <DEL> automatically.  In some
cases, especially with text-only terminals, Emacs may guess wrong.  If
the key that ought to erase the last character doesn't do it in Emacs,
see *note DEL Does Not Delete::.

   Most PC keyboards have both a <BACKSPACE> key a little ways above
<RET> or <ENTER>, and a <DELETE> key elsewhere.  On these keyboards,
Emacs tries to set up <BACKSPACE> as <DEL>.  The <DELETE> key deletes
"forwards" like `C-d' (see below), which means it deletes the character
underneath the cursor (after point).

   To end a line and start typing a new one, type <RET>.  (This key may
be labeled <RETURN> or <ENTER>, but in Emacs we call it <RET>.)  This
inserts a newline character in the buffer.  If point is at the end of
the line, this creates a new blank line after it.  If point is in the
middle of a line, the effect is to split that line.  Typing <DEL> when
the cursor is at the beginning of a line deletes the preceding newline
character, thus joining the line with the one before it.

   Emacs can split lines automatically when they become too long, if
you turn on a special minor mode called "Auto Fill" mode.  *Note
Filling::, for Auto Fill mode and other methods of "filling" text.

   If you prefer printing characters to replace (overwrite) existing
text, rather than shove it to the right, you should enable Overwrite
mode, a minor mode.  *Note Minor Modes::.

   Only printing characters and <SPC> insert themselves in Emacs.
Other characters act as editing commands and do not insert themselves.
These include control characters, and characters with codes above 200
octal.  If you need to insert one of these characters in the buffer,
you must "quote" it by typing the character `Control-q'
(`quoted-insert') first.  (This character's name is normally written
`C-q' for short.)  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, it serves only to terminate the
     sequence.  Any other non-digit terminates the sequence and then
     acts as normal input--thus, `C-q 1 0 1 B' inserts `AB'.

     The use of octal sequences is disabled in ordinary non-binary
     Overwrite mode, to give you a convenient way to insert a digit
     instead of overwriting with it.

When multibyte characters are enabled, if you specify a code in the
range 0200 through 0377 octal, `C-q' assumes that you intend to use
some ISO 8859-N character set, and converts the specified code to the
corresponding Emacs character code.  *Note Enabling Multibyte::.  You
select _which_ of the ISO 8859 character sets to use through your
choice of language environment (*note Language Environments::).

   To use decimal or hexadecimal instead of octal, set the variable
`read-quoted-char-radix' to 10 or 16.  If the radix is greater than 10,
some letters starting with `a' serve as part of a character code, just
like digits.

   A numeric argument tells `C-q' how many copies of the quoted
character to insert (*note Arguments::).

   Customization information: <DEL> in most modes runs the command
`delete-backward-char'; <RET> runs the command `newline', and
self-inserting printing characters run the command `self-insert', which
inserts whatever character you typed.  Some major modes rebind <DEL> to
other commands.


File: emacs,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

8.2 Changing the Location of Point
==================================

To do more than insert characters, you have to know how to move point
(*note Point::).  The simplest way to do this is with arrow keys, or by
clicking the left mouse button where you want to move to.

   There are also control and meta characters for cursor motion.  Some
are equivalent to the arrow keys (it is faster to use these control
keys than move your hand over to the arrow keys).  Others do more
sophisticated things.

`C-a'
     Move to the beginning of the line (`move-beginning-of-line').

`C-e'
     Move to the end of the line (`move-end-of-line').

`C-f'
     Move forward one character (`forward-char').  The right-arrow key
     does the same thing.

`C-b'
     Move backward one character (`backward-char').  The left-arrow key
     has the same effect.

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`C-n'
     Move down one line vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you move to the middle of the
     next.  The down-arrow key does the same thing.

`C-p'
     Move up one line, vertically (`previous-line').  The up-arrow key
     has the same effect.  This command preserves position within the
     line, like `C-n'.

`M-r'
     Move point to left margin, vertically centered in the window
     (`move-to-window-line').  Text does not move on the screen.  A
     numeric argument says which screen line to place point on, counting
     downward from the top of the window (zero means the top line).  A
     negative argument counts lines up from the bottom (-1 means the
     bottom line).

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`C-v'
`<PAGEDOWN>'
`<PRIOR>'
     Scroll the display one screen forward, and move point if necessary
     to put it on the screen (`scroll-up').  This doesn't always move
     point, but it is commonly used to do so.  If your keyboard has a
     <PAGEDOWN> or <PRIOR> key, it does the same thing.

     Scrolling commands are described further in *note Scrolling::.

`M-v'
`<PAGEUP>'
`<NEXT>'
     Scroll one screen backward, and move point if necessary to put it
     on the screen (`scroll-down').  This doesn't always move point, but
     it is commonly used to do so.  If your keyboard has a <PAGEUP> or
     <NEXT> key, it does the same thing.

`M-x goto-char'
     Read a number N and move point to buffer position N.  Position 1
     is the beginning of the buffer.

`M-g M-g'
`M-g g'
`M-x goto-line'
     Read a number N and move point to the beginning of line number N.
     Line 1 is the beginning of the buffer.  If point is on or just
     after a number in the buffer, and you type <RET> with the
     minibuffer empty, that number is used for N.

`C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for `C-n' and `C-p' (`set-goal-column').  When a semipermanent
     goal column is in effect, those commands always try to move to
     this column, or as close as possible to it, after moving
     vertically.  The goal column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' try to
     preserve the horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then `C-n'
and `C-p', when starting at the end of the line, move to the end of
another line.  Normally, `track-eol' is `nil'.  *Note Variables::, for
how to set variables such as `track-eol'.

   `C-n' normally stops at the end of the buffer when you use it on the
last line of the buffer.  However, if you set the variable
`next-line-add-newlines' to a non-`nil' value, `C-n' on the last line
of a buffer creates an additional line at the end and moves down into
it.


File: emacs,  Node: Erasing,  Next: Basic Undo,  Prev: Moving Point,  Up: Basic

8.3 Erasing Text
================

`<DEL>'
     Delete the character before point (`delete-backward-char').

`C-d'
     Delete the character after point (`delete-char').

`<DELETE>'
`<BACKSPACE>'
     One of these keys, whichever is the large key above the <RET> or
     <ENTER> key, deletes the character before point--it is <DEL>.  If
     <BACKSPACE> is <DEL>, and your keyboard also has <DELETE>, then
     <DELETE> deletes forwards, like `C-d'.

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the <DEL> key which deletes the character
before point (that is, before the cursor).  Another key, `Control-d'
(`C-d' for short), deletes the character after point (that is, the
character that the cursor is on).  This shifts the rest of the text on
the line to the left.  If you type `C-d' at the end of a line, it joins
that line with the following line.

   To erase a larger amount of text, use the `C-k' key, which erases
(kills) a line at a time.  If you type `C-k' at the beginning or middle
of a line, it kills all the text up to the end of the line.  If you
type `C-k' at the end of a line, it joins that line with the following
line.

   *Note Killing::, for more flexible ways of killing text.


File: emacs,  Node: Basic Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

8.4 Undoing Changes
===================

Emacs records a list of changes made in the buffer text, so you can
undo recent changes, as far as the records go.  Usually each editing
command makes a separate entry in the undo records, but sometimes an
entry covers just part of a command, and very simple commands may be
grouped.

`C-x u'
     Undo one entry of the undo records--usually, one command worth
     (`undo').

`C-_'
`C-/'
     The same.

   The command `C-x u' (or `C-_' or `C-/') is how you undo.  Normally
this command undoes the last change, and moves point back to where it
was before the change.

   If you repeat `C-x u' (or its aliases), each repetition undoes
another, earlier change, back to the limit of the undo information
available.  If all recorded changes have already been undone, the undo
command displays an error message and does nothing.

   The undo command applies only to changes in the buffer; you can't
use it to undo mere cursor motion.  However, some cursor motion
commands set the mark, so if you use these commands from time to time,
you can move back to the neighborhoods you have moved through by
popping the mark ring (*note Mark Ring::).


File: emacs,  Node: Basic Files,  Next: Basic Help,  Prev: Basic Undo,  Up: Basic

8.5 Files
=========

Text that you insert in an Emacs buffer lasts only as long as the Emacs
session.  To keep any text permanently you must put it in a "file".
Files are named units of text which are stored by the operating system
for you to retrieve later by name.  To use the contents of a file in
any way, you must specify the file name.  That includes editing the
file with Emacs.

   Suppose there is a file named `test.emacs' in your home directory.
To begin editing this file in Emacs, type

     C-x C-f test.emacs <RET>

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type <RET> to terminate the argument (*note
Minibuffer::).

   Emacs obeys this command by "visiting" the file: it creates a
buffer, it copies the contents of the file into the buffer, and then
displays the buffer for editing.  If you alter the text, you can "save"
the new text in the file by typing `C-x C-s' (`save-buffer').  This
copies the altered buffer contents back into the file `test.emacs',
making them permanent.  Until you save, the changed text exists only
inside Emacs, and the file `test.emacs' is unaltered.

   To create a file, just visit it with `C-x C-f' as if it already
existed.  This creates an empty buffer, in which you can insert the
text you want to put in the file.  Emacs actually creates the file the
first time you save this buffer with `C-x C-s'.

   To learn more about using files in Emacs, see *note Files::.


File: emacs,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

8.6 Help
========

If you forget what a key does, you can find out with the Help
character, which is `C-h' (or <F1>, which is an alias for `C-h').  Type
`C-h k' followed by the key of interest; for example, `C-h k C-n' tells
you what `C-n' does.  `C-h' is a prefix key; `C-h k' is just one of its
subcommands (the command `describe-key').  The other subcommands of
`C-h' provide different kinds of help.  Type `C-h' twice to get a
description of all the help facilities.  *Note Help::.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

8.7 Blank Lines
===============

Here are special commands and techniques for inserting and deleting
blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   To insert a new line of text before an existing line, type the new
line of text, followed by <RET>.  However, it may be easier to see what
you are doing if you first make a blank line and then insert the
desired text into it.  This is easy to do using the key `C-o'
(`open-line'), which inserts a newline after point but leaves point in
front of the newline.  After `C-o', type the text for the new line.
`C-o F O O' has the same effect as `F O O <RET>', except for the final
location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument specifying how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, the `C-o'
command inserts the fill prefix on the new line, if typed at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  `C-x C-o' in a run of several blank
lines deletes all but one of them.  `C-x C-o' on a lone blank line
deletes that one.  When point is on a nonblank line, `C-x C-o' deletes
all following blank lines (if any).


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

8.8 Continuation Lines
======================

When a text line is too long to fit in one screen line, Emacs displays
it on two or more screen lines.  This is called "continuation" or "line
wrapping".  On graphical displays, Emacs indicates line wrapping with
small bent arrows in the left and right window fringes.  On text-only
terminals, Emacs displays a `\' character at the right margin of a
screen line if it is not the last in its text line.  This `\' character
says that the following screen line is not really a new text line.

   When line wrapping occurs just before a character that is wider than
one column, some columns at the end of the previous screen line may be
"empty."  In this case, Emacs displays additional `\' characters in the
"empty" columns before the `\' character that indicates continuation.

   Continued lines can be difficult to read, since lines can break in
the middle of a word.  If you prefer, you can make Emacs insert a
newline automatically when a line gets too long, by using Auto Fill
mode.  Or enable Long Lines mode, which ensures that wrapping only
occurs between words.  *Note Filling::.

   Emacs can optionally "truncate" long lines--this means displaying
just one screen line worth, and the rest of the long line does not
appear at all.  `$' in the last column or a small straight arrow in the
window's right fringe indicates a truncated line.

   *Note Line Truncation::, for more about line truncation, and other
variables that control how text is displayed.


File: emacs,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

8.9 Cursor Position Information
===============================

Here are commands to get information about the size and position of
parts of the buffer, and to count lines.

`M-x what-page'
     Display the page number of point, and the line number within that
     page.

`M-x what-line'
     Display the line number of point in the whole buffer.

`M-x line-number-mode'
`M-x column-number-mode'
     Toggle automatic display of the current line number or column
     number.  *Note Optional Mode Line::.

`M-='
     Display the number of lines in the current region
     (`count-lines-region').  *Note Mark::, for information about the
     region.

`C-x ='
     Display the character code of character after point, character
     position of point, and column of point (`what-cursor-position').

`M-x hl-line-mode'
     Enable or disable highlighting of the current line.  *Note Cursor
     Display::.

`M-x size-indication-mode'
     Toggle automatic display of the size of the buffer.  *Note
     Optional Mode Line::.

   `M-x what-line' displays the current line number in the echo area.
You can also see the current line number in the mode line; see *note
Mode Line::; but if you narrow the buffer, the line number in the mode
line is relative to the accessible portion (*note Narrowing::).  By
contrast, `what-line' shows both the line number relative to the
narrowed region and the line number relative to the whole buffer.

   `M-x what-page' counts pages from the beginning of the file, and
counts lines within the page, showing both numbers in the echo area.
*Note Pages::.

   Use `M-=' (`count-lines-region') to displays the number of lines in
the region (*note Mark::).  *Note Pages::, for the command `C-x l'
which counts the lines in the current page.

   The command `C-x =' (`what-cursor-position') shows what cursor's
column position, and other information about point and the character
after it.  It displays a line in the echo area that looks like this:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   The four values after `Char:' describe the character that follows
point, first by showing it and then by giving its character code in
decimal, octal and hex.  For a non-ASCII multibyte character, these are
followed by `file' and the character's representation, in hex, in the
buffer's coding system, if that coding system encodes the character
safely and with a single byte (*note Coding Systems::).  If the
character's encoding is longer than one byte, Emacs shows `file ...'.

   However, if the character displayed is in the range 0200 through
0377 octal, it may actually stand for an invalid UTF-8 byte read from a
file.  In Emacs, that byte is represented as a sequence of 8-bit
characters, but all of them together display as the original invalid
byte, in octal code.  In this case, `C-x =' shows `part of display ...'
instead of `file'.

   `point=' is followed by the position of point expressed as a
character count.  The start of the buffer is position 1, one character
later is position 2, and so on.  The next, larger, number is the total
number of characters in the buffer.  Afterward in parentheses comes the
position expressed as a percentage of the total size.

   `column=' is followed by the horizontal position of point, in
columns from the left edge of the window.

   If the buffer has been narrowed, making some of the text at the
beginning and the end temporarily inaccessible, `C-x =' displays
additional text describing the currently accessible range.  For
example, it might display this:

     Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

where the two extra numbers give the smallest and largest character
position that point is allowed to assume.  The characters between those
two positions are the accessible ones.  *Note Narrowing::.

   If point is at the end of the buffer (or the end of the accessible
part), the `C-x =' output does not describe a character after point.
The output might look like this:

     point=36169 of 36168 (EOB) column=0

   `C-u C-x =' displays the following additional information about a
character.

   * The character set name, and the codes that identify the character
     within that character set; ASCII characters are identified as
     belonging to the `ascii' character set.

   * The character's syntax and categories.

   * The character's encodings, both internally in the buffer, and
     externally if you were to save the file.

   * What keys to type to input the character in the current input
     method (if it supports the character).

   * If you are running Emacs on a graphical display, the font name and
     glyph code for the character.  If you are running Emacs on a
     text-only terminal, the code(s) sent to the terminal.

   * The character's text properties (*note Text Properties:
     (elisp)Text Properties.), including any faces usewd to display the
     character, and any overlays containing it (*note Overlays:
     (elisp)Overlays.).

   Here's an example showing the Latin-1 character A with grave accent,
in a buffer whose coding system is `iso-latin-1', whose terminal coding
system is `iso-latin-1' (so the terminal actually displays the
character as `A`'), and which has font-lock-mode (*note Font Lock::)
enabled:

       character: A` (2240, #o4300, #x8c0, U+00C0)
         charset: latin-iso8859-1
                  (Right-Hand Part of Latin Alphabet 1...
      code point: #x40
          syntax: w 	which means: word
        category: l:Latin
        to input: type "`A" with latin-1-prefix
     buffer code: #x81 #xC0
       file code: #xC0 (encoded by coding system iso-latin-1)
         display: terminal code #xC0

     There are text properties here:
       fontified            t


File: emacs,  Node: Arguments,  Next: Repeating,  Prev: Position Info,  Up: Basic

8.10 Numeric Arguments
======================

In mathematics and computer usage, "argument" means "data provided to a
function or operation."  You can give any Emacs command a "numeric
argument" (also called a "prefix argument").  Some commands interpret
the argument as a repetition count.  For example, `C-f' with an
argument of ten moves forward ten characters instead of one.  With
these commands, no argument is equivalent to an argument of one.
Negative arguments tell most such commands to move or act in the
opposite direction.

   If your terminal keyboard has a <META> key (labeled <ALT> on PC
keyboards), the easiest way to specify a numeric argument is to type
digits and/or a minus sign while holding down the <META> key.  For
example,

     M-5 C-n

moves down five lines.  The characters `Meta-1', `Meta-2', and so on,
as well as `Meta--', do this because they are keys bound to commands
(`digit-argument' and `negative-argument') that are defined to set up
an argument for the next command.  `Meta--' without digits normally
means -1.  Digits and `-' modified with Control, or Control and Meta,
also specify numeric arguments.

   You can also specify a numeric argument by typing `C-u'
(`universal-argument') followed by the digits.  The advantage of `C-u'
is that you can type the digits without modifier keys; thus, `C-u'
works on all terminals.  For a negative argument, type a minus sign
after `C-u'.  A minus sign without digits normally means -1.

   `C-u' alone has the special meaning of "four times": it multiplies
the argument for the next command by four.  `C-u C-u' multiplies it by
sixteen.  Thus, `C-u C-u C-f' moves forward sixteen characters.  This
is a good way to move forward "fast," since it moves about 1/5 of a
line in the usual size screen.  Other useful combinations are `C-u
C-n', `C-u C-u C-n' (move down a good fraction of a screen), `C-u C-u
C-o' (make "a lot" of blank lines), and `C-u C-k' (kill four lines).

   Some commands care whether there is an argument, but ignore its
value.  For example, the command `M-q' (`fill-paragraph') fills text;
with an argument, it justifies the text as well.  (*Note Filling::, for
more information on `M-q'.)  Plain `C-u' is a handy way of providing an
argument for such commands.

   Some commands use the value of the argument as a repeat count, but do
something peculiar when there is no argument.  For example, the command
`C-k' (`kill-line') with argument N kills N lines, including their
terminating newlines.  But `C-k' with no argument is special: it kills
the text up to the next newline, or, if point is right at the end of
the line, it kills the newline itself.  Thus, two `C-k' commands with
no arguments can kill a nonblank line, just like `C-k' with an argument
of one.  (*Note Killing::, for more information on `C-k'.)

   A few commands treat a plain `C-u' differently from an ordinary
argument.  A few others may treat an argument of just a minus sign
differently from an argument of -1.  These unusual cases are described
when they come up; they exist to make an individual command more
convenient, and they are documented in that command's documentation
string.

   You can use a numeric argument before a self-inserting character to
insert multiple copies of it.  This is straightforward when the
character is not a digit; for example, `C-u 6 4 a' inserts 64 copies of
the character `a'.  But this does not work for inserting digits; `C-u 6
4 1' specifies an argument of 641.  You can separate the argument from
the digit to insert with another `C-u'; for example, `C-u 6 4 C-u 1'
does insert 64 copies of the character `1'.

   We use the term "prefix argument" as well as "numeric argument," to
emphasize that you type these argument before the command, and to
distinguish them from minibuffer arguments that come after the command.


File: emacs,  Node: Repeating,  Prev: Arguments,  Up: Basic

8.11 Repeating a Command
========================

Many simple commands, such as those invoked with a single key or with
`M-x COMMAND-NAME <RET>', can be repeated by invoking them with a
numeric argument that serves as a repeat count (*note Arguments::).
However, if the command you want to repeat prompts for input, or uses a
numeric argument in another way, that method won't work.

   The command `C-x z' (`repeat') provides another way to repeat an
Emacs command many times.  This command repeats the previous Emacs
command, whatever that was.  Repeating a command uses the same arguments
that were used before; it does not read new arguments each time.

   To repeat the command more than once, type additional `z''s: each
`z' repeats the command one more time.  Repetition ends when you type a
character other than `z', or press a mouse button.

   For example, suppose you type `C-u 2 0 C-d' to delete 20 characters.
You can repeat that command (including its argument) three additional
times, to delete a total of 80 characters, by typing `C-x z z z'.  The
first `C-x z' repeats the command once, and each subsequent `z' repeats
it once again.


File: emacs,  Node: Minibuffer,  Next: M-x,  Prev: Basic,  Up: Top

9 The Minibuffer
****************

The "minibuffer" is where Emacs commands read complicated arguments
(anything more a single number).  We call it the "minibuffer" because
it's a special-purpose buffer with a small amount of screen space.
Minibuffer arguments can be file names, buffer names, Lisp function
names, Emacs command names, Lisp expressions, and many other
things--whatever the command wants to read.  You can use the usual
Emacs editing commands in the minibuffer to edit the argument text.

   When the minibuffer is in use, it appears in the echo area, with a
cursor.  The minibuffer display starts with a "prompt" in a distinct
color; it says what kind of input is expected and how it will be used.
Often the prompt is derived from the name of the command that is
reading the argument.  The prompt normally ends with a colon.

   Sometimes a "default argument" appears in the prompt, inside
parentheses before the colon.  The default will be used as the argument
value if you just type <RET>.  For example, commands that read buffer
names show a buffer name as the default.  You can type <RET> to operate
on that default buffer.

   The simplest way to enter a minibuffer argument is to type the text,
then <RET> to exit the minibuffer.  You can cancel the minibuffer, and
the command that wants the argument, by typing `C-g'.

   Since the minibuffer appears in the echo area, it can conflict with
other uses of the echo area.  Here is how Emacs handles such conflicts:

   * An error occurs while the minibuffer is active.

     The error message hides the minibuffer for a few seconds, or until
     you type something.  Then the minibuffer comes back.

   * A command such as `C-x =' needs to display a message in the echo
     area.

     The message hides the minibuffer for a few seconds, or until you
     type something.  Then the minibuffer comes back.

   * Keystrokes don't echo while the minibuffer is in use.

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.


File: emacs,  Node: Minibuffer File,  Next: Minibuffer Edit,  Up: Minibuffer

9.1 Minibuffers for File Names
==============================

When you use the minibuffer to enter a file name, it starts out with
some initial text--the "default directory", ending in a slash.  The
file you specify will be in this directory unless you alter or replace
it.

   For example, if the minibuffer starts out with these contents:

     Find File: /u2/emacs/src/

(where `Find File: ' is the prompt), and you type `buffer.c' as input,
that specifies the file `/u2/emacs/src/buffer.c'.  You can specify the
parent directory by adding `..'; thus, if you type `../lisp/simple.el',
you will get `/u2/emacs/lisp/simple.el'.  Alternatively, you can use
`M-<DEL>' to kill the directory names you don't want (*note Words::).

   You can kill the entire default with `C-a C-k', but there's no need
to do that.  It's easier to ignore the default, and enter an absolute
file name starting with a slash or a tilde after the default directory.
For example, to specify `/etc/termcap', just type that name:

     Find File: /u2/emacs/src//etc/termcap

GNU Emacs interprets a double slash (which is not normally useful in
file names) as, "ignore everything before the second slash in the
pair."  In the example above. `/u2/emacs/src/' is ignored, so you get
`/etc/termcap'.  The ignored part of the file name is dimmed if the
terminal allows it; to disable this dimming, turn off File Name Shadow
mode (a minor mode) with the command `M-x file-name-shadow-mode'.

   If the variable `insert-default-directory' is `nil', the default
directory is never inserted in the minibuffer--so the minibuffer starts
out empty.  Nonetheless, relative file name arguments are still
interpreted based on the same default directory.


File: emacs,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

9.2 Editing in the Minibuffer
=============================

The minibuffer is an Emacs buffer (albeit a peculiar one), and the
usual Emacs commands are available for editing the argument text.

   Since <RET> in the minibuffer is defined to exit the minibuffer, you
can't use it to insert a newline in the minibuffer.  To do that, type
`C-o' or `C-q C-j'.  (The newline character is really the ASCII
character control-J.)

   The minibuffer has its own window, which normally has space in the
frame at all times, but it only acts like an Emacs window when the
minibuffer is active.  When active, this window is much like any other
Emacs window; for instance, you can switch to another window (with `C-x
o'), edit text there, then return to the minibuffer window to finish
the argument.  You can even kill text in another window, return to the
minibuffer window, and then yank the text into the argument.  *Note
Windows::.

   There are some restrictions on the minibuffer window, however: you
cannot kill it, or split it, or switch buffers in it--the minibuffer
and its window are permanently attached.

   The minibuffer window expands vertically as necessary to hold the
text that you put in the minibuffer.  If `resize-mini-windows' is `t'
(the default), the window always resizes as needed by its contents.  If
its value is the symbol `grow-only', the window grows automatically as
needed, but shrinks (back to the normal size) only when the minibuffer
becomes inactive.  If its value is `nil', you have to adjust the height
yourself.

   The variable `max-mini-window-height' controls the maximum height
for resizing the minibuffer window: a floating-point number specifies a
fraction of the frame's height; an integer specifies the maximum number
of lines; `nil' means do not resize the minibuffer window
automatically.  The default value is 0.25.

   The `C-M-v' command in the minibuffer scrolls the help text from
commands that display help text of any sort in another window.
`M-<PAGEUP>' and `M-<PAGEDOWN>' also operate on that help text.  This
is especially useful with long lists of possible completions.  *Note
Other Window::.

   Emacs normally disallows most commands that use the minibuffer while
the minibuffer is active.  (Entering the minibuffer from the minibuffer
can be confusing.)  To allow such commands in the minibuffer, set the
variable `enable-recursive-minibuffers' to `t'.


File: emacs,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

9.3 Completion
==============

Some arguments allow "completion" to enter their value.  This means
that after you type part of the argument, Emacs can fill in the rest,
or some of it, based on what you have typed so far.

   When completion is available, certain keys--<TAB>, <RET>, and
<SPC>--are rebound to complete the text in the minibuffer before point
into a longer string chosen from a set of "completion alternatives"
provided by the command that requested the argument.  (<SPC> does not
do completion in reading file names, because it is common to use spaces
in file names on some systems.)  `?' displays a list of the possible
completions at any time.

   For example, `M-x' uses the minibuffer to read the name of a
command, so it provides a list of all Emacs command names for
completion candidates.  The completion keys match the minibuffer text
against these candidates, find any additional name characters implied
by the text already present in the minibuffer, and add those
characters.  This makes it possible to type `M-x ins <SPC> b <RET>'
instead of `M-x insert-buffer <RET>', for example.

   Case is significant in completion when it is significant in the
argument you are entering (buffer names, file names, command names, for
instance).  Thus, `fo' does not complete to `Foo'.  Completion ignores
case distinctions for certain arguments in which case does not matter.

   Completion acts only on the text before point.  If there is text in
the minibuffer after point--i.e., if you move point backward after
typing some text into the minibuffer--it remains unchanged.

* Menu:

* Example: Completion Example.    Examples of using completion.
* Commands: Completion Commands.  A list of completion commands.
* Strict Completion::             Different types of completion.
* Options: Completion Options.    Options for completion.


File: emacs,  Node: Completion Example,  Next: Completion Commands,  Up: Completion

9.3.1 Completion Example
------------------------

A concrete example may help here.  If you type `M-x au <TAB>', the
<TAB> looks for alternatives (in this case, command names) that start
with `au'.  There are several, including `auto-fill-mode' and
`auto-save-mode', but they all begin with `auto-', so the `au' in the
minibuffer completes to `auto-'.

   If you type <TAB> again immediately, it cannot determine the next
character; it could be any of `cfilrs'.  So it does not add any
characters; instead, <TAB> displays a list of all possible completions
in another window.

   Now type `f <TAB>'.  This <TAB> sees `auto-f'.  The only command
name starting with that is `auto-fill-mode', so completion fills in the
rest of that.  You have been able to enter `auto-fill-mode' by typing
just `au <TAB> f <TAB>'.


File: emacs,  Node: Completion Commands,  Next: Strict Completion,  Prev: Completion Example,  Up: Completion

9.3.2 Completion Commands
-------------------------

Here is a list of the completion commands defined in the minibuffer
when completion is allowed.

`<TAB>'
     Complete the text before point in the minibuffer as much as
     possible (`minibuffer-complete').

`<SPC>'
     Complete up to one word from the minibuffer text before point
     (`minibuffer-complete-word').  <SPC> for completion is not
     available when entering a file name, since file names often include
     spaces.

`<RET>'
     Submit the text in the minibuffer as the argument, possibly
     completing first as described in the next node
     (`minibuffer-complete-and-exit').  *Note Strict Completion::.

`?'
     Display a list of possible completions of the text before point
     (`minibuffer-completion-help').

   <SPC> completes like <TAB>, but only up to the next hyphen or space.
If you have `auto-f' in the minibuffer and type <SPC>, it finds that
the completion is `auto-fill-mode', but it only inserts `ill-', giving
`auto-fill-'.  Another <SPC> at this point completes all the way to
`auto-fill-mode'.  The command that implements this behavior is called
`minibuffer-complete-word'.

   When you display a list of possible completions, you can choose one
from it:

`Mouse-1'
`Mouse-2'
     Clicking mouse button 1 or 2 on a completion possibility chooses
     that completion (`mouse-choose-completion').  You must click in the
     list of completions, not in the minibuffer.

`<PRIOR>'
`M-v'
     Typing <PRIOR> or <PAGE-UP>, or `M-v', while in the minibuffer,
     selects the window showing the completion list buffer
     (`switch-to-completions').  This paves the way for using the
     commands below.  (Selecting that window in other ways has the same
     effect.)

`<RET>'
     Typing <RET> _in the completion list buffer_ chooses the
     completion that point is in or next to (`choose-completion').  To
     use this command, you must first switch to the completion list
     window.

`<RIGHT>'
     Typing the right-arrow key <RIGHT> _in the completion list buffer_
     moves point to the following completion possibility
     (`next-completion').

`<LEFT>'
     Typing the left-arrow key <LEFT> _in the completion list buffer_
     moves point to the previous completion possibility
     (`previous-completion').


File: emacs,  Node: Strict Completion,  Next: Completion Options,  Prev: Completion Commands,  Up: Completion

9.3.3 Strict Completion
-----------------------

There are three different ways that <RET> can do completion, depending
on how the argument will be used.

   * "Strict" completion accepts only known completion candidates.  For
     example, when `C-x k' reads the name of a buffer to kill, only the
     name of an existing buffer makes sense.  In strict completion,
     <RET> refuses to exit if the text in the minibuffer does not
     complete to an exact match.

   * "Cautious" completion is similar to strict completion, except that
     <RET> exits only if the text is an already exact match.
     Otherwise, <RET> does not exit, but it does complete the text.  If
     that completes to an exact match, a second <RET> will exit.

     Cautious completion is used for reading file names for files that
     must already exist, for example.

   * "Permissive" completion allows any input; the completion
     candidates are just suggestions.  For example, when `C-x C-f'
     reads the name of a file to visit, any file name is allowed,
     including nonexistent file (in case you want to create a file).
     In permissive completion, <RET> does not complete, it just submits
     the argument as you have entered it.

   The completion commands display a list of all possible completions
whenever they can't determine even one more character by completion.
Also, typing `?' explicitly requests such a list.  You can scroll the
list with `C-M-v' (*note Other Window::).


File: emacs,  Node: Completion Options,  Prev: Strict Completion,  Up: Completion

9.3.4 Completion Options
------------------------

When completing file names, certain file names are usually ignored.
The variable `completion-ignored-extensions' contains a list of
strings; a file name ending in any of those strings is ignored as a
completion candidate.  The standard value of this variable has several
elements including `".o"', `".elc"', `".dvi"' and `"~"'.  The effect is
that, for example, `foo' can complete to `foo.c' even though `foo.o'
exists as well.  However, if _all_ the possible completions end in
"ignored" strings, then they are not ignored.  Displaying a list of
possible completions disregards `completion-ignored-extensions'; it
shows them all.

   If an element of `completion-ignored-extensions' ends in a slash
(`/'), it's a subdirectory name; then that directory and its contents
are ignored.  Elements of `completion-ignored-extensions' which do not
end in a slash are ordinary file names, and do not apply to names of
directories.

   If `completion-auto-help' is set to `nil', the completion commands
never display a list of possibilities; you must type `?' to display the
list.

   Partial Completion mode implements a more powerful kind of
completion that can complete multiple words in parallel.  For example,
it can complete the command name abbreviation `p-b' into `print-buffer'
if no other command starts with two words whose initials are `p' and
`b'.

   To enable this mode, use `M-x partial-completion-mode', or customize
the variable `partial-completion-mode'.  This mode binds special
partial completion commands to <TAB>, <SPC>, <RET>, and `?' in the
minibuffer.  The usual completion commands are available on `M-<TAB>'
(or `C-M-i'), `M-<SPC>', `M-<RET>' and `M-?'.

   Partial completion of directories in file names uses `*' to indicate
the places for completion; thus, `/u*/b*/f*' might complete to
`/usr/bin/foo'.  For remote files, partial completion enables
completion of methods, user names and host names.  *Note Remote Files::.

   Partial Completion mode also extends `find-file' so that `<INCLUDE>'
looks for the file named INCLUDE in the directories in the path
`PC-include-file-path'.  If you set `PC-disable-includes' to non-`nil',
this feature is disabled.

   Icomplete mode presents a constantly-updated display that tells you
what completions are available for the text you've entered so far.  The
command to enable or disable this minor mode is `M-x icomplete-mode'.


File: emacs,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

9.4 Minibuffer History
======================

Every argument that you enter with the minibuffer is saved on a
"minibuffer history list" so you can easily use it again later.
Special commands fetch the text of an earlier argument into the
minibuffer, replacing the old minibuffer contents.  You can think of
them as moving through the history of previous arguments.

`<UP>'
`M-p'
     Move to the previous item in the minibuffer history, an earlier
     argument (`previous-history-element').

`<DOWN>'
`M-n'
     Move to the next item in the minibuffer history
     (`next-history-element').

`M-r REGEXP <RET>'
     Move to an earlier item in the minibuffer history that matches
     REGEXP (`previous-matching-history-element').

`M-s REGEXP <RET>'
     Move to a later item in the minibuffer history that matches REGEXP
     (`next-matching-history-element').

   To move through the minibuffer history list one item at a time, use
`M-p' or up-arrow (`previous-history-element') to fetch the next
earlier minibuffer input, and use `M-n' or down-arrow
(`next-history-element') to fetch the next later input.  These commands
don't move the cursor, they pull different saved strings into the
minibuffer.  But you can think of them as "moving" through the history
list.

   The input that you fetch from the history entirely replaces the
contents of the minibuffer.  To use it again unchanged, just type
<RET>.  You can also edit the text before you reuse it; this does not
change the history element that you "moved" to, but your new argument
does go at the end of the history list in its own right.

   For many minibuffer arguments there is a "default" value.  You can
insert the default value into the minibuffer as text by using `M-n'.
You can think of this as moving "into the future" in the history.

   There are also commands to search forward or backward through the
history; they search for history elements that match a regular
expression.  `M-r' (`previous-matching-history-element') searches older
elements in the history, while `M-s' (`next-matching-history-element')
searches newer elements.  These commands are unusual; they use the
minibuffer to read the regular expression even though they are invoked
from the minibuffer.  As with incremental searching, an upper-case
letter in the regular expression makes the search case-sensitive (*note
Search Case::).

   All uses of the minibuffer record your input on a history list, but
there are separate history lists for different kinds of arguments.  For
example, there is a list for file names, used by all the commands that
read file names.  (As a special feature, this history list records the
absolute file name, even if the name you entered was not absolute.)

   There are several other specific history lists, including one for
buffer names, one for arguments of commands like `query-replace', one
used by `M-x' for command names, and one used by `compile' for
compilation commands.  Finally, there is one "miscellaneous" history
list that most minibuffer arguments use.

   The variable `history-length' specifies the maximum length of a
minibuffer history list; adding a new element deletes the oldest
element if the list gets too long.  If the value of `history-length' is
`t', though, there is no maximum length.

   The variable `history-delete-duplicates' specifies whether to delete
duplicates in history.  If it is `t', adding a new element deletes from
the list all other elements that are equal to it.


File: emacs,  Node: Repetition,  Prev: Minibuffer History,  Up: Minibuffer

9.5 Repeating Minibuffer Commands
=================================

Every command that uses the minibuffer once is recorded on a special
history list, the "command history", together with the values of its
arguments, so that you can repeat the entire command.  In particular,
every use of `M-x' is recorded there, since `M-x' uses the minibuffer
to read the command name.

`C-x <ESC> <ESC>'
     Re-execute a recent minibuffer command from the command history
     (`repeat-complex-command').

`M-x list-command-history'
     Display the entire command history, showing all the commands `C-x
     <ESC> <ESC>' can repeat, most recent first.

   `C-x <ESC> <ESC>' is used to re-execute a recent command that used
the minibuffer.  With no argument, it repeats the last such command.  A
numeric argument specifies which command to repeat; 1 means the last
one, 2 the previous, and so on.

   `C-x <ESC> <ESC>' works by turning the previous command into a Lisp
expression and then entering a minibuffer initialized with the text for
that expression.  Even if you don't understand Lisp syntax, it will
probably be obvious which command is displayed for repetition.  If you
type just <RET>, that repeats the command unchanged.  You can also
change the command by editing the Lisp expression before you execute
it.  The repeated command is added to the front of the command history
unless it is identical to the most recently item.

   Once inside the minibuffer for `C-x <ESC> <ESC>', you can use the
minibuffer history commands (`M-p', `M-n', `M-r', `M-s'; *note
Minibuffer History::) to move through the history list of saved entire
commands.  After finding the desired previous command, you can edit its
expression as usual and then repeat it by typing <RET>.

   Incremental search does not, strictly speaking, use the minibuffer.
Therefore, although it behaves like a complex command, it normally does
not appear in the history list for `C-x <ESC> <ESC>'.  You can make
incremental search commands appear in the history by setting
`isearch-resume-in-command-history' to a non-`nil' value.  *Note
Incremental Search::.

   The list of previous minibuffer-using commands is stored as a Lisp
list in the variable `command-history'.  Each element is a Lisp
expression which describes one command and its arguments.  Lisp programs
can re-execute a command by calling `eval' with the `command-history'
element.


File: emacs,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

10 Running Commands by Name
***************************

Every Emacs command has a name that you can use to run it.  For
convenience, many commands also have key bindings.  You can run those
commands by typing the keys, or run them by name.  Most Emacs commands
have no key bindings, so the only way to run them is by name.  (*Note
Key Bindings::, for how to set up key bindings.)

   By convention, a command name consists of one or more words,
separated by hyphens; for example, `auto-fill-mode' or `manual-entry'.
Command names mostly use complete English words to make them easier to
remember.

   To run a command by name, start with `M-x', type the command name,
then terminate it with <RET>.  `M-x' uses the minibuffer to read the
command name.  The string `M-x' appears at the beginning of the
minibuffer as a "prompt" to remind you to enter a command name to be
run.  <RET> exits the minibuffer and runs the command.  *Note
Minibuffer::, for more information on the minibuffer.

   You can use completion to enter the command name.  For example, to
invoke the command `forward-char', you can type

     M-x forward-char <RET>

or

     M-x forw <TAB> c <RET>

Note that `forward-char' is the same command that you invoke with the
key `C-f'.  The existence of a key binding does not stop you from
running the command by name.

   To cancel the `M-x' and not run a command, type `C-g' instead of
entering the command name.  This takes you back to command level.

   To pass a numeric argument to the command you are invoking with
`M-x', specify the numeric argument before `M-x'.  The argument value
appears in the prompt while the command name is being read, and finally
`M-x' passes the argument to that command.

   When the command you run with `M-x' has a key binding, Emacs
mentions this in the echo area after running the command.  For example,
if you type `M-x forward-word', the message says that you can run the
same command by typing `M-f'.  You can turn off these messages by
setting the variable `suggest-key-bindings' to `nil'.

   In this manual, when we speak of running a command by name, we often
omit the <RET> that terminates the name.  Thus we might say `M-x
auto-fill-mode' rather than `M-x auto-fill-mode <RET>'.  We mention the
<RET> only for emphasis, such as when the command is followed by
arguments.

   `M-x' works by running the command `execute-extended-command', which
is responsible for reading the name of another command and invoking it.


File: emacs,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

11 Help
*******

Emacs provides extensive help features, all accessible through the
"help character", `C-h'.  This is a prefix key that is used for
commands that display documentation; the next character you type should
be a "help options", to ask for a particular kind of help.  You can
cancel the `C-h' command with `C-g'.  The function key <F1> is
equivalent to `C-h'.

   `C-h' itself is one of the help options; `C-h C-h' displays a list
of help options, with a brief description of each one
(`help-for-help').  You can scroll the list with <SPC> and <DEL>, then
type the help option you want.  To cancel, type `C-g'.

   `C-h' or <F1> means "help" in various other contexts as well.  For
instance, you can type them after a prefix key to display list of the
keys that can follow the prefix key.  (A few prefix keys don't support
`C-h' in this way, because they define other meanings for it, but they
all support <F1> for help.)

   Most help buffers use a special major mode, Help mode, which lets
you scroll conveniently with <SPC> and <DEL>.  You can also follow
hyperlinks to URLs, and to other facilities including Info nodes and
customization buffers.  *Note Help Mode::.

   If you are looking for a certain feature, but don't know what it is
called or where to look, we recommend three methods.  First, try an
apropos command, then try searching the manual index, then look in the
FAQ and the package keywords.

`C-h a TOPICS <RET>'
     This searches for commands whose names match the argument TOPICS.
     The argument can be a keyword, a list of keywords, or a regular
     expression (*note Regexps::).  This command displays all the
     matches in a new buffer.  *Note Apropos::.

`C-h i d m emacs <RET> i TOPIC <RET>'
     This searches for TOPIC in the indices of the on-line Emacs
     manual, and displays the first match found.  Press `,' to see
     subsequent matches.  You can use a regular expression as TOPIC.

`C-h i d m emacs <RET> s TOPIC <RET>'
     Similar, but searches the _text_ of the manual rather than the
     indices.

`C-h C-f'
     This displays the Emacs FAQ.  You can use the Info commands to
     browse it.

`C-h p'
     This displays the available Emacs packages based on keywords.
     *Note Library Keywords::.

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in Emacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Help Mode::           Special features of Help mode and Help buffers.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Misc Help::		Other help commands.
* Help Files::          Commands to display pre-written help files.
* Help Echo::           Help on active text and tooltips (`balloon help')


File: emacs,  Node: Help Summary,  Next: Key Help,  Up: Help

11.1 Help Summary
=================

   Here is a summary of the Emacs interactive help commands.  (The
character that follows `C-h' is the "help option.")  *Note Help
Files::, for other help commands that display fixed files of
information.

`C-h a TOPICS <RET>'
     Display a list of commands whose names match TOPICS
     (`apropos-command'; *note Apropos::).

`C-h b'
     Display all active key bindings; minor mode bindings first, then
     those of the major mode, then global bindings
     (`describe-bindings').

`C-h c KEY'
     Given a key sequence KEY, show the name of the command that it
     runs (`describe-key-briefly').  Here `c' stands for "character."
     For more extensive information on KEY, use `C-h k'.

`C-h d TOPICS <RET>'
     Display the commands and variables whose documentation matches
     TOPICS (`apropos-documentation').

`C-h e'
     Display the `*Messages*' buffer (`view-echo-area-messages').

`C-h f FUNCTION <RET>'
     Display documentation on the Lisp function named FUNCTION
     (`describe-function').  Since commands are Lisp functions, this
     works for commands too.

`C-h h'
     Display the `HELLO' file, which shows examples of various character
     sets.

`C-h i'
     Run Info, the GNU documentation browser (`info').  The complete
     Emacs manual is available on-line in Info.

`C-h k KEY'
     Display the name and documentation of the command that KEY runs
     (`describe-key').

`C-h l'
     Display a description of the last 100 characters you typed
     (`view-lossage').

`C-h m'
     Display documentation of the current major mode (`describe-mode').

`C-h p'
     Find packages by topic keyword (`finder-by-keyword').

`C-h s'
     Display the current contents of the syntax table, with an
     explanation of what they mean (`describe-syntax').  *Note Syntax::.

`C-h t'
     Enter the Emacs interactive tutorial (`help-with-tutorial').

`C-h v VAR <RET>'
     Display the documentation of the Lisp variable VAR
     (`describe-variable').

`C-h w COMMAND <RET>'
     Show which keys run the command named COMMAND (`where-is').

`C-h C CODING <RET>'
     Describe the coding system CODING (`describe-coding-system').

`C-h C <RET>'
     Describe the coding systems currently in use.

`C-h I METHOD <RET>'
     Describe the input method METHOD (`describe-input-method').

`C-h L LANGUAGE-ENV <RET>'
     Display information on the character sets, coding systems, and
     input methods used in language environment LANGUAGE-ENV
     (`describe-language-environment').

`C-h F FUNCTION <RET>'
     Enter Info and goes to the node that documents the Emacs function
     FUNCTION (`Info-goto-emacs-command-node').

`C-h K KEY'
     Enter Info and goes to the node that documents the key sequence
     KEY (`Info-goto-emacs-key-command-node').

`C-h S SYMBOL <RET>'
     Display the Info documentation on symbol SYMBOL according to the
     programming language you are editing (`info-lookup-symbol').

`C-h .'
     Display the help message for a special text area, if point is in
     one (`display-local-help').  (These include, for example, links in
     `*Help*' buffers.)


File: emacs,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

11.2 Documentation for a Key
============================

The help commands to get information about a key sequence are `C-h c'
and `C-h k'.  `C-h c KEY' displays in the echo area the name of the
command that KEY is bound to.  For example, `C-h c C-f' displays
`forward-char'.  Since command names are chosen to describe what the
commands do, this gives you a very brief description of what KEY does.

   `C-h k KEY' is similar but gives more information: it displays the
documentation string of the command as well as its name.  It displays
this information in a window, since it may not fit in the echo area.

   To find the documentation of a key sequence KEY, type `C-h K KEY'.
This displays the appropriate manual section which contains the
documentation of KEY.

   `C-h c', `C-h k' and `C-h K' work for any sort of key sequences,
including function keys, menus, and mouse events.  For instance, after
`C-h k' you can select a menu item from the menu bar, to view the
documentation string of the command it runs.

   `C-h w COMMAND <RET>' lists the keys that are bound to COMMAND.  It
displays the list in the echo area.  If it says the command is not on
any key, that means you must use `M-x' to run it.  `C-h w' runs the
command `where-is'.


File: emacs,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

11.3 Help by Command or Variable Name
=====================================

`C-h f FUNCTION <RET>' (`describe-function') displays the documentation
of Lisp function FUNCTION, in a window.  Since commands are Lisp
functions, you can use this method to view the documentation of any
command whose name you know.  For example,

     C-h f auto-fill-mode <RET>

displays the documentation of `auto-fill-mode'.  This is the only way
to get the documentation of a command that is not bound to any key (one
which you would normally run using `M-x').

   `C-h f' is also useful for Lisp functions that you use in a Lisp
program.  For example, if you have just written the expression
`(make-vector len)' and want to check that you are using `make-vector'
properly, type `C-h f make-vector <RET>'.  Because `C-h f' allows all
function names, not just command names, you may find that some of your
favorite completion abbreviations that work in `M-x' don't work in `C-h
f'.  An abbreviation that is unique among command names may not be
unique among all function names.

   If you type `C-h f <RET>', it describes the function called by the
innermost Lisp expression in the buffer around point, _provided_ that
function name is a valid, defined Lisp function.  (That name appears as
the default while you enter the argument.)  For example, if point is
located following the text `(make-vector (car x)', the innermost list
containing point is the one that starts with `(make-vector', so `C-h f
<RET>' will describe the function `make-vector'.

   `C-h f' is also useful just to verify that you spelled a function
name correctly.  If the minibuffer prompt for `C-h f' shows the
function name from the buffer as the default, it means that name is
defined as a Lisp function.  Type `C-g' to cancel the `C-h f' command
if you don't really want to view the documentation.

   `C-h v' (`describe-variable') is like `C-h f' but describes Lisp
variables instead of Lisp functions.  Its default is the Lisp symbol
around or before point, if that is the name of a defined Lisp variable.
*Note Variables::.

   Help buffers that describe Emacs variables and functions normally
have hyperlinks to the corresponding source definition, if you have the
source files installed.  (*Note Hyperlinking::.)  If you know Lisp (or
C), this provides the ultimate documentation.  If you don't know Lisp,
you should learn it.  (The Introduction to Emacs Lisp Programming,
available from the FSF through fsf.org, is a good way to get started.)
If Emacs feels you are just _using_ it, treating it as an object
program, its feelings may be hurt.  For real intimacy, read the Emacs
source code.

   To find a function's documentation in a manual, use `C-h F'
(`Info-goto-emacs-command-node').  This knows about various manuals,
not just the Emacs manual, and finds the right one.


File: emacs,  Node: Apropos,  Next: Help Mode,  Prev: Name Help,  Up: Help

11.4 Apropos
============

The "apropos" commands answer questions like, "What are the commands
for working with files?"  More precisely, you specify an "apropos
pattern", which means either a word, a list of words, or a regular
expression.  Each apropos command displays a list of items that match
the pattern, in a separate buffer.

`C-h a PATTERN <RET>'
     Search for commands whose names match PATTERN.

`M-x apropos <RET> PATTERN <RET>'
     Search for functions and variables whose names match PATTERN.
     Both interactive functions (commands) and noninteractive functions
     can be found by this command.

`M-x apropos-variable <RET> PATTERN <RET>'
     Search for user-option variables whose names match PATTERN.

`M-x apropos-value <RET> PATTERN <RET>'
     Search for functions whose definitions PATTERN, and variables
     whose values match PATTERN.

`C-h d PATTERN <RET>'
     Search for functions and variables whose *documentation strings*
     match PATTERN.

   The simplest kind of apropos pattern is one word.  Anything which
contains that word matches the pattern.  Thus, to find the commands
that work on files, type `C-h a file <RET>'.  This displays a list of
all command names that contain `file', including `copy-file',
`find-file', and so on.  Each command name comes with a brief
description and a list of keys you can currently invoke it with.  In
our example, it would say that you can invoke `find-file' by typing
`C-x C-f'.

   The `a' in `C-h a' stands for "Apropos"; `C-h a' runs the command
`apropos-command'.  This command normally checks only commands
(interactive functions); if you specify a prefix argument, it checks
noninteractive functions as well.

   For more information about a function definition, variable or symbol
property listed in the apropos buffer, you can click on it with
`Mouse-1' or `Mouse-2', or move there and type <RET>.

   When you specify more than one word in the apropos pattern, a name
must contain at least two of the words in order to match.  Thus, if you
are looking for commands to kill a chunk of text before point, you
could try `C-h a kill back backward behind before <RET>'.  The real
command name `kill-backward' will match that; if there were a command
`kill-text-before', it would also match, since it contains two of the
specified words.

   For even greater flexibility, you can specify a regular expression
(*note Regexps::).  An apropos pattern is interpreted as a regular
expression if it contains any of the regular expression special
characters, `^$*+?.\['.

   Following the conventions for naming Emacs commands, here are some
words that you'll find useful in apropos patterns.  By using them in
`C-h a', you will also get a feel for the naming conventions.

     char, line, word, sentence, paragraph, region, page, sexp, list,
     defun, rect, buffer, frame, window, face, file, dir, register,
     mode, beginning, end, forward, backward, next, previous, up, down,
     search, goto, kill, delete, mark, insert, yank, fill, indent,
     case, change, set, what, list, find, view, describe, default.

   Use `M-x apropos' instead of `C-h a' to list all the Lisp symbols
that match an apropos pattern, not just the symbols that are commands.
This command does not list key bindings by default; specify a numeric
argument if you want it to list them.

   Use `M-x apropos-variable' to list user-customizable variables that
match an apropos pattern.  If you specify a prefix argument, it lists
all matching variables.

   The `apropos-documentation' command is like `apropos' except that it
searches documentation strings instead of symbol names for matches.

   The `apropos-value' command is like `apropos' except that it
searches variables' values for matches for the apropos pattern.  With a
prefix argument, it also checks symbols' function definitions and
property lists.

   If the variable `apropos-do-all' is non-`nil', the apropos commands
always behave as if they had been given a prefix argument.

   By default, apropos lists the search results in alphabetical order.
If the variable `apropos-sort-by-scores' is non-`nil', the apropos
commands try to guess the relevance of each result, and display the
most relevant ones first.

   By default, apropos lists the search results for
`apropos-documentation' in order of relevance of the match.  If the
variable `apropos-documentation-sort-by-scores' is `nil', apropos lists
the symbols found in alphabetical order.


File: emacs,  Node: Help Mode,  Next: Library Keywords,  Prev: Apropos,  Up: Help

11.5 Help Mode Commands
=======================

Help buffers provide the same commands as View mode (*note Misc File
Ops::), plus a few special commands of their own.

`<SPC>'
     Scroll forward.

`<DEL>'
     Scroll backward.

`<RET>'
     Follow a cross reference at point.

`<TAB>'
     Move point forward to the next cross reference.

`S-<TAB>'
     Move point back to the previous cross reference.

`Mouse-1'
`Mouse-2'
     Follow a cross reference that you click on.

`C-c C-c'
     Show all documentation about the symbol at point.

   When a function name (*note Running Commands by Name: M-x.),
variable name (*note Variables::), or face name (*note Faces::) appears
in the documentation, it normally appears inside paired single-quotes.
To view the documentation of that command, variable or face, you can
click on the name with `Mouse-1' or `Mouse-2', or move point there and
type <RET>.  Use `C-c C-b' to retrace your steps.

   You can follow cross references to URLs (web pages) also.  This uses
the `browse-url' command to view the page in the browser you choose.
*Note Browse-URL::.

   There are convenient commands to move point to cross references in
the help text.  <TAB> (`help-next-ref') moves point down to the next
cross reference.  `S-<TAB>' moves up to the previous cross reference
(`help-previous-ref').

   To view all documentation about any symbol name that appears in the
text, move point to the symbol name and type `C-c C-c'
(`help-follow-symbol').  This shows all available documentation about
the symbol as a variable, function and/or face.  As above, use `C-c
C-b' to retrace your steps.


File: emacs,  Node: Library Keywords,  Next: Language Help,  Prev: Help Mode,  Up: Help

11.6 Keyword Search for Lisp Libraries
======================================

The `C-h p' command lets you search the standard Emacs Lisp libraries
by topic keywords.  Here is a partial list of keywords you can use:

abbrev        abbreviation handling, typing shortcuts, macros.
bib           code related to the `bib' bibliography processor.
c             support for the C language and related languages.
calendar      calendar and time management support.
comm          communications, networking, remote access to files.
convenience   convenience features for faster editing.
data          support for editing files of data.
docs          support for Emacs documentation.
emulations    emulations of other editors.
extensions    Emacs Lisp language extensions.
faces         support for multiple fonts.
files         support for editing and manipulating files.
frames        support for Emacs frames and window systems.
games         games, jokes and amusements.
hardware      support for interfacing with exotic hardware.
help          support for on-line help systems.
hypermedia    support for links between text or other media types.
i18n          internationalization and alternate character-set support.
internal      code for Emacs internals, build process, defaults.
languages     specialized modes for editing programming languages.
lisp          Lisp support, including Emacs Lisp.
local         code local to your site.
maint         maintenance aids for the Emacs development group.
mail          modes for electronic-mail handling.
matching      various sorts of searching and matching.
mouse         mouse support.
multimedia    images and sound support.
news          support for netnews reading and posting.
oop           support for object-oriented programming.
outlines      support for hierarchical outlining.
processes     process, subshell, compilation, and job control support.
terminals     support for terminal types.
tex           supporting code for the TeX formatter.
tools         programming tools.
unix          front-ends/assistants for, or emulators of, UNIX-like
              features.
wp            word processing.


File: emacs,  Node: Language Help,  Next: Misc Help,  Prev: Library Keywords,  Up: Help

11.7 Help for International Language Support
============================================

You can use the command `C-h L' (`describe-language-environment') to
get information about a specific language environment.  *Note Language
Environments::.  This tells you which languages this language
environment supports.  It also lists the character sets, coding
systems, and input methods that work with this language environment,
and finally shows some sample text to illustrate scripts.

   The command `C-h h' (`view-hello-file') displays the file
`etc/HELLO', which shows how to say "hello" in many languages.

   The command `C-h I' (`describe-input-method') describes an input
method--either a specified input method, or by default the input method
currently in use.  *Note Input Methods::.

   The command `C-h C' (`describe-coding-system') describes coding
systems--either a specified coding system, or the ones currently in
use.  *Note Coding Systems::.


File: emacs,  Node: Misc Help,  Next: Help Files,  Prev: Language Help,  Up: Help

11.8 Other Help Commands
========================

`C-h i' (`info') runs the Info program, which browses structured
documentation files.  The entire Emacs manual is available within Info,
along with many other manuals for the GNU system.  Type `h' after
entering Info to run a tutorial on using Info.

   With a numeric argument N, `C-h i' selects the Info buffer
`*info*<N>'.  This is useful if you want to browse multiple Info
manuals simultaneously.  If you specify just `C-u' as the prefix
argument, `C-h i' prompts for the name of a documentation file, so you
can browse a file which doesn't have an entry in the top-level Info
menu.

   The help commands `C-h F FUNCTION <RET>' and `C-h K KEY', described
above, enter Info and go straight to the documentation of FUNCTION or
KEY.

   When editing a program, if you have an Info version of the manual
for the programming language, you can use `C-h S'
(`info-lookup-symbol') to find symbol (keyword, function or variable)
in the proper manual.  The details of how this command works depend on
the major mode.

   If something surprising happens, and you are not sure what you
typed, use `C-h l' (`view-lossage').  `C-h l' displays the last 100
characters you typed in Emacs.  If you see commands that you don't
know, you can use `C-h c' to find out what they do.

   To review recent echo area messages, use `C-h e'
(`view-echo-area-messages').  This displays the buffer `*Messages*',
where those messages are kept.

   Each Emacs major mode typically redefines a few keys and makes other
changes in how editing works.  `C-h m' (`describe-mode') displays
documentation on the current major mode, which normally describes the
commands and features that are changed in this mode.

   `C-h b' (`describe-bindings') and `C-h s' (`describe-syntax') show
other information about the current environment within Emacs.  `C-h b'
displays a list of all the key bindings now in effect: first the local
bindings of the current minor modes, then the local bindings defined by
the current major mode, and finally the global bindings (*note Key
Bindings::).  `C-h s' displays the contents of the syntax table, with
explanations of each character's syntax (*note Syntax::).

   You can get a list of subcommands for a particular prefix key by
typing `C-h' after the prefix key.  (There are a few prefix keys for
which this does not work--those that provide their own bindings for
`C-h'.  One of these is <ESC>, because `<ESC> C-h' is actually `C-M-h',
which marks a defun.)


File: emacs,  Node: Help Files,  Next: Help Echo,  Prev: Misc Help,  Up: Help

11.9 Help Files
===============

The Emacs help commands described above display dynamic help based on
the current state within Emacs, or refer to manuals.  Other help
commands display pre-written, static help files.  These commands all
have the form `C-h C-CHAR'; that is, `C-h' followed by a control
character.

`C-h C-c'
     Display the Emacs copying conditions (`describe-copying').  These
     are the rules under which you can copy and redistribute Emacs.

`C-h C-d'
     Display how to download or order the latest version of Emacs and
     other GNU software (`describe-distribution').

`C-h C-e'
     Display the list of known Emacs problems, sometimes with suggested
     workarounds (`view-emacs-problems').

`C-h C-f'
     Display the Emacs frequently-answered-questions list
     (`view-emacs-FAQ').

`C-h C-n'
     Display the Emacs "news" file, which lists new features in the most
     recent version of Emacs (`view-emacs-news').

`C-h C-p'
     Display general information about the GNU Project
     (`describe-gnu-project').

`C-h C-t'
     Display the Emacs to-do list (`view-emacs-todo').

`C-h C-w'
     Display the full details on the complete absence of warranty for
     GNU Emacs (`describe-no-warranty').


File: emacs,  Node: Help Echo,  Prev: Help Files,  Up: Help

11.10 Help on Active Text and Tooltips
======================================

When a region of text is "active," so that you can select it with the
mouse or a key like `RET', it often has associated help text.  For
instance, most parts of the mode line have help text.  On graphical
displays, the help text is displayed as a "tooltip" (sometimes known as
"balloon help"), when you move the mouse over the active text.  *Note
Tooltips::.  On some systems, it is shown in the echo area.  On
text-only terminals, if Emacs cannot follow the mouse, it cannot show
the help text on mouse-over.

   You can also access text region help info using the keyboard.  The
command `C-h .' (`display-local-help') displays any help text
associated with the text at point, using the echo area.  If you want
help text to be displayed automatically whenever it is available at
point, set the variable `help-at-pt-display-when-idle' to `t'.


File: emacs,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

12 The Mark and the Region
**************************

Many Emacs commands operate on an arbitrary contiguous part of the
current buffer.  To specify the text for such a command to operate on,
you set "the mark" at one end of it, and move point to the other end.
The text between point and the mark is called "the region".  Emacs
highlights the region whenever there is one, if you enable Transient
Mark mode (*note Transient Mark::).

   Certain Emacs commands set the mark; other editing commands do not
affect it, so the mark remains where you set it last.  Each Emacs
buffer has its own mark, and setting the mark in one buffer has no
effect on other buffers' marks.  When you return to a buffer that was
current earlier, its mark is at the same place as before.

   The ends of the region are always point and the mark.  It doesn't
matter which of them was put in its current place first, or which one
comes earlier in the text--the region starts from point or the mark
(whichever comes first), and ends at point or the mark (whichever comes
last).  Every time you move point, or set the mark in a new place, the
region changes.

   Many commands that insert text, such as `C-y' (`yank') and `M-x
insert-buffer', position point and the mark at opposite ends of the
inserted text, so that the region consists of the text just inserted.

   Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark in the "mark ring".

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Momentary Mark::      Enabling Transient Mark mode momentarily.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.


File: emacs,  Node: Setting Mark,  Next: Transient Mark,  Up: Mark

12.1 Setting the Mark
=====================

Here are some commands for setting the mark:

`C-<SPC>'
     Set the mark where point is (`set-mark-command').

`C-@'
     The same.

`C-x C-x'
     Interchange mark and point (`exchange-point-and-mark').

`Drag-Mouse-1'
     Set point and the mark around the text you drag across.

`Mouse-3'
     Set the mark where point is, then move point to where you click
     (`mouse-save-then-kill').

   For example, suppose you wish to convert part of the buffer to upper
case, using the `C-x C-u' (`upcase-region') command, which operates on
the text in the region.  You can first go to the beginning of the text
to be capitalized, type `C-<SPC>' to put the mark there, move to the
end, and then type `C-x C-u'.  Or, you can set the mark at the end of
the text, move to the beginning, and then type `C-x C-u'.

   The most common way to set the mark is with the `C-<SPC>' command
(`set-mark-command').  This sets the mark where point is.  Then you can
move point away, leaving the mark behind.

   There are two ways to set the mark with the mouse.  You can drag
mouse button one across a range of text; that puts point where you
release the mouse button, and sets the mark at the other end of that
range.  Or you can click mouse button three, which sets the mark at
point (like `C-<SPC>') and then moves point where you clicked (like
`Mouse-1').

   Using the mouse to mark a region copies the region into the kill
ring in addition to setting the mark; that gives behavior consistent
with other window-driven applications.  If you don't want to modify the
kill ring, you must use keyboard commands to set the mark.  *Note Mouse
Commands::.

   When Emacs was developed, terminals had only one cursor, so Emacs
does not show where the mark is located-you have to remember.  If you
enable Transient Mark mode (see below), then the region is highlighted
when it is active; you can tell mark is at the other end of the
highlighted region.  But this only applies when the mark is active.

   The usual solution to this problem is to set the mark and then use
it soon, before you forget where it is.  Alternatively, you can see
where the mark is with the command `C-x C-x'
(`exchange-point-and-mark') which puts the mark where point was and
point where the mark was.  The extent of the region is unchanged, but
the cursor and point are now at the previous position of the mark.  In
Transient Mark mode, this command also reactivates the mark.

   `C-x C-x' is also useful when you are satisfied with the position of
point but want to move the other end of the region (where the mark is);
do `C-x C-x' to put point at that end of the region, and then move it.
Using `C-x C-x' a second time, if necessary, puts the mark at the new
position with point back at its original position.

   For more facilities that allow you to go to previously set marks, see
*note Mark Ring::.

   There is no such character as `C-<SPC>' in ASCII; when you type
<SPC> while holding down <CTRL> on a text terminal, what you get is the
character `C-@'.  This key is also bound to `set-mark-command'-so
unless you are unlucky enough to have a text terminal where typing
`C-<SPC>' does not produce `C-@', you might as well think of this
character as `C-<SPC>'.


File: emacs,  Node: Transient Mark,  Next: Momentary Mark,  Prev: Setting Mark,  Up: Mark

12.2 Transient Mark Mode
========================

On a terminal that supports colors, Emacs has the ability to highlight
the current region.  But normally it does not.  Why not?

   In the normal mode of use, every command that sets the mark also
activates it, and nothing ever deactivates it.  Thus, once you have set
the mark in a buffer, there is _always_ a region in that buffer.
Highlighting the region all the time would be a nuisance.  So normally
Emacs highlights the region only immediately after you have selected
one with the mouse.

   If you want region highlighting, you can use Transient Mark mode.
This is a more rigid mode of operation in which the region "lasts" only
until you use it; operating on the region text deactivates the mark, so
there is no region any more.  Therefore, you must explicitly set up a
region for each command that uses one.

   When Transient Mark mode is enabled, Emacs highlights the region,
whenever there is a region.  In Transient Mark mode, most of the time
there is no region; therefore, highlighting the region when it exists
is useful and not annoying.

   To enable Transient Mark mode, type `M-x transient-mark-mode'.  This
command toggles the mode; you can use the same command to turn the mode
off again.

   Here are the details of Transient Mark mode:

   * To set the mark, type `C-<SPC>' (`set-mark-command').  This makes
     the mark active and thus begins highlighting of the region.  As
     you move point, you will see the highlighted region grow and
     shrink.

   * The mouse commands for specifying the mark also make it active.
     So do keyboard commands whose purpose is to specify a region,
     including `M-@', `C-M-@', `M-h', `C-M-h', `C-x C-p', and `C-x h'.

   * You can tell that the mark is active because the region is
     highlighted.

   * When the mark is active, you can execute commands that operate on
     the region, such as killing, indenting, or writing to a file.

   * Any change to the buffer, such as inserting or deleting a
     character, deactivates the mark.  This means any subsequent
     command that operates on a region will get an error and refuse to
     operate.  You can make the region active again by typing `C-x C-x'.

   * If Delete Selection mode is also enabled, some commands delete the
     region when used while the mark is active.  *Note Mouse Commands::.

   * Quitting with `C-g' deactivates the mark.

   * Commands like `M->' and `C-s', that "leave the mark behind" in
     addition to some other primary purpose, do not activate the new
     mark.  You can activate the new region by executing `C-x C-x'
     (`exchange-point-and-mark').

   * Commands that normally set the mark before moving long distances
     (like `M-<' and `C-s') do not alter the mark in Transient Mark mode
     when the mark is active.

   * Some commands operate on the region if a region is active.  For
     instance, `C-x u' in Transient Mark mode operates on the region,
     when there is a region.  (Outside Transient Mark mode, you must
     type `C-u C-x u' if you want it to operate on the region.)  *Note
     Undo::.  Other commands that act this way are identified in their
     own documentation.

   The highlighting of the region uses the `region' face; you can
customize the appearance of the highlighted region by changing this
face.  *Note Face Customization::.

   When multiple windows show the same buffer, they can have different
regions, because they can have different values of point (though they
all share one common mark position).  Ordinarily, only the selected
window highlights its region (*note Windows::).  However, if the
variable `highlight-nonselected-windows' is non-`nil', then each window
highlights its own region (provided that Transient Mark mode is enabled
and the mark in the window's buffer is active).

   If the variable `mark-even-if-inactive' is non-`nil' in Transient
Mark mode, then commands can use the mark and the region even when it
is inactive.  Region highlighting appears and disappears just as it
normally does in Transient Mark mode, but the mark doesn't really go
away when the highlighting disappears, so you can still use region
commands.

   Transient Mark mode is also sometimes known as "Zmacs mode" because
the Zmacs editor on the MIT Lisp Machine handled the mark in a similar
way.


File: emacs,  Node: Momentary Mark,  Next: Using Region,  Prev: Transient Mark,  Up: Mark

12.3 Using Transient Mark Mode Momentarily
==========================================

If you don't like Transient Mark mode in general, you might still want
to use it once in a while.  To do this, type `C-<SPC> C-<SPC>' or `C-u
C-x C-x'.  These commands set or activate the mark, and enable
Transient Mark mode only until the mark is deactivated.

`C-<SPC> C-<SPC>'
     Set the mark at point (like plain `C-<SPC>'), and enable Transient
     Mark mode just once until the mark is deactivated.  (This is not
     really a separate command; you are using the `C-<SPC>' command
     twice.)

`C-u C-x C-x'
     Activate the mark without changing it; enable Transient Mark mode
     just once, until the mark is deactivated.  (This is the `C-x C-x'
     command, `exchange-point-and-mark', with a prefix argument.)

   One of the secondary features of Transient Mark mode is that certain
commands operate only on the region, when there is an active region.
If you don't use Transient Mark mode, the region once set never becomes
inactive, so there is no way for these commands to make such a
distinction.  Enabling Transient Mark mode momentarily gives you a way
to use these commands on the region.

   Momentary use of Transient Mark mode is also a way to highlight the
region for the time being.


File: emacs,  Node: Using Region,  Next: Marking Objects,  Prev: Momentary Mark,  Up: Mark

12.4 Operating on the Region
============================

Once you have a region and the mark is active, here are some of the
ways you can operate on the region:

   * Kill it with `C-w' (*note Killing::).

   * Save it in a register with `C-x r s' (*note Registers::).

   * Save it in a buffer or a file (*note Accumulating Text::).

   * Convert case with `C-x C-l' or `C-x C-u' (*note Case::).

   * Indent it with `C-x <TAB>' or `C-M-\' (*note Indentation::).

   * Fill it as text with `M-x fill-region' (*note Filling::).

   * Print hardcopy with `M-x print-region' (*note Printing::).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::).

   * Undo changes within it using `C-u C-x u' (*note Undo::).

   Most commands that operate on the text in the region have the word
`region' in their names.


File: emacs,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

12.5 Commands to Mark Textual Objects
=====================================

Here are the commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of following balanced expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current defun (`mark-defun').

`C-x h'
     Put region around the entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next balanced
expression (*note Expressions::).  These commands handle arguments just
like `M-f' and `C-M-f'.  Repeating these commands extends the region.
For example, you can type either `C-u 2 M-@' or `M-@ M-@' to mark the
next two words.  These commands also extend the region in Transient
Mark mode, regardless of the last command.

   Other commands set both point and mark, to delimit an object in the
buffer.  For example, `M-h' (`mark-paragraph') moves point to the
beginning of the paragraph that surrounds or follows point, and puts
the mark at the end of that paragraph (*note Paragraphs::).  It
prepares the region so you can indent, case-convert, or kill a whole
paragraph.  With a prefix argument, if the argument's value is positive,
`M-h' marks that many paragraphs starting with the one surrounding
point.  If the prefix argument is -N, `M-h' also marks N paragraphs,
running back form the one surrounding point.  In that last case, point
moves forward to the end of that paragraph, and the mark goes at the
start of the region.  Repeating the `M-h' command extends the region to
subsequent paragraphs.

   `C-M-h' (`mark-defun') similarly puts point before, and the mark
after, the current (or following) major top-level definition, or defun
(*note Moving by Defuns::).  Repeating `C-M-h' extends the region to
subsequent defuns.

   `C-x C-p' (`mark-page') puts point before the current page, and mark
at the end (*note Pages::).  The mark goes after the terminating page
delimiter (to include it in the region), while point goes after the
preceding page delimiter (to exclude it).  A numeric argument specifies
a later page (if positive) or an earlier page (if negative) instead of
the current page.

   Finally, `C-x h' (`mark-whole-buffer') sets up the entire buffer as
the region, by putting point at the beginning and the mark at the end.
(In some programs this is called "select all.")

   In Transient Mark mode, all of these commands activate the mark.


File: emacs,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Marking Objects,  Up: Mark

12.6 The Mark Ring
==================

Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark, in the "mark ring".  Commands that set the mark also push the old
mark onto this ring.  To return to a marked location, use `C-u C-<SPC>'
(or `C-u C-@'); this is the command `set-mark-command' given a numeric
argument.  It moves point to where the mark was, and restores the mark
from the ring of former marks.

   If you set `set-mark-command-repeat-pop' to non-`nil', then when you
repeat the character `C-<SPC>' after typing `C-u C-<SPC>', each
repetition moves point to a previous mark position from the ring.  The
mark positions you move through in this way are not lost; they go to
the end of the ring.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-<SPC>' always stays
in the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This is to make it easier for you to move back
later.  Searches set the mark if they move point.  However, in
Transient Mark mode, these commands do not set the mark when the mark
is already active.  You can tell when a command sets the mark because
it displays `Mark set' in the echo area.

   If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (*note Saving Positions in Registers:
RegPos.).

   The variable `mark-ring-max' specifies the maximum number of entries
to keep in the mark ring.  If that many entries exist and another one
is pushed, the earliest one in the list is discarded.  Repeating `C-u
C-<SPC>' cycles through the positions currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects, with the most recent first.  This variable is local in
every buffer.


File: emacs,  Node: Global Mark Ring,  Prev: Mark Ring,  Up: Mark

12.7 The Global Mark Ring
=========================

In addition to the ordinary mark ring that belongs to each buffer,
Emacs has a single "global mark ring".  It records a sequence of
buffers in which you have recently set the mark, so you can go back to
those buffers.

   Setting the mark always makes an entry on the current buffer's mark
ring.  If you have switched buffers since the previous mark setting, the
new mark position makes an entry on the global mark ring also.  The
result is that the global mark ring records a sequence of buffers that
you have been in, and, for each buffer, a place where you set the mark.

   The command `C-x C-<SPC>' (`pop-global-mark') jumps to the buffer
and position of the latest entry in the global ring.  It also rotates
the ring, so that successive uses of `C-x C-<SPC>' take you to earlier
and earlier buffers.


File: emacs,  Node: Killing,  Next: Yanking,  Prev: Mark,  Up: Top

13 Killing and Moving Text
**************************

"Killing" means erasing text and copying it into the "kill ring", from
which you can bring it back into the buffer by "yanking" it.  (Some
systems use the terms "cutting" and "pasting" for these operations.)
This is the most common way of moving or copying text within Emacs.
Killing and yanking is very safe because Emacs remembers several recent
kills, not just the last one.  It is versatile, because the many
commands for killing syntactic units can also be used for moving those
units.  But there are other ways of copying text for special purposes.

   Most commands which erase text from the buffer save it in the kill
ring.  These commands are known as "kill" commands.  The commands that
erase text but do not save it in the kill ring are known as "delete"
commands.  The `C-x u' (`undo') command (*note Undo::) can undo both
kill and delete commands; the importance of the kill ring is that you
can also yank the text in a different place or places.  Emacs has only
one kill ring for all buffers, so you can kill text in one buffer and
yank it in another buffer.

   The delete commands include `C-d' (`delete-char') and <DEL>
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can erase significant amounts of nontrivial data generally do a kill
operation instead.  The commands' names and individual descriptions use
the words `kill' and `delete' to say which kind of operation they
perform.

   You cannot kill read-only text, since such text does not allow any
kind of modification.  But some users like to use the kill commands to
copy read-only text into the kill ring, without actually changing it.
Therefore, the kill commands work specially in a read-only buffer: they
move over text, and copy it to the kill ring, without actually deleting
it from the buffer.  Normally, kill commands beep and display an error
message when this happens.  But if you set the variable
`kill-read-only-ok' to a non-`nil' value, they just print a message in
the echo area to explain why the text has not been erased.

   You can also use the mouse to kill and yank.  *Note Cut and Paste::.

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.


File: emacs,  Node: Deletion,  Next: Killing by Lines,  Up: Killing

13.1 Deletion
=============

Deletion means erasing text and not saving it in the kill ring.  For
the most part, the Emacs commands that delete text are those that erase
just one character or only whitespace.

`C-d'
`<DELETE>'
     Delete next character (`delete-char').  If your keyboard has a
     <DELETE> function key (usually located in the edit keypad), Emacs
     binds it to `delete-char' as well.

`<DEL>'
`<BS>'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-<SPC>'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, along with any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and <DEL>
(`delete-backward-char').  `C-d' deletes the character after point, the
one the cursor is "on top of."  This doesn't move point.  <DEL> deletes
the character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and <DEL> aren't always delete
commands; when given arguments, they kill instead, since they can erase
more than one character this way.

   Every keyboard has a large key which is a short distance above the
<RET> or <ENTER> key and is normally used for erasing what you have
typed.  It may be labeled <DEL>, <BACKSPACE>, <BS>, <DELETE>, or even
with a left arrow.  Regardless of the label on the key, in Emacs it
called <DEL>, and it should delete one character backwards.

   Many keyboards (including standard PC keyboards) have a <BACKSPACE>
key a short ways above <RET> or <ENTER>, and a <DELETE> key elsewhere.
In that case, the <BACKSPACE> key is <DEL>, and the <DELETE> key is
equivalent to `C-d'--or it should be.

   Why do we say "or it should be"?  When Emacs starts up using a
graphical display, it determines automatically which key or keys should
be equivalent to <DEL>.  As a result, <BACKSPACE> and/or <DELETE> keys
normally do the right things.  But in some unusual cases Emacs gets the
wrong information from the system.  If these keys don't do what they
ought to do, you need to tell Emacs which key to use for <DEL>.  *Note
DEL Does Not Delete::, for how to do this.

   On most text-only terminals, Emacs cannot tell which keys the
keyboard really has, so it follows a uniform plan which may or may not
fit your keyboard.  The uniform plan is that the ASCII <DEL> character
deletes, and the ASCII <BS> (backspace) character asks for help (it is
the same as `C-h').  If this is not right for your keyboard, such as if
you find that the key which ought to delete backwards enters Help
instead, see *note DEL Does Not Delete::.

   The other delete commands are those which delete only whitespace
characters: spaces, tabs and newlines.  `M-\'
(`delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  With a prefix argument, this only deletes
spaces and tab characters before point.  `M-<SPC>' (`just-one-space')
does likewise but leaves a single space after point, regardless of the
number of spaces that existed previously (even if there were none
before).  With a numeric argument N, it leaves N spaces after point.

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line.  If the current line is blank, it deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).  On a solitary blank line, it deletes that line.

   `M-^' (`delete-indentation') joins the current line and the previous
line, by deleting a newline and all surrounding spaces, usually leaving
a single space.  *Note M-^: Indentation.


File: emacs,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Killing

13.2 Killing by Lines
=====================

`C-k'
     Kill rest of line or one or more lines (`kill-line').

`C-S-backspace'
     Kill an entire line at once (`kill-whole-line')

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving it blank.  When used
on a blank line, it kills the whole line including its newline.  To kill
an entire non-blank line, go to the beginning and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following point, thus merging the next line into the current one.
Spaces and tabs that you can't see at the end of the line are ignored
when deciding which case applies, so if point appears to be at the end
of the line, you can be sure `C-k' will kill the newline.

   When `C-k' is given a positive argument, it kills that many lines
and the newlines that follow them (however, text on the current line
before point is not killed).  With a negative argument -N, it kills N
lines preceding the current line (together with the text on the current
line before point).  Thus, `C-u - 2 C-k' at the front of a line kills
the two previous lines.

   `C-k' with an argument of zero kills the text before point on the
current line.

   If the variable `kill-whole-line' is non-`nil', `C-k' at the very
beginning of a line kills the entire line including the following
newline.  This variable is normally `nil'.

   `C-S-backspace' (`kill-whole-line') will kill a whole line including
its newline regardless of the position of point within the line.  Note
that many character terminals will prevent you from typing the key
sequence `C-S-backspace'.


File: emacs,  Node: Other Kill Commands,  Prev: Killing by Lines,  Up: Killing

13.3 Other Kill Commands
========================

`C-w'
     Kill region (from point to the mark) (`kill-region').

`M-d'
     Kill word (`kill-word').  *Note Words::.

`M-<DEL>'
     Kill word backwards (`backward-kill-word').

`C-x <DEL>'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill the following balanced expression (`kill-sexp').  *Note
     Expressions::.

`M-z CHAR'
     Kill through the next occurrence of CHAR (`zap-to-char').

   The most general kill command is `C-w' (`kill-region'), which kills
everything between point and the mark.  With this command, you can kill
any contiguous sequence of characters, if you first set the region
around them.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (and
including) the next occurrence of that character in the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-<DEL>' and `M-d'
(*note Words::); balanced expressions, with `C-M-k' (*note
Expressions::); and sentences, with `C-x <DEL>' and `M-k' (*note
Sentences::).


File: emacs,  Node: Yanking,  Next: Accumulating Text,  Prev: Killing,  Up: Top

14 Yanking
**********

"Yanking" means reinserting text previously killed.  This is what some
systems call "pasting."  The usual way to move or copy text is to kill
it and then yank it elsewhere one or more times.  This is very safe
because Emacs remembers many recent kills, not just the last one.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace text just yanked with an earlier batch of killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`kill-ring-save').  Some systems call this "copying."

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

   On graphical displays with window systems, if there is a current
selection in some other application, and you selected it more recently
than you killed any text in Emacs, `C-y' copies the selection instead
of text killed within Emacs.

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.


File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Up: Yanking

14.1 The Kill Ring
==================

All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, shared by all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This happens only if the argument is specified with just a
`C-u', precisely.  Any other sort of argument, including `C-u' and
digits, specifies an earlier kill to yank (*note Earlier Kills::).

   The yank commands discard certain text properties from the text that
is yanked, those that might lead to annoying results.  For instance,
they discard text properties that respond to the mouse or specify key
bindings.  The variable `yank-excluded-properties' specifies the
properties to discard.  Yanking of register contents and rectangles
also discard these properties.

   To copy a block of text, you can use `M-w' (`kill-ring-save'), which
copies the region into the kill ring without removing it from the
buffer.  This is approximately equivalent to `C-w' followed by `C-x u',
except that `M-w' does not alter the undo history and does not
temporarily change the screen.


File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

14.2 Appending Kills
====================

Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks all the text as a unit, just
as it was before it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains this text:

     This is a line -!-of sample text.

with point shown by -!-.  If you type `M-d M-<DEL> M-d M-<DEL>',
killing alternately forward and backward, you end up with `a line of
sample' as one entry in the kill ring, and `This is  text.' in the
buffer.  (Note the double space between `is' and `text', which you can
clean up with `M-<SPC>' or `M-q'.)

   Another way to kill the same text is to move back two words with
`M-b M-b', then kill all four words forward with `C-u M-d'.  This
produces exactly the same results in the buffer and in the kill ring.
`M-f M-f C-u M-<DEL>' kills the same text, all going backward; once
again, the result is the same.  The text in the kill ring entry always
has the same order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
`C-M-w' (`append-next-kill') right before it.  The `C-M-w' tells the
following command, if it is a kill command, to append the text it kills
to the last killed text, instead of starting a new entry.  With
`C-M-w', you can kill several separated pieces of text and accumulate
them to be yanked back in one place.

   A kill command following `M-w' does not append to the text that
`M-w' copied into the kill ring.


File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

14.3 Yanking Earlier Kills
==========================

To recover killed text that is no longer the most recent kill, use the
`M-y' command (`yank-pop').  It takes the text previously yanked and
replaces it with the text from an earlier kill.  So, to recover the
text of the next-to-the-last kill, first use `C-y' to yank the last
kill, and then use `M-y' to replace it with the previous kill.  `M-y'
is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
loops back around to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the "last yank"
pointer remains at the same place in the kill ring, so repeating `C-y'
will yank another copy of the same previous kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument restores the text from the specified
kill ring entry, counting back from the most recent as 1.  Thus, `C-u 2
C-y' gets the next-to-the-last block of killed text--it is equivalent
to `C-y M-y'.  `C-y' with a numeric argument starts counting from the
"last yank" pointer, and sets the "last yank" pointer to the entry that
it yanks.

   The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are saved.

   The actual contents of the kill ring are stored in a variable named
`kill-ring'; you can view the entire contents of the kill ring with the
command `C-h v kill-ring'.


File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Yanking,  Up: Top

15 Accumulating Text
********************

Usually we copy or move text by killing it and yanking it, but there
are other convenient methods for copying one block of text in many
places, or for copying many scattered blocks of text into one place.  To
copy one block to many places, store it in a register (*note
Registers::).  Here we describe the commands to accumulate scattered
pieces of text into a buffer or into a file.

`M-x append-to-buffer'
     Append region to the contents of a specified buffer.

`M-x prepend-to-buffer'
     Prepend region to the contents of a specified buffer.

`M-x copy-to-buffer'
     Copy region into a specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert the contents of a specified buffer into current buffer at
     point.

`M-x append-to-file'
     Append region to the contents of a specified file, at the end.

   To accumulate text into a buffer, use `M-x append-to-buffer'.  This
reads a buffer name, then inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, `append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, starting from wherever
point happens to be at that moment.

   Point in that buffer is left at the end of the copied text, so
successive uses of `append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, `append-to-buffer' does not always append to the text already
in the buffer--it appends only if point in that buffer is at the end.
However, if `append-to-buffer' is the only command you use to alter a
buffer, then point is always at the end.

   `M-x prepend-to-buffer' is just like `append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is
similar, except that any existing text in the other buffer is deleted,
so the buffer is left containing just the text newly copied into it.

   To retrieve the accumulated text from another buffer, use the
command `M-x insert-buffer'; this too takes BUFFERNAME as an argument.
It inserts a copy of the whole text in buffer BUFFERNAME into the
current buffer at point, and sets the mark after the inserted text.
Alternatively, you can select the other buffer for editing, then copy
text from it by killing.  *Note Buffers::, for background information
on buffers.

   Instead of accumulating text within Emacs, in a buffer, you can
append text directly into a file with `M-x append-to-file', which takes
FILENAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.

   You should use `append-to-file' only with files that are _not_ being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing
some of your editing.


File: emacs,  Node: Rectangles,  Next: CUA Bindings,  Prev: Accumulating Text,  Up: Top

16 Rectangles
*************

The rectangle commands operate on rectangular areas of the text: all
the characters between a certain pair of columns, in a certain range of
lines.  Commands are provided to kill rectangles, yank killed
rectangles, clear them out, fill them with blanks or text, or delete
them.  Rectangle commands are useful with text in multicolumn formats,
and for changing text into or out of such formats.

   When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner.  The
rectangle thus specified is called the "region-rectangle" because you
control it in much the same way as the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as a region or as a rectangle, depending on the
command that uses them.

   If point and the mark are in the same column, the rectangle they
delimit is empty.  If they are in the same line, the rectangle is one
line high.  This asymmetry between lines and columns comes about
because point (and likewise the mark) is between two columns, but within
a line.

`C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     "last killed rectangle" (`kill-rectangle').

`C-x r d'
     Delete the text of the region-rectangle (`delete-rectangle').

`C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     (`yank-rectangle').

`C-x r o'
     Insert blank space to fill the space of the region-rectangle
     (`open-rectangle').  This pushes the previous contents of the
     region-rectangle rightward.

`C-x r c'
     Clear the region-rectangle by replacing all of its contents with
     spaces (`clear-rectangle').

`M-x delete-whitespace-rectangle'
     Delete whitespace in each of the lines on the specified rectangle,
     starting from the left edge column of the rectangle.

`C-x r t STRING <RET>'
     Replace rectangle contents with STRING on each line
     (`string-rectangle').

`M-x string-insert-rectangle <RET> STRING <RET>'
     Insert STRING on each line of the rectangle.

   The rectangle operations fall into two classes: commands for
deleting and inserting rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `C-x r d' (`delete-rectangle') and
`C-x r k' (`kill-rectangle').  In either case, the portion of each line
that falls inside the rectangle's boundaries is deleted, causing any
following text on the line to move left into the gap.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that can only record the most recent rectangle killed.  This is because
yanking a rectangle is so different from yanking linear text that
different yank commands have to be used.  It is hard to define
yank-popping for rectangles, so we do not try.

   To yank the last killed rectangle, type `C-x r y'
(`yank-rectangle').  Yanking a rectangle is the opposite of killing
one.  Point specifies where to put the rectangle's upper left corner.
The rectangle's first line is inserted there, the rectangle's second
line is inserted at the same horizontal position, but one line
vertically down, and so on.  The number of lines affected is determined
by the height of the saved rectangle.

   You can convert single-column lists into double-column lists using
rectangle killing and yanking; kill the second half of the list as a
rectangle and then yank it beside the first line of the list.  *Note
Two-Column::, for another way to edit multi-column text.

   You can also copy rectangles into and out of registers with `C-x r r
R' and `C-x r i R'.  *Note Rectangle Registers: RegRect.

   There are two commands you can use for making blank rectangles: `C-x
r c' (`clear-rectangle') which blanks out existing text, and `C-x r o'
(`open-rectangle') which inserts a blank rectangle.  Clearing a
rectangle is equivalent to deleting it and then inserting a blank
rectangle of the same size.

   The command `M-x delete-whitespace-rectangle' deletes horizontal
whitespace starting from a particular column.  This applies to each of
the lines in the rectangle, and the column is specified by the left
edge of the rectangle.  The right edge of the rectangle does not make
any difference to this command.

   The command `C-x r t' (`string-rectangle') replaces the contents of
a region-rectangle with a string on each line.  The string's width need
not be the same as the width of the rectangle.  If the string's width
is less, the text after the rectangle shifts left; if the string is
wider than the rectangle, the text after the rectangle shifts right.

   The command `M-x string-insert-rectangle' is similar to
`string-rectangle', but inserts the string on each line, shifting the
original text to the right.


File: emacs,  Node: CUA Bindings,  Next: Registers,  Prev: Rectangles,  Up: Top

17 CUA Bindings
***************

The command `M-x cua-mode' sets up key bindings that are compatible
with the Common User Access (CUA) system used in many other
applications.  `C-x' means cut (kill), `C-c' copy, `C-v' paste (yank),
and `C-z' undo.  Standard Emacs commands like `C-x C-c' still work,
because `C-x' and `C-c' only take effect when the mark is active (and
the region is highlighted).  However, if you don't want to override
these bindings in Emacs at all, set `cua-enable-cua-keys' to `nil'.

   In CUA mode, using `Shift' together with the movement keys activates
and highlights the region over which they move.  The standard
(unshifted) movement keys deactivate the mark, and typed text replaces
the active region as in Delete-Selection mode (*note Mouse Commands::).

   To enter an Emacs command like `C-x C-f' while the mark is active,
use one of the following methods: either hold `Shift' together with the
prefix key, e.g. `S-C-x C-f', or quickly type the prefix key twice,
e.g. `C-x C-x C-f'.

   CUA mode provides enhanced rectangle support with visible rectangle
highlighting.  Use `C-RET' to start a rectangle, extend it using the
movement commands, and cut or copy it using `C-x' or `C-c'.  `RET'
moves the cursor to the next (clockwise) corner of the rectangle, so
you can easily expand it in any direction.  Normal text you type is
inserted to the left or right of each line in the rectangle (on the
same side as the cursor).

   With CUA you can easily copy text and rectangles into and out of
registers by providing a one-digit numeric prefix to the kill, copy,
and yank commands, e.g. `C-1 C-c' copies the region into register `1',
and `C-2 C-v' yanks the contents of register `2'.

   CUA mode also has a global mark feature which allows easy moving and
copying of text between buffers.  Use `C-S-SPC' to toggle the global
mark on and off.  When the global mark is on, all text that you kill or
copy is automatically inserted at the global mark, and text you type is
inserted at the global mark rather than at the current position.

   For example, to copy words from various buffers into a word list in
a given buffer, set the global mark in the target buffer, then navigate
to each of the words you want in the list, mark it (e.g. with `S-M-f'),
copy it to the list with `C-c' or `M-w', and insert a newline after the
word in the target list by pressing <RET>.


File: emacs,  Node: Registers,  Next: Display,  Prev: CUA Bindings,  Up: Top

18 Registers
************

Emacs "registers" are compartments where you can save text, rectangles,
positions, and other things for later use.  Once you save text or a
rectangle in a register, you can copy it into the buffer once, or many
times; you can move point to a position saved in a register once, or
many times.

   Each register has a name, which consists of a single character.  A
register can store a number, a piece of text, a rectangle, a position,
a window configuration, or a file name, but only one thing at any given
time.  Whatever you store in a register remains there until you store
something else in that register.  To see what a register R contains,
use `M-x view-register'.

`M-x view-register <RET> R'
     Display a description of what register R contains.

   "Bookmarks" record files and positions in them, so you can return to
those positions when you look at the file again.  Bookmarks are similar
enough in spirit to registers that they seem to belong in this chapter.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Files: RegFiles.            File names in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: emacs,  Node: RegPos,  Next: RegText,  Up: Registers

18.1 Saving Positions in Registers
==================================

Saving a position records a place in a buffer so that you can move back
there later.  Moving to a saved position switches to that buffer and
moves point to that place in it.

`C-x r <SPC> R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r <SPC> R'.  The register R retains the position thus
saved until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to hold the
same position.  You can jump to the saved position any number of times.

   If you use `C-x r j' to go to a saved position, but the buffer it
was saved from has been killed, `C-x r j' tries to create the buffer
again by visiting the same file.  Of course, this works only for buffers
that were visiting files.


File: emacs,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

18.2 Saving Text in Registers
=============================

When you want to insert a copy of the same piece of text several times,
it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r i R'
     Insert text from register R (`insert-register').

`M-x append-to-register <RET> R'
     Append region to text in register R.

`M-x prepend-to-register <RET> R'
     Prepend region to text in register R.

   `C-x r s R' stores a copy of the text of the region into the
register named R.  `C-u C-x r s R', the same command with a numeric
argument, deletes the text from the buffer as well; you can think of
this as "moving" the region text into the register.

   `M-x append-to-register <RET> R' appends the copy of the text in the
region to the text already stored in the register named R.  If invoked
with a numeric argument, it deletes the region after appending it to
the register.  The command `prepend-to-register' is similar, except
that it _prepends_ the region text to the text in the register, rather
than _appending_ it.

   `C-x r i R' inserts in the buffer the text from register R.
Normally it leaves point before the text and places the mark after, but
with a numeric argument (`C-u') it puts point after the text and the
mark before.


File: emacs,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

18.3 Saving Rectangles in Registers
===================================

A register can contain a rectangle instead of linear text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on how to specify a rectangle in the buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-rectangle-to-register').  With numeric argument, delete it
     as well.

`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts a text string if the register
contains one, and inserts a rectangle if the register contains one.

   See also the command `sort-columns', which you can think of as
sorting a rectangle.  *Note Sorting::.


File: emacs,  Node: RegConfig,  Next: RegNumbers,  Prev: RegRect,  Up: Registers

18.4 Saving Window Configurations in Registers
==============================================

You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`C-x r f R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: emacs,  Node: RegNumbers,  Next: RegFiles,  Prev: RegConfig,  Up: Registers

18.5 Keeping Numbers in Registers
=================================

There are commands to store a number in a register, to insert the
number in the buffer in decimal, and to increment it.  These commands
can be useful in keyboard macros (*note Keyboard Macros::).

`C-u NUMBER C-x r n R'
     Store NUMBER into register R (`number-to-register').

`C-u NUMBER C-x r + R'
     Increment the number in register R by NUMBER
     (`increment-register').

`C-x r i R'
     Insert the number from register R into the buffer.

   `C-x r i' is the same command used to insert any other sort of
register contents into the buffer.  `C-x r +' with no numeric argument
increments the register value by 1; `C-x r n' with no numeric argument
stores zero in the register.


File: emacs,  Node: RegFiles,  Next: Bookmarks,  Prev: RegNumbers,  Up: Registers

18.6 Keeping File Names in Registers
====================================

If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: emacs,  Node: Bookmarks,  Prev: RegFiles,  Up: Registers

18.7 Bookmarks
==============

"Bookmarks" are somewhat like registers in that they record positions
you can jump to.  Unlike registers, they have long names, and they
persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

`C-x r m <RET>'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK <RET>'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK <RET>'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions or annotate the bookmarks.
Type `C-h m' in the bookmark buffer for more information about its
special editing commands.

   When you kill Emacs, Emacs offers to save your bookmark values in
your default bookmark file, `~/.emacs.bmk', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one Emacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if Emacs crashes.  (The value, if a
number, says how many bookmark modifications should go by between
saving.)

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record on each side of the bookmark's position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load <RET> FILENAME <RET>'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write <RET> FILENAME <RET>'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete <RET> BOOKMARK <RET>'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-insert-location <RET> BOOKMARK <RET>'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert <RET> BOOKMARK <RET>'
     Insert in the buffer the _contents_ of the file that bookmark
     BOOKMARK points to.


File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

19 Controlling the Display
**************************

Since only part of a large buffer fits in the window, Emacs tries to
show a part that is likely to be interesting.  Display-control commands
allow you to specify which part of the text you want to see, and how to
display it.  Many variables also affect the details of redisplay.
Unless otherwise stated, the variables described in this chapter have
their effect by customizing redisplay itself; therefore, their values
only make a difference at the time of redisplay.

* Menu:

* Scrolling::	           Commands to move text up and down in a window.
* Auto Scrolling::         Redisplay scrolls text automatically when needed.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Faces::	           How to change the display style using faces.
* Standard Faces::         Emacs' predefined faces.
* Font Lock::              Minor mode for syntactic highlighting using faces.
* Highlight Interactively:: Tell Emacs what text to highlight.
* Fringes::                Enabling or disabling window fringes.
* Displaying Boundaries::  Displaying top and bottom of the buffer.
* Useless Whitespace::     Showing possibly-spurious trailing whitespace.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Cursor Display::         Features for displaying the cursor.
* Line Truncation::        Truncating lines to fit the screen width instead
                             of continuing them to multiple screen lines.
* Display Custom::         Information on variables for customizing display.


File: emacs,  Node: Scrolling,  Next: Auto Scrolling,  Up: Display

19.1 Scrolling
==============

If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous portion
of the text.  The portion shown always contains point.

   "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling "forward" or "up"
means that text moves up, and new text appears at the bottom.
Scrolling "backward" or "down" moves text down, and new text appears at
the top.

   Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also scroll explicitly with the commands in
this section.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`<NEXT>'
`<PAGEDOWN>'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`<PRIOR>'
`<PAGEUP>'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-M-l'
     Scroll heuristically to bring useful information onto the screen
     (`reposition-window').

   The most basic scrolling command is `C-l' (`recenter') with no
argument.  It scrolls the selected window so that point is halfway down
from the top of the window.  On a text terminal, it also clears the
screen and redisplays all windows.  That is useful in case the screen
is garbled (*note Screen Garbled::).

   To read the buffer a windowful at a time, use `C-v' (`scroll-up')
with no argument.  This scrolls forward by nearly the whole window
height.  The effect is to take the two lines at the bottom of the
window and put them at the top, followed by nearly a whole windowful of
lines that were not previously visible.  If point was in the text that
scrolled off the top, it ends up at the new top of the window.

   `M-v' (`scroll-down') with no argument scrolls backward in a similar
way, also with overlap.  The number of lines of overlap that the `C-v'
or `M-v' commands leave is controlled by the variable
`next-screen-context-lines'; by default, it is 2.  The function keys
<NEXT> and <PRIOR>, or <PAGEDOWN> and <PAGEUP>, are equivalent to `C-v'
and `M-v'.

   The commands `C-v' and `M-v' with a numeric argument scroll the text
in the selected window up or down a few lines.  `C-v' with an argument
moves the text and point up, together, that many lines; it brings the
same number of new lines into view at the bottom of the window.  `M-v'
with numeric argument scrolls the text downward, bringing that many new
lines into view at the top of the window.  `C-v' with a negative
argument is like `M-v' and vice versa.

   The names of scroll commands are based on the direction that the
text moves in the window.  Thus, the command to scroll forward is
called `scroll-up' because it moves the text upward on the screen.  The
keys <PAGEDOWN> and <PAGEUP> derive their names and customary meanings
from a different convention that developed elsewhere; hence the strange
result that <PAGEDOWN> runs `scroll-up'.

   Some users like the full-screen scroll commands to keep point at the
same screen line.  To enable this behavior, set the variable
`scroll-preserve-screen-position' to a non-`nil' value.  In this mode,
when these commands would scroll the text around point off the screen,
or within `scroll-margin' lines of the edge, they move point to keep
the same vertical position within the window.  This mode is convenient
for browsing through a file by scrolling by screenfuls; if you come
back to the screen where you started, point goes back to the line where
it started.  However, this mode is inconvenient when you move to the
next screen in order to move point to the text there.

   Another way to do scrolling is with `C-l' with a numeric argument.
`C-l' does not clear the screen when given an argument; it only scrolls
the selected window.  With a positive argument N, it repositions text
to put point N lines down from the top.  An argument of zero puts point
on the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the screen.  `C-l' with a
negative argument puts point that many lines from the bottom of the
window.  For example, `C-u - 1 C-l' puts point on the bottom line, and
`C-u - 5 C-l' puts it five lines from the bottom.  `C-u C-l' scrolls to
put point at the center (vertically) of the selected window.

   The `C-M-l' command (`reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.


File: emacs,  Node: Auto Scrolling,  Next: Horizontal Scrolling,  Prev: Scrolling,  Up: Display

19.2 Automatic Scrolling
========================

Redisplay scrolls the buffer automatically when point moves out of the
visible portion of the text.  The purpose of automatic scrolling is to
make point visible, but you can customize many aspects of how this is
done.

   Normally, automatic scrolling centers point vertically within the
window.  However, if you set `scroll-conservatively' to a small number
N, then if you move point just a little off the screen--less than N
lines--then Emacs scrolls the text just far enough to bring point back
on screen.  By default, `scroll-conservatively' is 0.

   When the window does scroll by a longer distance, you can control
how aggressively it scrolls, by setting the variables
`scroll-up-aggressively' and `scroll-down-aggressively'.  The value of
`scroll-up-aggressively' should be either `nil', or a fraction F
between 0 and 1.  A fraction specifies where on the screen to put point
when scrolling upward.  More precisely, when a window scrolls up
because point is above the window start, the new start position is
chosen to put point F part of the window height from the top.  The
larger F, the more aggressive the scrolling.

   `nil', which is the default, scrolls to put point at the center.  So
it is equivalent to .5.

   Likewise, `scroll-down-aggressively' is used for scrolling down.
The value, F, specifies how far point should be placed from the bottom
of the window; thus, as with `scroll-up-aggressively', a larger value
is more aggressive.

   The variable `scroll-margin' restricts how close point can come to
the top or bottom of a window.  Its value is a number of screen lines;
if point comes within that many lines of the top or bottom of the
window, Emacs recenters the window.  By default, `scroll-margin' is 0.


File: emacs,  Node: Horizontal Scrolling,  Next: Follow Mode,  Prev: Auto Scrolling,  Up: Display

19.3 Horizontal Scrolling
=========================

"Horizontal scrolling" means shifting all the lines sideways within a
window--so that some of the text near the left margin is not displayed
at all.  When the text in a window is scrolled horizontally, text lines
are truncated rather than continued (*note Line Truncation::).
Whenever a window shows truncated lines, Emacs automatically updates
its horizontal scrolling whenever point moves off the left or right
edge of the screen.  You can also use these commands to do explicit
horizontal scrolling.

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

   The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  This moves part of the
beginning of each line off the left edge of the window.  With no
argument, it scrolls by almost the full width of the window (two
columns less, to be precise).

   `C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displayed
normally (with each line starting at the window's left margin);
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for `C-x >'; any sufficiently large
argument will restore the normal display.

   If you use those commands to scroll a window horizontally, that sets
a lower bound for automatic horizontal scrolling.  Automatic scrolling
will continue to scroll the window, but never farther to the right than
the amount you previously set by `scroll-left'.

   The value of the variable `hscroll-margin' controls how close to the
window's edges point is allowed to get before the window will be
automatically scrolled.  It is measured in columns.  If the value is 5,
then moving point within 5 columns of the edge causes horizontal
scrolling away from that edge.

   The variable `hscroll-step' determines how many columns to scroll
the window when point gets too close to the edge.  If it's zero,
horizontal scrolling centers point horizontally within the window.  If
it's a positive integer, it specifies the number of columns to scroll
by.  If it's a floating-point number, it specifies the fraction of the
window's width to scroll by.  The default is zero.

   To disable automatic horizontal scrolling, set the variable
`auto-hscroll-mode' to `nil'.


File: emacs,  Node: Follow Mode,  Next: Faces,  Prev: Horizontal Scrolling,  Up: Display

19.4 Follow Mode
================

"Follow mode" is a minor mode that makes two windows, both showing the
same buffer, scroll as a single tall "virtual window."  To use Follow
mode, go to a frame with just one window, split it into two
side-by-side windows using `C-x 3', and then type `M-x follow-mode'.
From then on, you can edit the buffer in either of the two windows, or
scroll either one; the other window follows it.

   In Follow mode, if you move point outside the portion visible in one
window and into the portion visible in the other window, that selects
the other window--again, treating the two as if they were parts of one
large window.

   To turn off Follow mode, type `M-x follow-mode' a second time.


File: emacs,  Node: Faces,  Next: Standard Faces,  Prev: Follow Mode,  Up: Display

19.5 Faces: Controlling Text Display Style
==========================================

You can specify various styles for displaying text using "faces".  Each
face can specify various "face attributes", such as the font family,
the height, weight and slant of the characters, the foreground and
background color, and underlining or overlining.  A face does not have
to specify all of these attributes; often it inherits most of them from
another face.

   On graphical display, all the Emacs face attributes are meaningful.
On a text-only terminal, only some of them work.  Some text-only
terminals support inverse video, bold, and underline attributes; some
support colors.  Text-only terminals generally do not support changing
the height and width or the font family.

   Most major modes assign faces to the text automatically through the
work of Font Lock mode.  *Note Font Lock::, for more information about
Font Lock mode and syntactic highlighting.  You can print the current
buffer with the highlighting that appears on your screen using the
command `ps-print-buffer-with-faces'.  *Note PostScript::.

   You control the appearance of a part of the text in the buffer by
specifying the face or faces to use for it.  The style of display used
for any given character is determined by combining the attributes of
all the applicable faces specified for that character.  Any attribute
that isn't specified by these faces is taken from the `default' face,
whose attributes reflect the default settings of the frame itself.

   Enriched mode, the mode for editing formatted text, includes several
commands and menus for specifying faces for text in the buffer.  *Note
Format Faces::, for how to specify the font for text in the buffer.
*Note Format Colors::, for how to specify the foreground and background
color.

   To alter the appearance of a face, use the customization buffer.
*Note Face Customization::.  You can also use X resources to specify
attributes of particular faces (*note Resources::).  Alternatively, you
can change the foreground and background colors of a specific face with
`M-x set-face-foreground' and `M-x set-face-background'.  These
commands prompt in the minibuffer for a face name and a color name,
with completion, and then set that face to use the specified color.
Changing the colors of the `default' face also changes the foreground
and background colors on all frames, both existing and those to be
created in the future.  (You can also set foreground and background
colors for the current frame only; see *note Frame Parameters::.)

   If you want to alter the appearance of all Emacs frames, you need to
customize the frame parameters in the variable `default-frame-alist';
see *note default-frame-alist: Creating Frames.

   Emacs can correctly display variable-width fonts, but Emacs commands
that calculate width and indentation do not know how to calculate
variable widths.  This can sometimes lead to incorrect results when you
use variable-width fonts.  In particular, indentation commands can give
inconsistent results, so we recommend you avoid variable-width fonts
for editing program source code.  Filling will sometimes make lines too
long or too short.  We plan to address these issues in future Emacs
versions.


File: emacs,  Node: Standard Faces,  Next: Font Lock,  Prev: Faces,  Up: Display

19.6 Standard Faces
===================

To see what faces are currently defined, and what they look like, type
`M-x list-faces-display'.  It's possible for a given face to look
different in different frames; this command shows the appearance in the
frame in which you type it.  With a prefix argument, this prompts for a
regular expression, and displays only faces with names matching that
regular expression.

   Here are the standard faces for specifying text appearance.  You can
apply them to specific text when you want the effects they produce.

`default'
     This face is used for ordinary text that doesn't specify any face.

`bold'
     This face uses a bold variant of the default font, if it has one.
     It's up to you to choose a default font that has a bold variant,
     if you want to use one.

`italic'
     This face uses an italic variant of the default font, if it has
     one.

`bold-italic'
     This face uses a bold italic variant of the default font, if it
     has one.

`underline'
     This face underlines text.

`fixed-pitch'
     This face forces use of a particular fixed-width font.

`variable-pitch'
     This face forces use of a particular variable-width font.  It's
     reasonable to customize this face to use a different
     variable-width font, if you like, but you should not make it a
     fixed-width font.

`shadow'
     This face is used for making the text less noticeable than the
     surrounding ordinary text.  Usually this can be achieved by using
     shades of gray in contrast with either black or white default
     foreground color.

   Here's an incomplete list of faces used to highlight parts of the
text temporarily for specific purposes.  (Many other modes define their
own faces for this purpose.)

`highlight'
     This face is used for highlighting portions of text, in various
     modes.  For example, mouse-sensitive text is highlighted using
     this face.

`isearch'
     This face is used for highlighting the current Isearch match.

`query-replace'
     This face is used for highlighting the current Query Replace match.

`lazy-highlight'
     This face is used for lazy highlighting of Isearch and Query
     Replace matches other than the current one.

`region'
     This face is used for displaying a selected region (when Transient
     Mark mode is enabled--see below).

`secondary-selection'
     This face is used for displaying a secondary X selection (*note
     Secondary Selection::).

`trailing-whitespace'
     The face for highlighting excess spaces and tabs at the end of a
     line when `show-trailing-whitespace' is non-`nil'; see *note
     Useless Whitespace::.

`nobreak-space'
     The face for displaying the character "nobreak space."

`escape-glyph'
     The face for highlighting the `\' or `^' that indicates a control
     character.  It's also used when `\' indicates a nobreak space or
     nobreak (soft) hyphen.

   When Transient Mark mode is enabled, the text of the region is
highlighted when the mark is active.  This uses the face named
`region'; you can control the style of highlighting by changing the
style of this face (*note Face Customization::).  *Note Transient
Mark::, for more information about Transient Mark mode and activation
and deactivation of the mark.

   These faces control the appearance of parts of the Emacs frame.
They exist as faces to provide a consistent way to customize the
appearance of these parts of the frame.

`mode-line'
`modeline'
     This face is used for the mode line of the currently selected
     window, and for menu bars when toolkit menus are not used.  By
     default, it's drawn with shadows for a "raised" effect on
     graphical displays, and drawn as the inverse of the default face
     on non-windowed terminals.  `modeline' is an alias for the
     `mode-line' face, for compatibility with old Emacs versions.

`mode-line-inactive'
     Like `mode-line', but used for mode lines of the windows other
     than the selected one (if `mode-line-in-non-selected-windows' is
     non-`nil').  This face inherits from `mode-line', so changes in
     that face affect mode lines in all windows.

`mode-line-highlight'
     Like `highlight', but used for portions of text on mode lines.

`mode-line-buffer-id'
     This face is used for buffer identification parts in the mode line.

`header-line'
     Similar to `mode-line' for a window's header line, which appears
     at the top of a window just as the mode line appears at the bottom.
     Most windows do not have a header line--only some special modes,
     such Info mode, create one.

`vertical-border'
     This face is used for the vertical divider between windows.  By
     default this face inherits from the `mode-line-inactive' face on
     character terminals.  On graphical displays the foreground color of
     this face is used for the vertical line between windows without
     scrollbars.

`minibuffer-prompt'
     This face is used for the prompt strings displayed in the
     minibuffer.  By default, Emacs automatically adds this face to the
     value of `minibuffer-prompt-properties', which is a list of text
     properties used to display the prompt text.  (This variable takes
     effect when you enter the minibuffer.)

`fringe'
     The face for the fringes to the left and right of windows on
     graphic displays.  (The fringes are the narrow portions of the
     Emacs frame between the text area and the window's right and left
     borders.)  *Note Fringes::.

`scroll-bar'
     This face determines the visual appearance of the scroll bar.
     *Note Scroll Bars::.

`border'
     This face determines the color of the frame border.

`cursor'
     This face determines the color of the cursor.

`mouse'
     This face determines the color of the mouse pointer.

`tool-bar'
     This face determines the color of tool bar icons.  *Note Tool
     Bars::.

`tooltip'
     This face is used for tooltips.  *Note Tooltips::.

`menu'
     This face determines the colors and font of Emacs's menus.  *Note
     Menu Bars::.  Setting the font of LessTif/Motif menus is currently
     not supported; attempts to set the font are ignored in this case.
     Likewise, attempts to customize this face in Emacs built with GTK
     and in the MS-Windows/Mac ports are ignored by the respective GUI
     toolkits; you need to use system-wide styles and options to change
     the appearance of the menus.


File: emacs,  Node: Font Lock,  Next: Highlight Interactively,  Prev: Standard Faces,  Up: Display

19.7 Font Lock mode
===================

Font Lock mode is a minor mode, always local to a particular buffer,
which highlights (or "fontifies") the buffer contents according to the
syntax of the text you are editing.  It can recognize comments and
strings in most languages; in several languages, it can also recognize
and properly highlight various other important constructs--for example,
names of functions being defined or reserved keywords.  Some special
modes, such as Occur mode and Info mode, have completely specialized
ways of assigning fonts for Font Lock mode.

   Font Lock mode is turned on by default in all modes which support it.
You can toggle font-lock for each buffer with the command `M-x
font-lock-mode'.  Using a positive argument unconditionally turns Font
Lock mode on, and a negative or zero argument turns it off.

   If you do not wish Font Lock mode to be turned on by default,
customize the variable `global-font-lock-mode' using the Customize
interface (*note Easy Customization::), or use the function
`global-font-lock-mode' in your `.emacs' file, like this:

     (global-font-lock-mode 0)

This variable, like all the variables that control Font Lock mode, take
effect whenever fontification is done; that is, potentially at any time.

   If you have disabled Global Font Lock mode, you can still enable Font
Lock for specific major modes by adding the function
`turn-on-font-lock' to the mode hooks (*note Hooks::).  For example, to
enable Font Lock mode for editing C files, you can do this:

     (add-hook 'c-mode-hook 'turn-on-font-lock)

   Font Lock mode uses several specifically named faces to do its job,
including `font-lock-string-face', `font-lock-comment-face', and
others.  The easiest way to find them all is to use `M-x
customize-group <RET> font-lock-faces <RET>'.  You can then use that
customization buffer to customize the appearance of these faces.  *Note
Face Customization::.

   You can also customize these faces using `M-x set-face-foreground'
or `M-x set-face-background'.  *Note Faces::.

   The variable `font-lock-maximum-decoration' specifies the preferred
level of fontification, for modes that provide multiple levels.  Level
1 is the least amount of fontification; some modes support levels as
high as 3.  The normal default is "as high as possible."  You can
specify an integer, which applies to all modes, or you can specify
different numbers for particular major modes; for example, to use level
1 for C/C++ modes, and the default level otherwise, use this:

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

   Fontification can be too slow for large buffers, so you can suppress
it for buffers above a certain size.  The variable
`font-lock-maximum-size' specifies a buffer size, beyond which buffer
fontification is suppressed.

   Comment and string fontification (or "syntactic" fontification)
relies on analysis of the syntactic structure of the buffer text.  For
the sake of speed, some modes, including Lisp mode, rely on a special
convention: an open-parenthesis or open-brace in the leftmost column
always defines the beginning of a defun, and is thus always outside any
string or comment.  (*Note Left Margin Paren::.)  If you don't follow
this convention, Font Lock mode can misfontify the text that follows an
open-parenthesis or open-brace in the leftmost column that is inside a
string or comment.

   The variable `font-lock-beginning-of-syntax-function' (always
buffer-local) specifies how Font Lock mode can find a position
guaranteed to be outside any comment or string.  In modes which use the
leftmost column parenthesis convention, the default value of the
variable is `beginning-of-defun'--that tells Font Lock mode to use the
convention.  If you set this variable to `nil', Font Lock no longer
relies on the convention.  This avoids incorrect results, but the price
is that, in some cases, fontification for a changed text must rescan
buffer text from the beginning of the buffer.  This can considerably
slow down redisplay while scrolling, particularly if you are close to
the end of a large buffer.

   Font Lock highlighting patterns already exist for many modes, but you
may want to fontify additional patterns.  You can use the function
`font-lock-add-keywords', to add your own highlighting patterns for a
particular mode.  For example, to highlight `FIXME:' words in C
comments, use this:

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))

   To remove keywords from the font-lock highlighting patterns, use the
function `font-lock-remove-keywords'.  *Note Search-based
Fontification: (elisp)Search-based Fontification, for documentation of
the format of this list.

   Fontifying large buffers can take a long time.  To avoid large
delays when a file is visited, Emacs fontifies only the visible portion
of a buffer.  As you scroll through the buffer, each portion that
becomes visible is fontified as soon as it is displayed.  The parts of
the buffer that are not displayed are fontified "stealthily," in the
background, i.e. when Emacs is idle.  You can control this background
fontification, also called "Just-In-Time" (or "JIT") Lock, by
customizing variables in the customization group `jit-lock'.  *Note
Specific Customization::.


File: emacs,  Node: Highlight Interactively,  Next: Fringes,  Prev: Font Lock,  Up: Display

19.8 Interactive Highlighting
=============================

Use `M-x highlight-changes-mode' to enable (or disable) Highlight
Changes mode, a minor mode that uses faces (colors, typically) to
indicate which parts of the buffer were changed most recently.

   Hi Lock mode highlights text that matches regular expressions you
specify.  For example, you might wish to see all the references to a
certain variable in a program source file, highlight certain parts in a
voluminous output of some program, or make certain names stand out in
an article.  Use the `M-x hi-lock-mode' command to enable (or disable)
Hi Lock mode.  To enable Hi Lock mode for all buffers, use `M-x
global-hi-lock-mode' or place `(global-hi-lock-mode 1)' in your
`.emacs' file.

   Hi Lock mode works like Font Lock mode (*note Font Lock::), except
that you specify explicitly the regular expressions to highlight.  You
control them with these commands:

`C-x w h REGEXP <RET> FACE <RET>'
     Highlight text that matches REGEXP using face FACE
     (`highlight-regexp').  The highlighting will remain as long as the
     buffer is loaded.  For example, to highlight all occurrences of
     the word "whim" using the default face (a yellow background) `C-x
     w h whim <RET> <RET>'.  Any face can be used for highlighting, Hi
     Lock provides several of its own and these are pre-loaded into a
     history list.  While being prompted for a face use `M-p' and `M-n'
     to cycle through them.

     You can use this command multiple times, specifying various regular
     expressions to highlight in different ways.

`C-x w r REGEXP <RET>'
     Unhighlight REGEXP (`unhighlight-regexp').

     If you invoke this from the menu, you select the expression to
     unhighlight from a list.  If you invoke this from the keyboard, you
     use the minibuffer.  It will show the most recently added regular
     expression; use `M-p' to show the next older expression and `M-n'
     to select the next newer expression.  (You can also type the
     expression by hand, with completion.)  When the expression you
     want to unhighlight appears in the minibuffer, press `<RET>' to
     exit the minibuffer and unhighlight it.

`C-x w l REGEXP <RET> FACE <RET>'
     Highlight entire lines containing a match for REGEXP, using face
     FACE (`highlight-lines-matching-regexp').

`C-x w b'
     Insert all the current highlighting regexp/face pairs into the
     buffer at point, with comment delimiters to prevent them from
     changing your program.  (This key binding runs the
     `hi-lock-write-interactive-patterns' command.)

     These patterns are extracted from the comments, if appropriate, if
     you invoke `M-x hi-lock-find-patterns', or if you visit the file
     while Hi Lock mode is enabled (since that runs
     `hi-lock-find-patterns').

`C-x w i'
     Extract regexp/face pairs from comments in the current buffer
     (`hi-lock-find-patterns').  Thus, you can enter patterns
     interactively with `highlight-regexp', store them into the file
     with `hi-lock-write-interactive-patterns', edit them (perhaps
     including different faces for different parenthesized parts of the
     match), and finally use this command (`hi-lock-find-patterns') to
     have Hi Lock highlight the edited patterns.

     The variable `hi-lock-file-patterns-policy' controls whether Hi
     Lock mode should automatically extract and highlight patterns
     found in a file when it is visited.  Its value can be `nil' (never
     highlight), `t' (highlight the patterns), `ask' (query the user),
     or a function.  If it is a function, `hi-lock-find-patterns' calls
     it with the patterns as argument; if the function returns
     non-`nil', the patterns are used.  The default is `nil'.  Note
     that patterns are always highlighted if you call
     `hi-lock-find-patterns' directly, regardless of the value of this
     variable.

     Also, `hi-lock-find-patterns' does nothing if the current major
     mode's symbol is a member of the list `hi-lock-exclude-modes'.


File: emacs,  Node: Fringes,  Next: Displaying Boundaries,  Prev: Highlight Interactively,  Up: Display

19.9 Window Fringes
===================

On a graphical display, each Emacs window normally has narrow "fringes"
on the left and right edges.  The fringes display indications about the
text in the window.

   The most common use of the fringes is to indicate a continuation
line, when one line of text is split into multiple lines on the screen.
The left fringe shows a curving arrow for each screen line except the
first, indicating that "this is not the real beginning."  The right
fringe shows a curving arrow for each screen line except the last,
indicating that "this is not the real end."

   The fringes indicate line truncation with short horizontal arrows
meaning "there's more text on this line which is scrolled horizontally
out of view;" clicking the mouse on one of the arrows scrolls the
display horizontally in the direction of the arrow.   The fringes can
also indicate other things, such as empty lines, or where a program you
are debugging is executing (*note Debuggers::).

   You can enable and disable the fringes for all frames using `M-x
fringe-mode'.  To enable and disable the fringes for the selected
frame, use `M-x set-fringe-style'.


File: emacs,  Node: Displaying Boundaries,  Next: Useless Whitespace,  Prev: Fringes,  Up: Display

19.10 Displaying Boundaries
===========================

On a graphical display, Emacs can indicate the buffer boundaries in the
fringes.  It indicates the first line and the last line with angle
images in the fringes.  This can be combined with up and down arrow
images which say whether it is possible to scroll the window up and
down.

   The buffer-local variable `indicate-buffer-boundaries' controls how
the buffer boundaries and window scrolling is indicated in the fringes.
If the value is `left' or `right', both angle and arrow bitmaps are
displayed in the left or right fringe, respectively.

   If value is an alist, each element `(INDICATOR .  POSITION)'
specifies the position of one of the indicators.  The INDICATOR must be
one of `top', `bottom', `up', `down', or `t' which specifies the default
position for the indicators not present in the alist.  The POSITION is
one of `left', `right', or `nil' which specifies not to show this
indicator.

   For example, `((top . left) (t . right))' places the top angle
bitmap in left fringe, the bottom angle bitmap in right fringe, and
both arrow bitmaps in right fringe.  To show just the angle bitmaps in
the left fringe, but no arrow bitmaps, use `((top .  left) (bottom .
left))'.

   The value of the variable `default-indicate-buffer-boundaries' is
the default value for `indicate-buffer-boundaries' in buffers that do
not override it.


File: emacs,  Node: Useless Whitespace,  Next: Selective Display,  Prev: Displaying Boundaries,  Up: Display

19.11 Useless Whitespace
========================

It is easy to leave unnecessary spaces at the end of a line, or empty
lines at the end of a file, without realizing it.  In most cases, this
"trailing whitespace" has no effect, but there are special
circumstances where it matters.  It can also be a nuisance that the
line has "changed," when the change is just spaces added or removed at
the end.

   You can make trailing whitespace at the end of a line visible on the
screen by setting the buffer-local variable `show-trailing-whitespace'
to `t'.  Then Emacs displays trailing whitespace in the face
`trailing-whitespace'.

   This feature does not apply when point is at the end of the line
containing the whitespace.  Strictly speaking, that is "trailing
whitespace" nonetheless, but displaying it specially in that case looks
ugly while you are typing in new text.  In this special case, the
location of point is enough to show you that the spaces are present.

   To delete all trailing whitespace within the current buffer's
accessible portion (*note Narrowing::), type `M-x
delete-trailing-whitespace <RET>'.  (This command does not remove the
form-feed characters.)

   Emacs can indicate unused lines at the end of the window with a
small image in the left fringe (*note Fringes::).  The image appears
for window lines that do not correspond to any buffer text.  Blank
lines at the end of the buffer then stand out because they do not have
this image in the fringe.

   To enable this feature, set the buffer-local variable
`indicate-empty-lines' to a non-`nil' value.  The default value of this
variable is controlled by the variable `default-indicate-empty-lines';
by setting that variable, you can enable or disable this feature for
all new buffers.  (This feature currently doesn't work on text-only
terminals.)


File: emacs,  Node: Selective Display,  Next: Optional Mode Line,  Prev: Useless Whitespace,  Up: Display

19.12 Selective Display
=======================

Emacs has the ability to hide lines indented more than a certain number
of columns (you specify how many columns).  You can use this to get an
overview of a part of a program.

   To hide lines in the current buffer, type `C-x $'
(`set-selective-display') with a numeric argument N.  Then lines with
at least N columns of indentation disappear from the screen.  The only
indication of their presence is that three dots (`...') appear at the
end of each visible line that is followed by one or more hidden ones.

   The commands `C-n' and `C-p' move across the hidden lines as if they
were not there.

   The hidden lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of the
hidden text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make all lines visible again, type `C-x $' with no argument.

   If you set the variable `selective-display-ellipses' to `nil', the
three dots do not appear at the end of a line that precedes hidden
lines.  Then there is no visible indication of the hidden lines.  This
variable becomes local automatically when set.

   See also *note Outline Mode:: for another way to hide part of the
text in a buffer.


File: emacs,  Node: Optional Mode Line,  Next: Text Display,  Prev: Selective Display,  Up: Display

19.13 Optional Mode Line Features
=================================

The buffer percentage POS indicates the percentage of the buffer above
the top of the window.  You can additionally display the size of the
buffer by typing `M-x size-indication-mode' to turn on Size Indication
mode.  The size will be displayed immediately following the buffer
percentage like this:

     POS of SIZE

Here SIZE is the human readable representation of the number of
characters in the buffer, which means that `k' for 10^3, `M' for 10^6,
`G' for 10^9, etc., are used to abbreviate.

   If you have narrowed the buffer (*note Narrowing::), the size of the
accessible part of the buffer is shown.

   The current line number of point appears in the mode line when Line
Number mode is enabled.  Use the command `M-x line-number-mode' to turn
this mode on and off; normally it is on.  The line number appears after
the buffer percentage POS, with the letter `L' to indicate what it is.

   Similarly, you can display the current column number by turning on
Column number mode with `M-x column-number-mode'.  The column number is
indicated by the letter `C'.  However, when both of these modes are
enabled, the line and column numbers are displayed in parentheses, the
line number first, rather than with `L' and `C'.  For example:
`(561,2)'.  *Note Minor Modes::, for more information about minor modes
and about how to use these commands.

   If you have narrowed the buffer (*note Narrowing::), the displayed
line number is relative to the accessible portion of the buffer.  Thus,
it isn't suitable as an argument to `goto-line'.  (Use `what-line'
command to see the line number relative to the whole file.)

   If the buffer is very large (larger than the value of
`line-number-display-limit'), then the line number doesn't appear.
Emacs doesn't compute the line number when the buffer is large, because
that would be too slow.  Set it to `nil' to remove the limit.

   Line-number computation can also be slow if the lines in the buffer
are too long.  For this reason, Emacs normally doesn't display line
numbers if the average width, in characters, of lines near point is
larger than the value of the variable
`line-number-display-limit-width'.  The default value is 200 characters.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time' or customize
the option `display-time-mode'.  The information added to the mode line
usually appears after the buffer name, before the mode names and their
parentheses.  It looks like this:

     HH:MMpm L.LL

Here HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number of running processes in the whole
system recently.  (Some fields may be missing if your operating system
cannot support them.)  If you prefer time display in 24-hour format,
set the variable `display-time-24hr-format' to `t'.

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.  On a graphical display you can use an
icon instead of `Mail' by customizing `display-time-use-mail-icon';
this may save some space on the mode line.  You can customize
`display-time-mail-face' to make the mail indicator prominent.  Use
`display-time-mail-file' to specify the mail file to check, or set
`display-time-mail-directory' to specify the directory to check for
incoming mail (any nonempty regular file in the directory is considered
as "newly arrived mail").

   By default, the mode line is drawn on graphics displays with
3D-style highlighting, like that of a button when it is not being
pressed.  If you don't like this effect, you can disable the 3D
highlighting of the mode line, by customizing the attributes of the
`mode-line' face.  *Note Face Customization::.

   By default, the mode line of nonselected windows is displayed in a
different face, called `mode-line-inactive'.  Only the selected window
is displayed in the `mode-line' face.  This helps show which window is
selected.  When the minibuffer is selected, since it has no mode line,
the window from which you activated the minibuffer has its mode line
displayed using `mode-line'; as a result, ordinary entry to the
minibuffer does not change any mode lines.

   You can disable use of `mode-line-inactive' by setting variable
`mode-line-in-non-selected-windows' to `nil'; then all mode lines are
displayed in the `mode-line' face.

   You can customize the mode line display for each of the end-of-line
formats by setting each of the variables `eol-mnemonic-unix',
`eol-mnemonic-dos', `eol-mnemonic-mac', and `eol-mnemonic-undecided' to
the strings you prefer.


File: emacs,  Node: Text Display,  Next: Cursor Display,  Prev: Optional Mode Line,  Up: Display

19.14 How Text Is Displayed
===========================

ASCII printing characters (octal codes 040 through 0176) in Emacs
buffers are displayed with their graphics, as are non-ASCII multibyte
printing characters (octal codes above 0400).

   Some ASCII control characters are displayed in special ways.  The
newline character (octal code 012) is displayed by starting a new line.
The tab character (octal code 011) is displayed by moving to the next
tab stop column (normally every 8 columns).

   Other ASCII control characters are normally displayed as a caret
(`^') followed by the non-control version of the character; thus,
control-A is displayed as `^A'.  The caret appears in face
`escape-glyph'.

   Non-ASCII characters 0200 through 0237 (octal) are displayed with
octal escape sequences; thus, character code 0230 (octal) is displayed
as `\230'.  The backslash appears in face `escape-glyph'.

   If the variable `ctl-arrow' is `nil', control characters in the
buffer are displayed with octal escape sequences, except for newline
and tab.  Altering the value of `ctl-arrow' makes it local to the
current buffer; until that time, the default value is in effect.  The
default is initially `t'.

   The display of character codes 0240 through 0377 (octal) may be
either as escape sequences or as graphics.  They do not normally occur
in multibyte buffers, but if they do, they are displayed as Latin-1
graphics.  In unibyte mode, if you enable European display they are
displayed using their graphics (assuming your terminal supports them),
otherwise as escape sequences.  *Note Unibyte Mode::.

   Some character sets define "no-break" versions of the space and
hyphen characters, which are used where a line should not be broken.
Emacs normally displays these characters with special faces
(respectively, `nobreak-space' and `escape-glyph') to distinguish them
from ordinary spaces and hyphens.  You can turn off this feature by
setting the variable `nobreak-char-display' to `nil'.  If you set the
variable to any other value, that means to prefix these characters with
an escape character.

   Normally, a tab character in the buffer is displayed as whitespace
which extends to the next display tab stop position, and display tab
stops come at intervals equal to eight spaces.  The number of spaces
per tab is controlled by the variable `tab-width', which is made local
by changing it.  Note that how the tab character in the buffer is
displayed has nothing to do with the definition of <TAB> as a command.
The variable `tab-width' must have an integer value between 1 and 1000,
inclusive.  The variable `default-tab-width' controls the default value
of this variable for buffers where you have not set it locally.

   You can customize the way any particular character code is displayed
by means of a display table.  *Note Display Tables: (elisp)Display
Tables.


File: emacs,  Node: Cursor Display,  Next: Line Truncation,  Prev: Text Display,  Up: Display

19.15 Displaying the Cursor
===========================

You can customize the cursor's color, and whether it blinks, using the
`cursor' Custom group (*note Easy Customization::).  On a graphical
display, the command `M-x blink-cursor-mode' enables or disables the
blinking of the cursor.  (On text terminals, the terminal itself blinks
the cursor, and Emacs has no control over it.)  You can control how the
cursor appears when it blinks off by setting the variable
`blink-cursor-alist'.

   Some text terminals offer two different cursors: the normal cursor
and the very visible cursor, where the latter may be e.g. bigger or
blinking.  By default Emacs uses the very visible cursor, and switches
to it when you start or resume Emacs.  If the variable `visible-cursor'
is `nil' when Emacs starts or resumes, it doesn't switch, so it uses
the normal cursor.

   Normally, the cursor appears in non-selected windows without
blinking, with the same appearance as when the blinking cursor blinks
"off."  For a box cursor, this is a hollow box; for a bar cursor, this
is a thinner bar.  To turn off cursors in non-selected windows,
customize the variable `cursor-in-non-selected-windows' and assign it a
`nil' value.

   On graphical displays, Emacs can optionally draw the block cursor as
wide as the character under the cursor--for example, if the cursor is
on a tab character, it would cover the full width occupied by that tab
character.  To enable this feature, set the variable `x-stretch-cursor'
to a non-`nil' value.

   To make the cursor even more visible, you can use HL Line mode, a
minor mode that highlights the line containing point.  Use `M-x
hl-line-mode' to enable or disable it in the current buffer.  `M-x
global-hl-line-mode' enables or disables the same mode globally.


File: emacs,  Node: Line Truncation,  Next: Display Custom,  Prev: Cursor Display,  Up: Display

19.16 Truncation of Lines
=========================

As an alternative to continuation, Emacs can display long lines by
"truncation".  This means that all the characters that do not fit in
the width of the screen or window do not appear at all.  On graphical
displays, a small straight arrow in the fringe indicates truncation at
either end of the line.  On text-only terminals, `$' appears in the
first column when there is text truncated to the left, and in the last
column when there is text truncated to the right.

   Horizontal scrolling automatically causes line truncation (*note
Horizontal Scrolling::).  You can explicitly enable line truncation for
a particular buffer with the command `M-x toggle-truncate-lines'.  This
works by locally changing the variable `truncate-lines'.  If that
variable is non-`nil', long lines are truncated; if it is `nil', they
are continued onto multiple screen lines.  Setting the variable
`truncate-lines' in any way makes it local to the current buffer; until
that time, the default value is in effect.  The default value is
normally `nil'.

   If the variable `truncate-partial-width-windows' is non-`nil', it
forces truncation rather than continuation in any window less than the
full width of the screen or frame, regardless of the value of
`truncate-lines'.  For information about side-by-side windows, see
*note Split Window::.  See also *note Display: (elisp)Display.

   If the variable `overflow-newline-into-fringe' is non-`nil' on a
graphical display, then Emacs does not continue or truncate a line
which is exactly as wide as the window.  Instead, the newline overflows
into the right fringe, and the cursor appears in the fringe when
positioned on that newline.


File: emacs,  Node: Display Custom,  Prev: Line Truncation,  Up: Display

19.17 Customization of Display
==============================

This section describes variables (*note Variables::) that you can
change to customize how Emacs displays.  Beginning users can skip it.

   If the variable `inverse-video' is non-`nil', Emacs attempts to
invert all the lines of the display from what they normally are.

   If the variable `visible-bell' is non-`nil', Emacs attempts to make
the whole screen blink when it would normally make an audible bell
sound.  This variable has no effect if your terminal does not have a way
to make the screen blink.

   The variable `echo-keystrokes' controls the echoing of
multi-character keys; its value is the number of seconds of pause
required to cause echoing to start, or zero, meaning don't echo at all.
The value takes effect when there is someting to echo.  *Note Echo
Area::.

   The variable `baud-rate' holds the output speed of the terminal, as
far as Emacs knows.  Setting this variable does not change the speed of
actual data transmission, but the value is used for calculations.  On
text-only terminals, it affects padding, and decisions about whether to
scroll part of the screen or redraw it instead.  It also affects the
behavior of incremental search.

   On graphical displays, `baud-rate' is only used to determine how
frequently to look for pending input during display updating.  A higher
value of `baud-rate' means that check for pending input will be done
less frequently.

   On graphical display, Emacs can optionally display the mouse pointer
in a special shape to say that Emacs is busy.  To turn this feature on
or off, customize the group `cursor'.  You can also control the amount
of time Emacs must remain busy before the busy indicator is displayed,
by setting the variable `hourglass-delay'.

   On graphical display, the variable `overline-margin' specifies the
vertical position of an overline above the text, including the height
of the overline itself (1 pixel).  The default value is 2 pixels.

   On graphical display, Emacs normally draws an underline at the
baseline level of the font.  If `x-underline-at-descent-line' is
non-`nil', Emacs draws the underline at the same height as the font's
descent line.

   On some text-only terminals, bold face and inverse video together
result in text that is hard to read.  Call the function
`tty-suppress-bold-inverse-default-colors' with a non-`nil' argument to
suppress the effect of bold-face in this case.

   On a text-only terminal, when you reenter Emacs after suspending,
Emacs normally clears the screen and redraws the entire display.  On
some terminals with more than one page of memory, it is possible to
arrange the termcap entry so that the `ti' and `te' strings (output to
the terminal when Emacs is entered and exited, respectively) switch
between pages of memory so as to use one page for Emacs and another
page for other output.  On such terminals, you might want to set the
variable `no-redraw-on-reenter' non-`nil'; this tells Emacs to assume,
when resumed, that the screen page it is using still contains what
Emacs last wrote there.


File: emacs,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

20 Searching and Replacement
****************************

Like other editors, Emacs has commands for searching for occurrences of
a string.  The principal search command is unusual in that it is
"incremental"; it begins to search before you have finished typing the
search string.  There are also nonincremental search commands more like
those of other editors.

   Besides the usual `replace-string' command that finds all
occurrences of one string and replaces them with another, Emacs has a
more flexible replacement command called `query-replace', which asks
interactively which occurrences to replace.  There are also commands to
find and operate on all matches for a pattern.

   You can also search multiple files under control of a tags table
(*note Tags Search::) or through the Dired `A' command (*note Operating
on Files::), or ask the `grep' program to do it (*note Grep
Searching::).

* Menu:

* Incremental Search::		Search happens as you type the string.
* Nonincremental Search::	Specify entire string and then search.
* Word Search::			Search for sequence of words.
* Regexp Search::		Search for match for a regexp.
* Regexps::			Syntax of regular expressions.
* Regexp Backslash::            Regular expression constructs starting with `\'.
* Regexp Example::              A complex regular expression explained.
* Search Case::			To ignore case while searching, or not.
* Replace::			Search, and replace some or all matches.
* Other Repeating Search::	Operating on all matches for some regexp.


File: emacs,  Node: Incremental Search,  Next: Nonincremental Search,  Up: Search

20.1 Incremental Search
=======================

An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) would be
found.  When you have typed enough characters to identify the place you
want, you can stop.  Depending on what you plan to do next, you may or
may not need to terminate the search explicitly with <RET>.

`C-s'
     Incremental search forward (`isearch-forward').

`C-r'
     Incremental search backward (`isearch-backward').

* Menu:

* Basic Isearch::       Basic incremental search commands.
* Repeat Isearch::      Searching for the same string again.
* Error in Isearch::    When your string is not found.
* Special Isearch::     Special input in incremental search.
* Non-ASCII Isearch::   How to search for non-ASCII characters.
* Isearch Yank::        Commands that grab text into the search string
                          or else edit the search string.
* Highlight Isearch::   Isearch highlights the other possible matches.
* Isearch Scroll::      Scrolling during an incremental search.
* Slow Isearch::        Incremental search features for slow terminals.


File: emacs,  Node: Basic Isearch,  Next: Repeat Isearch,  Up: Incremental Search

20.1.1 Basics of Incremental Search
-----------------------------------

`C-s' starts a forward incremental search.  It reads characters from
the keyboard, and moves point past the next occurrence of those
characters.  If you type `C-s' and then `F', that puts the cursor after
the first `F' (the first following the starting point, since this is a
forward search).  Then if you type an `O', you will see the cursor move
to just after the first `FO' (the `F' in that `FO' may or may not be
the first `F').  After another `O', the cursor moves to just after the
first `FOO' after the place where you started the search.  At each
step, the buffer text that matches the search string is highlighted, if
the terminal can do that; the current search string is always displayed
in the echo area.

   If you make a mistake in typing the search string, you can cancel
characters with <DEL>.  Each <DEL> cancels the last character of search
string.  This does not happen until Emacs is ready to read another
input character; first it must either find, or fail to find, the
character you want to erase.  If you do not want to wait for this to
happen, use `C-g' as described below.

   When you are satisfied with the place you have reached, you can type
<RET>, which stops searching, leaving the cursor where the search
brought it.  Also, any command not specially meaningful in searches
stops the searching and is then executed.  Thus, typing `C-a' would
exit the search and then move to the beginning of the line.  <RET> is
necessary only if the next command you want to type is a printing
character, <DEL>, <RET>, or another character that is special within
searches (`C-q', `C-w', `C-r', `C-s', `C-y', `M-y', `M-r', `M-c',
`M-e', and some other meta-characters).

   When you exit the incremental search, it sets the mark where point
_was_ before the search.  That is convenient for moving back there.  In
Transient Mark mode, incremental search sets the mark without
activating it, and does so only if the mark is not already active.


File: emacs,  Node: Repeat Isearch,  Next: Error in Isearch,  Prev: Basic Isearch,  Up: Incremental Search

20.1.2 Repeating Incremental Search
-----------------------------------

Sometimes you search for `FOO' and find one, but not the one you
expected to find.  There was a second `FOO' that you forgot about,
before the one you were aiming for.  In this event, type another `C-s'
to move to the next occurrence of the search string.  You can repeat
this any number of times.  If you overshoot, you can cancel some `C-s'
characters with <DEL>.

   After you exit a search, you can search for the same string again by
typing just `C-s C-s': the first `C-s' is the key that invokes
incremental search, and the second `C-s' means "search again."

   If a search is failing and you ask to repeat it by typing another
`C-s', it starts again from the beginning of the buffer.  Repeating a
failing reverse search with `C-r' starts again from the end.  This is
called "wrapping around", and `Wrapped' appears in the search prompt
once this has happened.  If you keep on going past the original
starting point of the search, it changes to `Overwrapped', which means
that you are revisiting matches that you have already seen.

   To reuse earlier search strings, use the "search ring".  The
commands `M-p' and `M-n' move through the ring to pick a search string
to reuse.  These commands leave the selected search ring element in the
minibuffer, where you can edit it.  To edit the current search string
in the minibuffer without replacing it with items from the search ring,
type `M-e'.  Type `C-s' or `C-r' to terminate editing the string and
search for it.

   You can change to searching backwards with `C-r'.  For instance, if
you are searching forward but you realize you were looking for
something above the starting point, you can do this.  Repeated `C-r'
keeps looking for more occurrences backwards.  A `C-s' starts going
forwards again.  `C-r' in a search can be canceled with <DEL>.

   If you know initially that you want to search backwards, you can use
`C-r' instead of `C-s' to start the search, because `C-r' as a key runs
a command (`isearch-backward') to search backward.  A backward search
finds matches that end before the starting point, just as a forward
search finds matches that begin after it.


File: emacs,  Node: Error in Isearch,  Next: Special Isearch,  Prev: Repeat Isearch,  Up: Incremental Search

20.1.3 Errors in Incremental Search
-----------------------------------

If your string is not found at all, the echo area says `Failing
I-Search'.  The cursor is after the place where Emacs found as much of
your string as it could.  Thus, if you search for `FOOT', and there is
no `FOOT', you might see the cursor after the `FOO' in `FOOL'.  At this
point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the
place you have found, you can type <RET> or some other Emacs command to
remain there.  Or you can type `C-g', which removes from the search
string the characters that could not be found (the `T' in `FOOT'),
leaving those that were found (the `FOO' in `FOOT').  A second `C-g' at
that point cancels the search entirely, returning point to where it was
when the search started.

   The `C-g' "quit" character does special things during searches; just
what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, `C-g' cancels the
entire search.  The cursor moves back to where you started the search.
If `C-g' is typed when there are characters in the search string that
have not been found--because Emacs is still searching for them, or
because it has failed to find them--then the search string characters
which have not been found are discarded from the search string.  With
them gone, the search is now successful and waiting for more input, so
a second `C-g' will cancel the entire search.


File: emacs,  Node: Special Isearch,  Next: Non-ASCII Isearch,  Prev: Error in Isearch,  Up: Incremental Search

20.1.4 Special Input for Incremental Search
-------------------------------------------

An upper-case letter in the search string makes the search
case-sensitive.  If you delete the upper-case character from the search
string, it ceases to have this effect.  *Note Search Case::.

   To search for a newline, type `C-j'.  To search for another control
character, such as control-S or carriage return, you must quote it by
typing `C-q' first.  This function of `C-q' is analogous to its use for
insertion (*note Inserting Text::): it causes the following character
to be treated the way any "ordinary" character is treated in the same
context.  You can also specify a character by its octal code: enter
`C-q' followed by a sequence of octal digits.

   `M-%' typed in incremental search invokes `query-replace' or
`query-replace-regexp' (depending on search mode) with the current
search string used as the string to replace.  *Note Query Replace::.

   Entering <RET> when the search string is empty launches
nonincremental search (*note Nonincremental Search::).

   To customize the special characters that incremental search
understands, alter their bindings in the keymap `isearch-mode-map'.
For a list of bindings, look at the documentation of `isearch-mode' with
`C-h f isearch-mode <RET>'.


File: emacs,  Node: Non-ASCII Isearch,  Next: Isearch Yank,  Prev: Special Isearch,  Up: Incremental Search

20.1.5 Isearch for Non-ASCII Characters
---------------------------------------

To enter non-ASCII characters in an incremental search, you can use
`C-q' (see the previous section), but it is easier to use an input
method (*note Input Methods::).  If an input method is enabled in the
current buffer when you start the search, you can use it in the search
string also.  Emacs indicates that by including the input method
mnemonic in its prompt, like this:

     I-search [IM]:

where IM is the mnemonic of the active input method.

   You can toggle (enable or disable) the input method while you type
the search string with `C-\' (`isearch-toggle-input-method').  You can
turn on a certain (non-default) input method with `C-^'
(`isearch-toggle-specified-input-method'), which prompts for the name
of the input method.  The input method you enable during incremental
search remains enabled in the current buffer afterwards.


File: emacs,  Node: Isearch Yank,  Next: Highlight Isearch,  Prev: Non-ASCII Isearch,  Up: Incremental Search

20.1.6 Isearch Yanking
----------------------

The characters `C-w' and `C-y' can be used in incremental search to
grab text from the buffer into the search string.  This makes it
convenient to search for another occurrence of text at point.  `C-w'
copies the character or word after point as part of the search string,
advancing point over it.  (The decision, whether to copy a character or
a word, is heuristic.)  Another `C-s' to repeat the search will then
search for a string including that character or word.

   `C-y' is similar to `C-w' but copies all the rest of the current
line into the search string.  If point is already at the end of a line,
it grabs the entire next line.  Both `C-y' and `C-w' convert the text
they copy to lower case if the search is currently not case-sensitive;
this is so the search remains case-insensitive.

   `C-M-w' and `C-M-y' modify the search string by only one character
at a time: `C-M-w' deletes the last character from the search string
and `C-M-y' copies the character after point to the end of the search
string.  An alternative method to add the character after point into
the search string is to enter the minibuffer by `M-e' and to type `C-f'
at the end of the search string in the minibuffer.

   The character `M-y' copies text from the kill ring into the search
string.  It uses the same text that `C-y' as a command would yank.
`Mouse-2' in the echo area does the same.  *Note Yanking::.


File: emacs,  Node: Highlight Isearch,  Next: Isearch Scroll,  Prev: Isearch Yank,  Up: Incremental Search

20.1.7 Lazy Search Highlighting
-------------------------------

When you pause for a little while during incremental search, it
highlights all other possible matches for the search string.  This
makes it easier to anticipate where you can get to by typing `C-s' or
`C-r' to repeat the search.  The short delay before highlighting other
matches helps indicate which match is the current one.  If you don't
like this feature, you can turn it off by setting
`isearch-lazy-highlight' to `nil'.

   You can control how this highlighting looks by customizing the faces
`isearch' (used for the current match) and `lazy-highlight' (for all
the other matches).


File: emacs,  Node: Isearch Scroll,  Next: Slow Isearch,  Prev: Highlight Isearch,  Up: Incremental Search

20.1.8 Scrolling During Incremental Search
------------------------------------------

You can enable the use of vertical scrolling during incremental search
(without exiting the search) by setting the customizable variable
`isearch-allow-scroll' to a non-`nil' value.  This applies to using the
vertical scroll-bar and to certain keyboard commands such as `<PRIOR>'
(`scroll-down'), `<NEXT>' (`scroll-up') and `C-l' (`recenter').  You
must run these commands via their key sequences to stay in the
search--typing `M-x' will terminate the search.  You can give prefix
arguments to these commands in the usual way.

   This feature won't let you scroll the current match out of
visibility, however.

   The feature also affects some other commands, such as `C-x 2'
(`split-window-vertically') and `C-x ^' (`enlarge-window') which don't
exactly scroll but do affect where the text appears on the screen.  In
general, it applies to any command whose name has a non-`nil'
`isearch-scroll' property.  So you can control which commands are
affected by changing these properties.

   For example, to make `C-h l' usable within an incremental search in
all future Emacs sessions, use `C-h c' to find what command it runs.
(You type `C-h c C-h l'; it says `view-lossage'.)  Then you can put the
following line in your `.emacs' file (*note Init File::):

     (put 'view-lossage 'isearch-scroll t)

This feature can be applied to any command that doesn't permanently
change point, the buffer contents, the match data, the current buffer,
or the selected window and frame.  The command must not itself attempt
an incremental search.


File: emacs,  Node: Slow Isearch,  Prev: Isearch Scroll,  Up: Incremental Search

20.1.9 Slow Terminal Incremental Search
---------------------------------------

Incremental search on a slow terminal uses a modified style of display
that is designed to take less time.  Instead of redisplaying the buffer
at each place the search gets to, it creates a new single-line window
and uses that to display the line that the search has found.  The
single-line window comes into play as soon as point moves outside of
the text that is already on the screen.

   When you terminate the search, the single-line window is removed.
Emacs then redisplays the window in which the search was done, to show
its new position of point.

   The slow terminal style of display is used when the terminal baud
rate is less than or equal to the value of the variable
`search-slow-speed', initially 1200.  See also the discussion of the
variable `baud-rate' (*note Customization of Display: baud-rate.).

   The number of lines to use in slow terminal search display is
controlled by the variable `search-slow-window-lines'.  Its normal
value is 1.


File: emacs,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

20.2 Nonincremental Search
==========================

Emacs also has conventional nonincremental search commands, which
require you to type the entire search string before searching begins.

`C-s <RET> STRING <RET>'
     Search for STRING.

`C-r <RET> STRING <RET>'
     Search backward for STRING.

   To do a nonincremental search, first type `C-s <RET>'.  This enters
the minibuffer to read the search string; terminate the string with
<RET>, and then the search takes place.  If the string is not found,
the search command signals an error.

   When you type `C-s <RET>', the `C-s' invokes incremental search as
usual.  That command is specially programmed to invoke nonincremental
search, `search-forward', if the string you specify is empty.  (Such an
empty argument would otherwise be useless.)  But it does not call
`search-forward' right away.  First it checks the next input character
to see if is `C-w', which specifies a word search.  *Note Word Search::.
`C-r <RET>' does likewise, for a reverse incremental search.

   Forward and backward nonincremental searches are implemented by the
commands `search-forward' and `search-backward'.  These commands may be
bound to keys in the usual manner.  The feature that you can get to
them via the incremental search commands exists for historical reasons,
and to avoid the need to find separate key sequences for them.


File: emacs,  Node: Word Search,  Next: Regexp Search,  Prev: Nonincremental Search,  Up: Search

20.3 Word Search
================

Word search searches for a sequence of words without regard to how the
words are separated.  More precisely, you type a string of many words,
using single spaces to separate them, and the string can be found even
if there are multiple spaces, newlines, or other punctuation characters
between these words.

   Word search is useful for editing a printed document made with a text
formatter.  If you edit while looking at the printed, formatted version,
you can't tell where the line breaks are in the source file.  With word
search, you can search without having to know them.

`C-s <RET> C-w WORDS <RET>'
     Search for WORDS, ignoring details of punctuation.

`C-r <RET> C-w WORDS <RET>'
     Search backward for WORDS, ignoring details of punctuation.

   Word search as a special case of nonincremental search is invoked
with `C-s <RET> C-w'.  This is followed by the search string, which
must always be terminated with <RET>.  Being nonincremental, this
search does not start until the argument is terminated.  It works by
constructing a regular expression and searching for that; see *note
Regexp Search::.

   Use `C-r <RET> C-w' to do backward word search.

   You can also invoke word search with `C-s M-e C-w' or `C-r M-e C-w'
followed by the search string and terminated with <RET>, `C-s' or
`C-r'.  This puts word search into incremental mode where you can use
all keys available for incremental search.  However, when you type more
words in incremental word search, it will fail until you type complete
words.

   Forward and backward word searches are implemented by the commands
`word-search-forward' and `word-search-backward'.  These commands may
be bound to keys in the usual manner.  They are available via the
incremental search commands both for historical reasons and to avoid
the need to find separate key sequences for them.


File: emacs,  Node: Regexp Search,  Next: Regexps,  Prev: Word Search,  Up: Search

20.4 Regular Expression Search
==============================

A "regular expression" ("regexp", for short) is a pattern that denotes
a class of alternative strings to match, possibly infinitely many.  GNU
Emacs provides both incremental and nonincremental ways to search for a
match for a regexp.  The syntax of regular expressions is explained in
the following section.

   Incremental search for a regexp is done by typing `C-M-s'
(`isearch-forward-regexp'), by invoking `C-s' with a prefix argument
(whose value does not matter), or by typing `M-r' within a forward
incremental search.  This command reads a search string incrementally
just like `C-s', but it treats the search string as a regexp rather
than looking for an exact match against the text in the buffer.  Each
time you add text to the search string, you make the regexp longer, and
the new regexp is searched for.  To search backward for a regexp, use
`C-M-r' (`isearch-backward-regexp'), `C-r' with a prefix argument, or
`M-r' within a backward incremental search.

   All of the control characters that do special things within an
ordinary incremental search have the same function in incremental regexp
search.  Typing `C-s' or `C-r' immediately after starting the search
retrieves the last incremental search regexp used; that is to say,
incremental regexp and non-regexp searches have independent defaults.
They also have separate search rings that you can access with `M-p' and
`M-n'.

   If you type <SPC> in incremental regexp search, it matches any
sequence of whitespace characters, including newlines.  If you want to
match just a space, type `C-q <SPC>'.  You can control what a bare
space matches by setting the variable `search-whitespace-regexp' to the
desired regexp.

   In some cases, adding characters to the regexp in an incremental
regexp search can make the cursor move back and start again.  For
example, if you have searched for `foo' and you add `\|bar', the cursor
backs up in case the first `bar' precedes the first `foo'.

   Forward and backward regexp search are not symmetrical, because
regexp matching in Emacs always operates forward, starting with the
beginning of the regexp.  Thus, forward regexp search scans forward,
trying a forward match at each possible starting position.  Backward
regexp search scans backward, trying a forward match at each possible
starting position.  These search methods are not mirror images.

   Nonincremental search for a regexp is done by the functions
`re-search-forward' and `re-search-backward'.  You can invoke these
with `M-x', or bind them to keys, or invoke them by way of incremental
regexp search with `C-M-s <RET>' and `C-M-r <RET>'.

   If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like `isearch-forward'
and `isearch-backward'.  *Note Incremental Search::.

