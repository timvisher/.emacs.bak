This is ../info/elisp, produced by makeinfo version 4.11 from
elisp.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Elisp: (elisp).       The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   This is edition 2.9 of the GNU Emacs Lisp Reference Manual,
corresponding to Emacs version 22.3.

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008  Free Software
Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "GNU General Public
     License," with the Front-Cover texts being "A GNU Manual," and
     with the Back-Cover Texts as in (a) below.  A copy of the license
     is included in the section entitled "GNU Free Documentation
     License."

     (a) The FSF's Back-Cover Text is: "You are free to copy and modify
     this GNU Manual. Buying copies from GNU Press supports the FSF in
     developing GNU and promoting software freedom."


File: elisp,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

28.7 Displaying Buffers in Windows
==================================

In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.  *Note Buffers and Windows::, for low-level functions that give
you more precise control.  All of these functions work by calling
`set-window-buffer'.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which would be gratuitous and surprise the user.  Instead, use
`set-buffer' and `save-current-buffer' (*note Current Buffer::), which
designate buffers as current for programmed access without affecting
the display of buffers in windows.

 -- Command: switch-to-buffer buffer-or-name &optional norecord
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a new
     buffer by that name is created.  The major mode for the new buffer
     is set according to the variable `default-major-mode'.  *Note Auto
     Major Mode::.  If BUFFER-OR-NAME is `nil', `switch-to-buffer'
     chooses a buffer using `other-buffer'.

     Normally the specified buffer is put at the front of the buffer
     list (both the selected frame's buffer list and the
     frame-independent buffer list).  This affects the operation of
     `other-buffer'.  However, if NORECORD is non-`nil', this is not
     done.  *Note The Buffer List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It returns the buffer that it switched to.

   The next two functions are similar to `switch-to-buffer', except for
the described features.

 -- Command: switch-to-buffer-other-window buffer-or-name &optional
          norecord
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in a window not currently selected.  It then selects that
     window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The currently selected window is absolutely never used to do the
     job.  If it is the only window, then it is split to make a
     distinct window for this purpose.  If the selected window is
     already displaying the buffer, then it continues to do so, but
     another window is nonetheless found to display it in as well.

     This function updates the buffer list just like `switch-to-buffer'
     unless NORECORD is non-`nil'.

 -- Function: pop-to-buffer buffer-or-name &optional other-window
          norecord
     This function makes BUFFER-OR-NAME the current buffer and switches
     to it in some window, preferably not the window previously
     selected.  The "popped-to" window becomes the selected window
     within its frame.  The return value is the buffer that was
     switched to.  If BUFFER-OR-NAME is `nil', that means to choose some
     other buffer, but you don't specify which.

     If the variable `pop-up-frames' is non-`nil', `pop-to-buffer'
     looks for a window in any visible frame already displaying the
     buffer; if there is one, it returns that window and makes it be
     selected within its frame.  If there is none, it creates a new
     frame and displays the buffer in it.

     If `pop-up-frames' is `nil', then `pop-to-buffer' operates
     entirely within the selected frame.  (If the selected frame has
     just a minibuffer, `pop-to-buffer' operates within the most
     recently selected frame that was not just a minibuffer.)

     If the variable `pop-up-windows' is non-`nil', windows may be
     split to create a new window that is different from the original
     window.  For details, see *note Choosing Window::.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     All the variables that affect `display-buffer' affect
     `pop-to-buffer' as well.  *Note Choosing Window::.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.  The major mode for the
     new buffer is set according to the variable `default-major-mode'.
     *Note Auto Major Mode::.

     This function updates the buffer list just like `switch-to-buffer'
     unless NORECORD is non-`nil'.

 -- Command: replace-buffer-in-windows buffer-or-name
     This function replaces BUFFER-OR-NAME with some other buffer in all
     windows displaying it.  It chooses the other buffer with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make sure
     that BUFFER-OR-NAME is no longer displayed.

     This function returns `nil'.


File: elisp,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

28.8 Choosing a Window for Display
==================================

This section describes the basic facility that chooses a window to
display a buffer in--`display-buffer'.  All the higher-level functions
and commands use this subroutine.  Here we describe how to use
`display-buffer' and how to customize it.

 -- Command: display-buffer buffer-or-name &optional not-this-window
          frame
     This command makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.  BUFFER-OR-NAME must be a buffer, or
     the name of an existing buffer.

     If NOT-THIS-WINDOW is non-`nil', it means to display the specified
     buffer in a window other than the selected one, even if it is
     already on display in the selected window.  This can cause the
     buffer to appear in two windows at once.  Otherwise, if
     BUFFER-OR-NAME is already being displayed in any window, that is
     good enough, so this function does nothing.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

     If the argument FRAME is non-`nil', it specifies which frames to
     check when deciding whether the buffer is already displayed.  If
     the buffer is already displayed in some window on one of these
     frames, `display-buffer' simply returns that window.  Here are the
     possible values of FRAME:

        * If it is `nil', consider windows on the selected frame.
          (Actually, the last non-minibuffer frame.)

        * If it is `t', consider windows on all frames.

        * If it is `visible', consider windows on all visible frames.

        * If it is 0, consider windows on all visible or iconified
          frames.

        * If it is a frame, consider windows on that frame.

     Precisely how `display-buffer' finds or creates a window depends on
     the variables described below.

 -- User Option: display-buffer-reuse-frames
     If this variable is non-`nil', `display-buffer' searches existing
     frames for a window displaying the buffer.  If the buffer is
     already displayed in a window in some frame, `display-buffer' makes
     the frame visible and raises it, to use that window.  If the
     buffer is not already displayed, or if
     `display-buffer-reuse-frames' is `nil', `display-buffer''s
     behavior is determined by other variables, described below.

 -- User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new windows.
     If it is non-`nil' and there is only one window, then that window
     is split.  If it is `nil', then `display-buffer' does not split
     the single window, but uses it whole.

 -- User Option: split-height-threshold
     This variable determines when `display-buffer' may split a window,
     if there are multiple windows.  `display-buffer' always splits the
     largest window if it has at least this many lines.  If the largest
     window is not this tall, it is split only if it is the sole window
     and `pop-up-windows' is non-`nil'.

 -- User Option: even-window-heights
     This variable determines if `display-buffer' should even out window
     heights if the buffer gets displayed in an existing window, above
     or beneath another existing window.  If `even-window-heights' is
     `t', the default, window heights will be evened out.  If
     `even-window-heights' is `nil', the original window heights will
     be left alone.

 -- User Option: pop-up-frames
     This variable controls whether `display-buffer' makes new frames.
     If it is non-`nil', `display-buffer' looks for an existing window
     already displaying the desired buffer, on any visible frame.  If
     it finds one, it returns that window.  Otherwise it makes a new
     frame.  The variables `pop-up-windows' and
     `split-height-threshold' do not matter if `pop-up-frames' is
     non-`nil'.

     If `pop-up-frames' is `nil', then `display-buffer' either splits a
     window or reuses one.

     *Note Frames::, for more information.

 -- User Option: pop-up-frame-function
     This variable specifies how to make a new frame if `pop-up-frames'
     is non-`nil'.

     Its value should be a function of no arguments.  When
     `display-buffer' makes a new frame, it does so by calling that
     function, which should return a frame.  The default value of the
     variable is a function that creates a frame using parameters from
     `pop-up-frame-alist'.

 -- User Option: pop-up-frame-alist
     This variable holds an alist specifying frame parameters used when
     `display-buffer' makes a new frame.  *Note Frame Parameters::, for
     more information about frame parameters.

 -- User Option: special-display-buffer-names
     A list of buffer names for buffers that should be displayed
     specially.  If the buffer's name is in this list, `display-buffer'
     handles the buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the buffer name, and the rest of the list says how to
     create the frame.  There are two possibilities for the rest of the
     list (its CDR).  It can be an alist, specifying frame parameters,
     or it can contain a function and arguments to give to it.  (The
     function's first argument is always the buffer to be displayed;
     the arguments from the list come after that.)

     For example:

          (("myfile" (minibuffer) (menu-bar-lines . 0)))

     specifies to display a buffer named `myfile' in a dedicated frame
     with specified `minibuffer' and `menu-bar-lines' parameters.

     The list of frame parameters can also use the phony frame
     parameters `same-frame' and `same-window'.  If the specified frame
     parameters include `(same-window . VALUE)' and VALUE is non-`nil',
     that means to display the buffer in the current selected window.
     Otherwise, if they include `(same-frame .  VALUE)' and VALUE is
     non-`nil', that means to display the buffer in a new window in the
     currently selected frame.

 -- User Option: special-display-regexps
     A list of regular expressions that specify buffers that should be
     displayed specially.  If the buffer's name matches any of the
     regular expressions in this list, `display-buffer' handles the
     buffer specially.

     By default, special display means to give the buffer a dedicated
     frame.

     If an element is a list, instead of a string, then the CAR of the
     list is the regular expression, and the rest of the list says how
     to create the frame.  See above, under
     `special-display-buffer-names'.

 -- Function: special-display-p buffer-name
     This function returns non-`nil' if displaying a buffer named
     BUFFER-NAME with `display-buffer' would create a special frame.
     The value is `t' if it would use the default frame parameters, or
     else the specified list of frame parameters.

 -- Variable: special-display-function
     This variable holds the function to call to display a buffer
     specially.  It receives the buffer as an argument, and should
     return the window in which it is displayed.

     The default value of this variable is
     `special-display-popup-frame'.

 -- Function: special-display-popup-frame buffer &optional args
     This function makes BUFFER visible in a frame of its own.  If
     BUFFER is already displayed in a window in some frame, it makes
     the frame visible and raises it, to use that window.  Otherwise, it
     creates a frame that will be dedicated to BUFFER.  This function
     returns the window it used.

     If ARGS is an alist, it specifies frame parameters for the new
     frame.

     If ARGS is a list whose CAR is a symbol, then `(car ARGS)' is
     called as a function to actually create and set up the frame; it
     is called with BUFFER as first argument, and `(cdr ARGS)' as
     additional arguments.

     This function always uses an existing window displaying BUFFER,
     whether or not it is in a frame of its own; but if you set up the
     above variables in your init file, before BUFFER was created, then
     presumably the window was previously made by this function.

 -- User Option: special-display-frame-alist
     This variable holds frame parameters for
     `special-display-popup-frame' to use when it creates a frame.

 -- User Option: same-window-buffer-names
     A list of buffer names for buffers that should be displayed in the
     selected window.  If the buffer's name is in this list,
     `display-buffer' handles the buffer by switching to it in the
     selected window.

 -- User Option: same-window-regexps
     A list of regular expressions that specify buffers that should be
     displayed in the selected window.  If the buffer's name matches
     any of the regular expressions in this list, `display-buffer'
     handles the buffer by switching to it in the selected window.

 -- Function: same-window-p buffer-name
     This function returns `t' if displaying a buffer named BUFFER-NAME
     with `display-buffer' would put it in the selected window.

 -- Variable: display-buffer-function
     This variable is the most flexible way to customize the behavior of
     `display-buffer'.  If it is non-`nil', it should be a function
     that `display-buffer' calls to do the work.  The function should
     accept two arguments, the first two arguments that `display-buffer'
     received.  It should choose or create a window, display the
     specified buffer in it, and then return the window.

     This hook takes precedence over all the other options and hooks
     described above.

   A window can be marked as "dedicated" to its buffer.  Then
`display-buffer' will not try to use that window to display any other
buffer.

 -- Function: window-dedicated-p window
     This function returns non-`nil' if WINDOW is marked as dedicated;
     otherwise `nil'.

 -- Function: set-window-dedicated-p window flag
     This function marks WINDOW as dedicated if FLAG is non-`nil', and
     nondedicated otherwise.


File: elisp,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

28.9 Windows and Point
======================

Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point
     of another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer from the
     window's value of point.  Conversely, deselecting a window sets the
     window's value of point from that of the buffer.  Thus, when you
     switch between windows that display a given buffer, the point
     value for the selected window is in effect in the buffer, while
     the point values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

*Note Positions::, for more details on buffer positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 -- Function: window-point &optional window
     This function returns the current position of point in WINDOW.
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.  If WINDOW is
     `nil', the selected window is used.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion' forms.
     But that value is hard to find.

 -- Function: set-window-point window position
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.  It returns POSITION.

     If WINDOW is selected, and its buffer is current, this simply does
     `goto-char'.


File: elisp,  Node: Window Start,  Next: Textual Scrolling,  Prev: Window Point,  Up: Windows

28.10 The Window Start Position
===============================

Each window contains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

   After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window start
to the start of a line.  This prevents certain operations from leaving
the window start at a meaningless point within a line.  This feature
may interfere with testing some Lisp code by executing it using the
commands of Lisp mode, because they trigger this readjustment.  To test
such code, put it into a command and bind the command to a key.

 -- Function: window-start &optional window
     This function returns the display-start position of window WINDOW.
     If WINDOW is `nil', the selected window is used.  For example,

          (window-start)
               => 7058

     When you create a window, or display a different buffer in it, the
     display-start position is set to a display-start position recently
     used for the same buffer, or 1 if the buffer doesn't have any.

     Redisplay updates the window-start position (if you have not
     specified it explicitly since the previous redisplay)--for
     example, to make sure point appears on the screen.  Nothing except
     redisplay automatically changes the window-start position; if you
     move point, do not expect the window-start position to change in
     response until after the next redisplay.

     For a realistic example of using `window-start', see the
     description of `count-lines'.  *Note Definition of count-lines::.

 -- Function: window-end &optional window update
     This function returns the position of the end of the display in
     window WINDOW.  If WINDOW is `nil', the selected window is used.

     Simply changing the buffer text or moving point does not update the
     value that `window-end' returns.  The value is updated only when
     Emacs redisplays and redisplay completes without being preempted.

     If the last redisplay of WINDOW was preempted, and did not finish,
     Emacs does not know the position of the end of display in that
     window.  In that case, this function returns `nil'.

     If UPDATE is non-`nil', `window-end' always returns an up-to-date
     value for where the window ends, based on the current
     `window-start' value.  If the saved value is valid, `window-end'
     returns that; otherwise it computes the correct value by scanning
     the buffer text.

     Even if UPDATE is non-`nil', `window-end' does not attempt to
     scroll the display if point has moved off the screen, the way real
     redisplay would do.  It does not alter the `window-start' value.
     In effect, it reports where the displayed text will end if
     scrolling is not required.

 -- Function: set-window-start window position &optional noforce
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.  It returns POSITION.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function using `nil' for NOFORCE, it
     means you want display to start at POSITION even if that would put
     the location of point off the screen.  If this does place point
     off screen, the display routines move point to the left margin on
     the middle line in the window.

     For example, if point is 1 and you set the start of the window
     to 37, the start of the next line, point will be "above" the top
     of the window.  The display routines will automatically move point
     if it is still 1 when redisplay occurs.  Here is an example:

          ;; Here is what `foo' looks like before executing
          ;;   the `set-window-start' expression.

          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------

          (set-window-start
           (selected-window)
           (save-excursion
             (goto-char 1)
             (forward-line 1)
             (point)))
          => 37

          ;; Here is what `foo' looks like after executing
          ;;   the `set-window-start' expression.
          ---------- Buffer: foo ----------
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------

     If NOFORCE is non-`nil', and POSITION would place point off screen
     at the next redisplay, then redisplay computes a new window-start
     position that works well with point, and thus POSITION is not used.

 -- Function: pos-visible-in-window-p &optional position window
          partially
     This function returns non-`nil' if POSITION is within the range of
     text currently visible on the screen in WINDOW.  It returns `nil'
     if POSITION is scrolled vertically out of view.  Locations that
     are partially obscured are not considered visible unless PARTIALLY
     is non-`nil'.  The argument POSITION defaults to the current
     position of point in WINDOW; WINDOW, to the selected window.

     If POSITION is `t', that means to check the last visible position
     in WINDOW.

     The `pos-visible-in-window-p' function considers only vertical
     scrolling.  If POSITION is out of view only because WINDOW has
     been scrolled horizontally, `pos-visible-in-window-p' returns
     non-`nil' anyway.  *Note Horizontal Scrolling::.

     If POSITION is visible, `pos-visible-in-window-p' returns `t' if
     PARTIALLY is `nil'; if PARTIALLY is non-`nil', and the character
     after POSITION is fully visible, it returns a list of the form `(X
     Y)', where X and Y are the pixel coordinates relative to the top
     left corner of the window; otherwise it returns an extended list
     of the form `(X Y RTOP RBOT ROWH VPOS)', where the RTOP and RBOT
     specify the number of off-window pixels at the top and bottom of
     the row at POSITION, ROWH specifies the visible height of that row,
     and VPOS specifies the vertical position (zero-based row number)
     of that row.

     Here is an example:

          ;; If point is off the screen now, recenter it now.
          (or (pos-visible-in-window-p
               (point) (selected-window))
              (recenter 0))

 -- Function: window-line-height &optional line window
     This function returns information about text line LINE in WINDOW.
     If LINE is one of `header-line' or `mode-line',
     `window-line-height' returns information about the corresponding
     line of the window.  Otherwise, LINE is a text line number
     starting from 0.  A negative number counts from the end of the
     window.  The argument LINE defaults to the current line in WINDOW;
     WINDOW, to the selected window.

     If the display is not up to date, `window-line-height' returns
     `nil'.  In that case, `pos-visible-in-window-p' may be used to
     obtain related information.

     If there is no line corresponding to the specified LINE,
     `window-line-height' returns `nil'.  Otherwise, it returns a list
     `(HEIGHT VPOS YPOS OFFBOT)', where HEIGHT is the height in pixels
     of the visible part of the line, VPOS and YPOS are the vertical
     position in lines and pixels of the line relative to the top of
     the first text line, and OFFBOT is the number of off-window pixels
     at the bottom of the text line.  If there are off-window pixels at
     the top of the (first) text line, YPOS is negative.


File: elisp,  Node: Textual Scrolling,  Next: Vertical Scrolling,  Prev: Window Start,  Up: Windows

28.11 Textual Scrolling
=======================

"Textual scrolling" means moving the text up or down through a window.
It works by changing the value of the window's display-start location.
It may also change the value of `window-point' to keep point on the
screen.

   Textual scrolling was formerly called "vertical scrolling," but we
changed its name to distinguish it from the new vertical fractional
scrolling feature (*note Vertical Scrolling::).

   In the commands `scroll-up' and `scroll-down', the directions "up"
and "down" refer to the motion of the text in the buffer at which you
are looking through the window.  Imagine that the text is written on a
long roll of paper and that the scrolling commands move the paper up
and down.  Thus, if you are looking at text in the middle of a buffer
and repeatedly call `scroll-down', you will eventually see the
beginning of the buffer.

   Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
"down" commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

   The textual scrolling functions (aside from `scroll-other-window')
have unpredictable results if the current buffer is different from the
buffer that is displayed in the selected window.  *Note Current
Buffer::.

   If the window contains a row which is taller than the height of the
window (for example in the presence of a large image), the scroll
functions will adjust the window vscroll to scroll the partially
visible row.  To disable this feature, Lisp code may bind the variable
`auto-window-vscroll' to `nil' (*note Vertical Scrolling::).

 -- Command: scroll-up &optional count
     This function scrolls the text in the selected window upward COUNT
     lines.  If COUNT is negative, scrolling is actually downward.

     If COUNT is `nil' (or omitted), then the length of scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-up' returns `nil', unless it gets an error because it
     can't scroll any further.

 -- Command: scroll-down &optional count
     This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

     If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-down' returns `nil', unless it gets an error because it
     can't scroll any further.

 -- Command: scroll-other-window &optional count
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

     You can specify which buffer to scroll by setting the variable
     `other-window-scroll-buffer' to a buffer.  If that buffer isn't
     already displayed, `scroll-other-window' displays it in some
     window.

     When the selected window is the minibuffer, the next window is
     normally the one at the top left corner.  You can specify a
     different window to scroll, when the minibuffer is selected, by
     setting the variable `minibuffer-scroll-window'.  This variable
     has no effect when any other window is selected.  When it is
     non-`nil' and the minibuffer is selected, it takes precedence over
     `other-window-scroll-buffer'.  *Note Definition of
     minibuffer-scroll-window::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll
     to, so the line reappears after the echo area momentarily displays
     the message `Beginning of buffer'.

 -- Variable: other-window-scroll-buffer
     If this variable is non-`nil', it tells `scroll-other-window'
     which buffer to scroll.

 -- User Option: scroll-margin
     This option specifies the size of the scroll margin--a minimum
     number of lines between point and the top or bottom of a window.
     Whenever point gets within this many lines of the top or bottom of
     the window, redisplay scrolls the text automatically (if possible)
     to move point out of the margin, closer to the center of the
     window.

 -- User Option: scroll-conservatively
     This variable controls how scrolling is done automatically when
     point moves off the screen (or into the scroll margin).  If the
     value is a positive integer N, then redisplay scrolls the text up
     to N lines in either direction, if that will bring point back into
     proper view.  This action is called "conservative scrolling".
     Otherwise, scrolling happens in the usual way, under the control of
     other variables such as `scroll-up-aggressively' and
     `scroll-down-aggressively'.

     The default value is zero, which means that conservative scrolling
     never happens.

 -- User Option: scroll-down-aggressively
     The value of this variable should be either `nil' or a fraction F
     between 0 and 1.  If it is a fraction, that specifies where on the
     screen to put point when scrolling down.  More precisely, when a
     window scrolls down because point is above the window start, the
     new start position is chosen to put point F part of the window
     height from the top.  The larger F, the more aggressive the
     scrolling.

     A value of `nil' is equivalent to .5, since its effect is to center
     point.  This variable automatically becomes buffer-local when set
     in any fashion.

 -- User Option: scroll-up-aggressively
     Likewise, for scrolling up.  The value, F, specifies how far point
     should be placed from the bottom of the window; thus, as with
     `scroll-up-aggressively', a larger value scrolls more aggressively.

 -- User Option: scroll-step
     This variable is an older variant of `scroll-conservatively'.  The
     difference is that it if its value is N, that permits scrolling
     only by precisely N lines, not a smaller number.  This feature
     does not work with `scroll-margin'.  The default value is zero.

 -- User Option: scroll-preserve-screen-position
     If this option is `t', scrolling which would move the current
     point position out of the window chooses the new position of point
     so that the vertical position of the cursor is unchanged, if
     possible.

     If it is non-`nil' and not `t', then the scrolling functions
     always preserve the vertical position of point, if possible.

 -- User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, `scroll-up'
     with an argument of `nil' scrolls so that this many lines at the
     bottom of the window appear instead at the top.  The default value
     is `2'.

 -- Command: recenter &optional count
     This function scrolls the text in the selected window so that
     point is displayed at a specified vertical position within the
     window.  It does not "move point" with respect to the text.

     If COUNT is a nonnegative number, that puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.
     If COUNT is a non-`nil' list, then it stands for the line in the
     middle of the window.

     If COUNT is `nil', `recenter' puts the line containing point in
     the middle of the window, then clears and redisplays the entire
     selected frame.

     When `recenter' is called interactively, COUNT is the raw prefix
     argument.  Thus, typing `C-u' as the prefix sets the COUNT to a
     non-`nil' list, while typing `C-u 4' sets COUNT to 4, which
     positions the current line four lines from the top.

     With an argument of zero, `recenter' positions the current line at
     the top of the window.  This action is so handy that some people
     make a separate key binding to do this.  For example,

          (defun line-to-top-of-window ()
            "Scroll current line to top of window.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive)
            (recenter 0))

          (global-set-key [kp-multiply] 'line-to-top-of-window)


File: elisp,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Textual Scrolling,  Up: Windows

28.12 Vertical Fractional Scrolling
===================================

"Vertical fractional scrolling" means shifting the image in the window
up or down by a specified multiple or fraction of a line.  Each window
has a "vertical scroll position", which is a number, never less than
zero.  It specifies how far to raise the contents of the window.
Raising the window contents generally makes all or part of some lines
disappear off the top, and all or part of some other lines appear at
the bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

 -- Function: window-vscroll &optional window pixels-p
     This function returns the current vertical scroll position of
     WINDOW.  If WINDOW is `nil', the selected window is used.  If
     PIXELS-P is non-`nil', the return value is measured in pixels,
     rather than in units of the normal line height.

          (window-vscroll)
               => 0

 -- Function: set-window-vscroll window lines &optional pixels-p
     This function sets WINDOW's vertical scroll position to LINES.
     The argument LINES should be zero or positive; if not, it is taken
     as zero.

     If WINDOW is `nil', the selected window is used.

     The actual vertical scroll position must always correspond to an
     integral number of pixels, so the value you specify is rounded
     accordingly.

     The return value is the result of this rounding.

          (set-window-vscroll (selected-window) 1.2)
               => 1.13

     If PIXELS-P is non-`nil', LINES specifies a number of pixels.  In
     this case, the return value is LINES.

 -- Variable: auto-window-vscroll
     If this variable is non-`nil', the line-move, scroll-up, and
     scroll-down functions will automatically modify the window vscroll
     to scroll through display rows that are taller that the height of
     the window, for example in the presence of large images.


File: elisp,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

28.13 Horizontal Scrolling
==========================

"Horizontal scrolling" means shifting the image in the window left or
right by a specified multiple of the normal character width.  Each
window has a "horizontal scroll position", which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

   The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

   Because we read from side to side in the "inner loop," and from top
to bottom in the "outer loop," the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of _each line_ to go off screen.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

   If `auto-hscroll-mode' is set, redisplay automatically alters the
horizontal scrolling of a window as necessary to ensure that point is
always visible.  However, you can still set the horizontal scrolling
value explicitly.  The value you specify serves as a lower bound for
automatic scrolling, i.e. automatic scrolling will not scroll a window
to a column less than the specified one.

 -- Command: scroll-left &optional count set-minimum
     This function scrolls the selected window COUNT columns to the
     left (or to the right if COUNT is negative).  The default for
     COUNT is the window width, minus 2.

     The return value is the total amount of leftward horizontal
     scrolling in effect after the change--just like the value returned
     by `window-hscroll' (below).

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther right have no effect.

     If SET-MINIMUM is non-`nil', the new scroll amount becomes the
     lower bound for automatic scrolling; that is, automatic scrolling
     will not scroll a window to a column less than the value returned
     by this function.  Interactive calls pass non-`nil' for
     SET-MINIMUM.

 -- Command: scroll-right &optional count set-minimum
     This function scrolls the selected window COUNT columns to the
     right (or to the left if COUNT is negative).  The default for
     COUNT is the window width, minus 2.  Aside from the direction of
     scrolling, this works just like `scroll-left'.

 -- Function: window-hscroll &optional window
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.

     The value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

     If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 -- Function: set-window-hscroll window columns
     This function sets horizontal scrolling of WINDOW.  The value of
     COLUMNS specifies the amount of scrolling, in terms of columns
     from the left margin.  The argument COLUMNS should be zero or
     positive; if not, it is taken as zero.  Fractional values of
     COLUMNS are not supported at present.

     Note that `set-window-hscroll' may appear not to work if you test
     it by evaluating a call with `M-:' in a simple way.  What happens
     is that the function sets the horizontal scroll value and returns,
     but then redisplay adjusts the horizontal scrolling to make point
     visible, and this overrides what the function did.  You can
     observe the function's effect if you call it while point is
     sufficiently far from the left margin that it will remain visible.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (defun hscroll-on-screen (window position)
       (save-excursion
         (goto-char position)
         (and
          (>= (- (current-column) (window-hscroll window)) 0)
          (< (- (current-column) (window-hscroll window))
             (window-width window)))))


File: elisp,  Node: Size of Window,  Next: Resizing Windows,  Prev: Horizontal Scrolling,  Up: Windows

28.14 The Size of a Window
==========================

An Emacs window is rectangular, and its size information consists of
the height (the number of lines) and the width (the number of character
positions in each line).  The mode line is included in the height.  But
the width does not count the scroll bar or the column of `|' characters
that separates side-by-side windows.

   The following three functions return size information about a window:

 -- Function: window-height &optional window
     This function returns the number of lines in WINDOW, including its
     mode line and header line, if any.  If WINDOW fills its entire
     frame except for the echo area, this is typically one less than
     the value of `frame-height' on that frame.

     If WINDOW is `nil', the function uses the selected window.

          (window-height)
               => 23
          (split-window-vertically)
               => #<window 4 on windows.texi>
          (window-height)
               => 11

 -- Function: window-body-height &optional window
     Like `window-height' but the value does not include the mode line
     (if any) or the header line (if any).

 -- Function: window-width &optional window
     This function returns the number of columns in WINDOW.  If WINDOW
     fills its entire frame, this is the same as the value of
     `frame-width' on that frame.  The width does not include the
     window's scroll bar or the column of `|' characters that separates
     side-by-side windows.

     If WINDOW is `nil', the function uses the selected window.

          (window-width)
               => 80

 -- Function: window-full-width-p &optional window
     This function returns non-`nil' if WINDOW is as wide as the frame
     that contains it; otherwise `nil'.  If WINDOW is `nil', the
     function uses the selected window.

 -- Function: window-edges &optional window
     This function returns a list of the edge coordinates of WINDOW.
     If WINDOW is `nil', the selected window is used.

     The order of the list is `(LEFT TOP RIGHT BOTTOM)', all elements
     relative to 0, 0 at the top left corner of the frame.  The element
     RIGHT of the value is one more than the rightmost column used by
     WINDOW, and BOTTOM is one more than the bottommost row used by
     WINDOW and its mode-line.

     The edges include the space used by the window's scroll bar,
     display margins, fringes, header line, and mode line, if it has
     them.  Also, if the window has a neighbor on the right, its right
     edge value includes the width of the separator line between the
     window and that neighbor.  Since the width of the window does not
     include this separator, the width does not usually equal the
     difference between the right and left edges.

 -- Function: window-inside-edges &optional window
     This is similar to `window-edges', but the edge values it returns
     include only the text area of the window.  They do not include the
     header line, mode line, scroll bar or vertical separator, fringes,
     or display margins.

   Here are the results obtained on a typical 24-line terminal with just
one window, with menu bar enabled:

     (window-edges (selected-window))
          => (0 1 80 23)
     (window-inside-edges (selected-window))
          => (0 1 80 22)

The bottom edge is at line 23 because the last line is the echo area.
The bottom inside edge is at line 22, which is the window's mode line.

   If WINDOW is at the upper left corner of its frame, and there is no
menu bar, then BOTTOM returned by `window-edges' is the same as the
value of `(window-height)', RIGHT is almost the same as the value of
`(window-width)', and TOP and LEFT are zero.  For example, the edges of
the following window are `0 0 8 5'.  Assuming that the frame has more
than 8 columns, the last column of the window (column 7) holds a border
rather than text.  The last row (row 4) holds the mode line, shown here
with `xxxxxxxxx'.

                0
                _______
             0 |       |
               |       |
               |       |
               |       |
               xxxxxxxxx  4

                       7

   In the following example, let's suppose that the frame is 7 columns
wide.  Then the edges of the left window are `0 0 4 3' and the edges of
the right window are `4 0 7 3'.  The inside edges of the left window
are `0 0 3 2', and the inside edges of the right window are `4 0 7 2',

                ___ ___
               |   |   |
               |   |   |
               xxxxxxxxx

                0  34  7

 -- Function: window-pixel-edges &optional window
     This function is like `window-edges' except that, on a graphical
     display, the edge values are measured in pixels instead of in
     character lines and columns.

 -- Function: window-inside-pixel-edges &optional window
     This function is like `window-inside-edges' except that, on a
     graphical display, the edge values are measured in pixels instead
     of in character lines and columns.


File: elisp,  Node: Resizing Windows,  Next: Coordinates and Windows,  Prev: Size of Window,  Up: Windows

28.15 Changing the Size of a Window
===================================

The window size functions fall into two classes: high-level commands
that change the size of windows and low-level functions that access
window size.  Emacs does not permit overlapping windows or gaps between
windows, so resizing one window affects other windows.

 -- Command: enlarge-window size &optional horizontal
     This function makes the selected window SIZE lines taller,
     stealing lines from neighboring windows.  It takes the lines from
     one window at a time until that window is used up, then takes from
     another.  If a window from which lines are stolen shrinks below
     `window-min-height' lines, that window disappears.

     If HORIZONTAL is non-`nil', this function makes WINDOW wider by
     SIZE columns, stealing columns instead of lines.  If a window from
     which columns are stolen shrinks below `window-min-width' columns,
     that window disappears.

     If the requested size would exceed that of the window's frame,
     then the function makes the window occupy the entire height (or
     width) of the frame.

     If there are various other windows from which lines or columns can
     be stolen, and some of them specify fixed size (using
     `window-size-fixed', see below), they are left untouched while
     other windows are "robbed."  If it would be necessary to alter the
     size of a fixed-size window, `enlarge-window' gets an error
     instead.

     If SIZE is negative, this function shrinks the window by -SIZE
     lines or columns.  If that makes the window smaller than the
     minimum size (`window-min-height' and `window-min-width'),
     `enlarge-window' deletes the window.

     `enlarge-window' returns `nil'.

 -- Command: enlarge-window-horizontally columns
     This function makes the selected window COLUMNS wider.  It could
     be defined as follows:

          (defun enlarge-window-horizontally (columns)
            (interactive "p")
            (enlarge-window columns t))

 -- Command: shrink-window size &optional horizontal
     This function is like `enlarge-window' but negates the argument
     SIZE, making the selected window smaller by giving lines (or
     columns) to the other windows.  If the window shrinks below
     `window-min-height' or `window-min-width', then it disappears.

     If SIZE is negative, the window is enlarged by -SIZE lines or
     columns.

 -- Command: shrink-window-horizontally columns
     This function makes the selected window COLUMNS narrower.  It
     could be defined as follows:

          (defun shrink-window-horizontally (columns)
            (interactive "p")
            (shrink-window columns t))

 -- Function: adjust-window-trailing-edge window delta horizontal
     This function makes the selected window DELTA lines taller or
     DELTA columns wider, by moving the bottom or right edge.  This
     function does not delete other windows; if it cannot make the
     requested size adjustment, it signals an error.  On success, this
     function returns `nil'.

 -- Function: fit-window-to-buffer &optional window max-height
          min-height
     This function makes WINDOW the right height to display its
     contents exactly.  If WINDOW is omitted or `nil', it uses the
     selected window.

     The argument MAX-HEIGHT specifies the maximum height the window is
     allowed to be; `nil' means use the frame height.  The argument
     MIN-HEIGHT specifies the minimum height for the window; `nil'
     means use `window-min-height'.  All these height values include
     the mode-line and/or header-line.

 -- Command: shrink-window-if-larger-than-buffer &optional window
     This command shrinks WINDOW vertically to be as small as possible
     while still showing the full contents of its buffer--but not less
     than `window-min-height' lines.  If WINDOW is not given, it
     defaults to the selected window.

     However, the command does nothing if the window is already too
     small to display the whole text of the buffer, or if part of the
     contents are currently scrolled off screen, or if the window is
     not the full width of its frame, or if the window is the only
     window in its frame.

     This command returns non-`nil' if it actually shrank the window
     and `nil' otherwise.

 -- Variable: window-size-fixed
     If this variable is non-`nil', in any given buffer, then the size
     of any window displaying the buffer remains fixed unless you
     explicitly change it or Emacs has no other choice.

     If the value is `height', then only the window's height is fixed;
     if the value is `width', then only the window's width is fixed.
     Any other non-`nil' value fixes both the width and the height.

     This variable automatically becomes buffer-local when set.

     Explicit size-change functions such as `enlarge-window' get an
     error if they would have to change a window size which is fixed.
     Therefore, when you want to change the size of such a window, you
     should bind `window-size-fixed' to `nil', like this:

          (let ((window-size-fixed nil))
             (enlarge-window 10))

     Note that changing the frame size will change the size of a
     fixed-size window, if there is no other alternative.

   The following two variables constrain the window-structure-changing
functions to a minimum height and width.

 -- User Option: window-min-height
     The value of this variable determines how short a window may become
     before it is automatically deleted.  Making a window smaller than
     `window-min-height' automatically deletes it, and no window may be
     created shorter than this.  The default value is 4.

     The absolute minimum window height is one; actions that change
     window sizes reset this variable to one if it is less than one.

 -- User Option: window-min-width
     The value of this variable determines how narrow a window may
     become before it is automatically deleted.  Making a window
     smaller than `window-min-width' automatically deletes it, and no
     window may be created narrower than this.  The default value is 10.

     The absolute minimum window width is two; actions that change
     window sizes reset this variable to two if it is less than two.


File: elisp,  Node: Coordinates and Windows,  Next: Window Tree,  Prev: Resizing Windows,  Up: Windows

28.16 Coordinates and Windows
=============================

This section describes how to relate screen coordinates to windows.

 -- Function: window-at x y &optional frame
     This function returns the window containing the specified cursor
     position in the frame FRAME.  The coordinates X and Y are measured
     in characters and count from the top left corner of the frame.  If
     they are out of range, `window-at' returns `nil'.

     If you omit FRAME, the selected frame is used.

 -- Function: coordinates-in-window-p coordinates window
     This function checks whether a particular frame position falls
     within the window WINDOW.

     The argument COORDINATES is a cons cell of the form `(X . Y)'.
     The coordinates X and Y are measured in characters, and count from
     the top left corner of the screen or frame.

     The value returned by `coordinates-in-window-p' is non-`nil' if
     the coordinates are inside WINDOW.  The value also indicates what
     part of the window the position is in, as follows:

    `(RELX . RELY)'
          The coordinates are inside WINDOW.  The numbers RELX and RELY
          are the equivalent window-relative coordinates for the
          specified position, counting from 0 at the top left corner of
          the window.

    `mode-line'
          The coordinates are in the mode line of WINDOW.

    `header-line'
          The coordinates are in the header line of WINDOW.

    `vertical-line'
          The coordinates are in the vertical line between WINDOW and
          its neighbor to the right.  This value occurs only if the
          window doesn't have a scroll bar; positions in a scroll bar
          are considered outside the window for these purposes.

    `left-fringe'
    `right-fringe'
          The coordinates are in the left or right fringe of the window.

    `left-margin'
    `right-margin'
          The coordinates are in the left or right margin of the window.

    `nil'
          The coordinates are not in any part of WINDOW.

     The function `coordinates-in-window-p' does not require a frame as
     argument because it always uses the frame that WINDOW is on.


File: elisp,  Node: Window Tree,  Next: Window Configurations,  Prev: Coordinates and Windows,  Up: Windows

28.17 The Window Tree
=====================

A "window tree" specifies the layout, size, and relationship between
all windows in one frame.

 -- Function: window-tree &optional frame
     This function returns the window tree for frame FRAME.  If FRAME
     is omitted, the selected frame is used.

     The return value is a list of the form `(ROOT MINI)', where ROOT
     represents the window tree of the frame's root window, and MINI is
     the frame's minibuffer window.

     If the root window is not split, ROOT is the root window itself.
     Otherwise, ROOT is a list `(DIR EDGES W1 W2 ...)' where DIR is
     `nil' for a horizontal split, and `t' for a vertical split, EDGES
     gives the combined size and position of the subwindows in the
     split, and the rest of the elements are the subwindows in the
     split.  Each of the subwindows may again be a window or a list
     representing a window split, and so on.  The EDGES element is a
     list `(LEFT TOP RIGHT BOTTOM)' similar to the value returned by
     `window-edges'.


File: elisp,  Node: Window Configurations,  Next: Window Hooks,  Prev: Window Tree,  Up: Windows

28.18 Window Configurations
===========================

A "window configuration" records the entire layout of one frame--all
windows, their sizes, which buffers they contain, how those buffers are
scrolled, and their values of point and the mark; also their fringes,
margins, and scroll bar settings.  It also includes the values of
`window-min-height', `window-min-width' and `minibuffer-scroll-window'.
As a special exception, the window configuration does not record the
value of point in the selected window for the current buffer.

   You can bring back an entire previous layout by restoring a window
configuration previously saved.  If you want to record all frames
instead of just one, use a frame configuration instead of a window
configuration.  *Note Frame Configurations::.

 -- Function: current-window-configuration &optional frame
     This function returns a new object representing FRAME's current
     window configuration.  If FRAME is omitted, the selected frame is
     used.

 -- Function: set-window-configuration configuration
     This function restores the configuration of windows and buffers as
     specified by CONFIGURATION, for the frame that CONFIGURATION was
     created for.

     The argument CONFIGURATION must be a value that was previously
     returned by `current-window-configuration'.  This configuration is
     restored in the frame from which CONFIGURATION was made, whether
     that frame is selected or not.  This always counts as a window size
     change and triggers execution of the `window-size-change-functions'
     (*note Window Hooks::), because `set-window-configuration' doesn't
     know how to tell whether the new configuration actually differs
     from the old one.

     If the frame which CONFIGURATION was saved from is dead, all this
     function does is restore the three variables `window-min-height',
     `window-min-width' and `minibuffer-scroll-window'. In this case,
     the function returns `nil'.  Otherwise, it returns `t'.

     Here is a way of using this function to get the same effect as
     `save-window-excursion':

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-vertically nil)
                       ...)
              (set-window-configuration config)))

 -- Special Form: save-window-excursion forms...
     This special form records the window configuration, executes FORMS
     in sequence, then restores the earlier window configuration.  The
     window configuration includes, for each window, the value of point
     and the portion of the buffer that is visible.  It also includes
     the choice of selected window.  However, it does not include the
     value of point in the current buffer; use `save-excursion' also,
     if you wish to preserve that.

     Don't use this construct when `save-selected-window' is sufficient.

     Exit from `save-window-excursion' always triggers execution of the
     `window-size-change-functions'.  (It doesn't know how to tell
     whether the restored configuration actually differs from the one in
     effect at the end of the FORMS.)

     The return value is the value of the final form in FORMS.  For
     example:

          (split-window)
               => #<window 25 on control.texi>
          (setq w (selected-window))
               => #<window 19 on control.texi>
          (save-window-excursion
            (delete-other-windows w)
            (switch-to-buffer "foo")
            'do-something)
               => do-something
               ;; The screen is now split again.

 -- Function: window-configuration-p object
     This function returns `t' if OBJECT is a window configuration.

 -- Function: compare-window-configurations config1 config2
     This function compares two window configurations as regards the
     structure of windows, but ignores the values of point and mark and
     the saved scrolling positions--it can return `t' even if those
     aspects differ.

     The function `equal' can also compare two window configurations; it
     regards configurations as unequal if they differ in any respect,
     even a saved point or mark.

 -- Function: window-configuration-frame config
     This function returns the frame for which the window configuration
     CONFIG was made.

   Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file `winner.el' for some more operations on windows configurations.


File: elisp,  Node: Window Hooks,  Prev: Window Configurations,  Up: Windows

28.19 Hooks for Window Scrolling and Changes
============================================

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run `window-scroll-functions'; the last runs
`window-size-change-functions'.

 -- Variable: window-scroll-functions
     This variable holds a list of functions that Emacs should call
     before redisplaying a window with scrolling.  It is not a normal
     hook, because each function is called with two arguments: the
     window, and its new display-start position.

     Displaying a different buffer in the window also runs these
     functions.

     These functions must be careful in using `window-end' (*note
     Window Start::); if you need an up-to-date value, you must use the
     UPDATE argument to ensure you get it.

     *Warning:* don't use this feature to alter the way the window is
     scrolled.  It's not designed for that, and such use probably won't
     work.

 -- Variable: window-size-change-functions
     This variable holds a list of functions to be called if the size
     of any window changes for any reason.  The functions are called
     just once per redisplay, and just once for each frame on which
     size changes have occurred.

     Each function receives the frame as its sole argument.  There is no
     direct way to find out which windows on that frame have changed
     size, or precisely how.  However, if a size-change function
     records, at each call, the existing windows and their sizes, it
     can also compare the present sizes and the previous sizes.

     Creating or deleting windows counts as a size change, and therefore
     causes these functions to be called.  Changing the frame size also
     counts, because it changes the sizes of the existing windows.

     It is not a good idea to use `save-window-excursion' (*note Window
     Configurations::) in these functions, because that always counts
     as a size change, and it would cause these functions to be called
     over and over.  In most cases, `save-selected-window' (*note
     Selecting Windows::) is what you need here.

 -- Variable: redisplay-end-trigger-functions
     This abnormal hook is run whenever redisplay in a window uses text
     that extends past a specified end trigger position.  You set the
     end trigger position with the function
     `set-window-redisplay-end-trigger'.  The functions are called with
     two arguments: the window, and the end trigger position.  Storing
     `nil' for the end trigger position turns off the feature, and the
     trigger value is automatically reset to `nil' just after the hook
     is run.

 -- Function: set-window-redisplay-end-trigger window position
     This function sets WINDOW's end trigger position at POSITION.

 -- Function: window-redisplay-end-trigger &optional window
     This function returns WINDOW's current end trigger position.  If
     WINDOW is `nil' or omitted, it uses the selected window.

 -- Variable: window-configuration-change-hook
     A normal hook that is run every time you change the window
     configuration of an existing frame.  This includes splitting or
     deleting windows, changing the sizes of windows, or displaying a
     different buffer in a window.  The frame whose window
     configuration has changed is the selected frame when this hook
     runs.


File: elisp,  Node: Frames,  Next: Positions,  Prev: Windows,  Up: Top

29 Frames
*********

In Emacs editing, A "frame" is a screen object that contains one or
more Emacs windows.  It's the kind of object that is called a "window"
in the terminology of graphical environments; but we can't call it a
"window" here, because Emacs uses that word in a different way.

   A frame initially contains a single main window and/or a minibuffer
window; you can subdivide the main window vertically or horizontally
into smaller windows.  In Emacs Lisp, a "frame object" is a Lisp object
that represents a frame on the screen.

   When Emacs runs on a text-only terminal, it starts with one
"terminal frame".  If you create additional ones, Emacs displays one
and only one at any given time--on the terminal screen, of course.

   When Emacs communicates directly with a supported window system, such
as X, it does not have a terminal frame; instead, it starts with a
single "window frame", but you can create more, and Emacs can display
several such frames at once as is usual for window systems.

 -- Function: framep object
     This predicate returns a non-`nil' value if OBJECT is a frame, and
     `nil' otherwise.  For a frame, the value indicates which kind of
     display the frame uses:

    `x'
          The frame is displayed in an X window.

    `t'
          A terminal frame on a character display.

    `mac'
          The frame is displayed on a Macintosh.

    `w32'
          The frame is displayed on MS-Windows 9X/NT.

    `pc'
          The frame is displayed on an MS-DOS terminal.

* Menu:

* Creating Frames::		Creating additional frames.
* Multiple Displays::           Creating frames on other displays.
* Frame Parameters::		Controlling frame size, position, font, etc.
* Frame Titles::                Automatic updating of frame titles.
* Deleting Frames::		Frames last until explicitly deleted.
* Finding All Frames::		How to examine all existing frames.
* Frames and Windows::		A frame contains windows;
				  display of text always works through windows.
* Minibuffers and Frames::	How a frame finds the minibuffer to use.
* Input Focus::			Specifying the selected frame.
* Visibility of Frames::	Frames may be visible or invisible, or icons.
* Raising and Lowering::	Raising a frame makes it hide other windows;
				  lowering it makes the others hide it.
* Frame Configurations::	Saving the state of all frames.
* Mouse Tracking::		Getting events that say when the mouse moves.
* Mouse Position::		Asking where the mouse is, or moving it.
* Pop-Up Menus::		Displaying a menu for the user to select from.
* Dialog Boxes::                Displaying a box to ask yes or no.
* Pointer Shape::               Specifying the shape of the mouse pointer.
* Window System Selections::    Transferring text to and from other X clients.
* Drag and Drop::               Internals of Drag-and-Drop implementation.
* Color Names::	                Getting the definitions of color names.
* Text Terminal Colors::        Defining colors for text-only terminals.
* Resources::		        Getting resource values from the server.
* Display Feature Testing::     Determining the features of a terminal.

   *Note Display::, for information about the related topic of
controlling Emacs redisplay.


File: elisp,  Node: Creating Frames,  Next: Multiple Displays,  Up: Frames

29.1 Creating Frames
====================

To create a new frame, call the function `make-frame'.

 -- Function: make-frame &optional alist
     This function creates and returns a new frame, displaying the
     current buffer.  If you are using a supported window system, it
     makes a window frame; otherwise, it makes a terminal frame.

     The argument is an alist specifying frame parameters.  Any
     parameters not mentioned in ALIST default according to the value
     of the variable `default-frame-alist'; parameters not specified
     even there default from the standard X resources or whatever is
     used instead on your system.

     The set of possible parameters depends in principle on what kind of
     window system Emacs uses to display its frames.  *Note Window
     Frame Parameters::, for documentation of individual parameters you
     can specify.

     This function itself does not make the new frame the selected
     frame.  *Note Input Focus::.  The previously selected frame
     remains selected.  However, the window system may select the new
     frame for its own reasons, for instance if the frame appears under
     the mouse pointer and your setup is for focus to follow the
     pointer.

 -- Variable: before-make-frame-hook
     A normal hook run by `make-frame' before it actually creates the
     frame.

 -- Variable: after-make-frame-functions
     An abnormal hook run by `make-frame' after it creates the frame.
     Each function in `after-make-frame-functions' receives one
     argument, the frame just created.


File: elisp,  Node: Multiple Displays,  Next: Frame Parameters,  Prev: Creating Frames,  Up: Frames

29.2 Multiple Displays
======================

A single Emacs can talk to more than one X display.  Initially, Emacs
uses just one display--the one chosen with the `DISPLAY' environment
variable or with the `--display' option (*note Initial Options:
(emacs)Initial Options.).  To connect to another display, use the
command `make-frame-on-display' or specify the `display' frame
parameter when you create the frame.

   Emacs treats each X server as a separate terminal, giving each one
its own selected frame and its own minibuffer windows.  However, only
one of those frames is "_the_ selected frame" at any given moment, see
*note Input Focus::.

   A few Lisp variables are "terminal-local"; that is, they have a
separate binding for each terminal.  The binding in effect at any time
is the one for the terminal that the currently selected frame belongs
to.  These variables include `default-minibuffer-frame',
`defining-kbd-macro', `last-kbd-macro', and `system-key-alist'.  They
are always terminal-local, and can never be buffer-local (*note
Buffer-Local Variables::).

   A single X server can handle more than one screen.  A display name
`HOST:SERVER.SCREEN' has three parts; the last part specifies the
screen number for a given server.  When you use two screens belonging
to one server, Emacs knows by the similarity in their names that they
share a single keyboard, and it treats them as a single terminal.

   Note that some graphical terminals can output to more than a one
monitor (or other output device) at the same time.  On these
"multi-monitor" setups, a single DISPLAY value controls the output to
all the physical monitors.  In this situation, there is currently no
platform-independent way for Emacs to distinguish between the different
physical monitors.

 -- Command: make-frame-on-display display &optional parameters
     This creates and returns a new frame on display DISPLAY, taking
     the other frame parameters from PARAMETERS.  Aside from the
     DISPLAY argument, it is like `make-frame' (*note Creating
     Frames::).

 -- Function: x-display-list
     This returns a list that indicates which X displays Emacs has a
     connection to.  The elements of the list are strings, and each one
     is a display name.

 -- Function: x-open-connection display &optional xrm-string
          must-succeed
     This function opens a connection to the X display DISPLAY.  It
     does not create a frame on that display, but it permits you to
     check that communication can be established with that display.

     The optional argument XRM-STRING, if not `nil', is a string of
     resource names and values, in the same format used in the
     `.Xresources' file.  The values you specify override the resource
     values recorded in the X server itself; they apply to all Emacs
     frames created on this display.  Here's an example of what this
     string might look like:

          "*BorderWidth: 3\n*InternalBorder: 2\n"

     *Note X Resources: (emacs)X Resources.

     If MUST-SUCCEED is non-`nil', failure to open the connection
     terminates Emacs.  Otherwise, it is an ordinary Lisp error.

 -- Function: x-close-connection display
     This function closes the connection to display DISPLAY.  Before
     you can do this, you must first delete all the frames that were
     open on that display (*note Deleting Frames::).


File: elisp,  Node: Frame Parameters,  Next: Frame Titles,  Prev: Multiple Displays,  Up: Frames

29.3 Frame Parameters
=====================

A frame has many parameters that control its appearance and behavior.
Just what parameters a frame has depends on what display mechanism it
uses.

   Frame parameters exist mostly for the sake of window systems.  A
terminal frame has a few parameters, mostly for compatibility's sake;
only the `height', `width', `name', `title', `menu-bar-lines',
`buffer-list' and `buffer-predicate' parameters do something special.
If the terminal supports colors, the parameters `foreground-color',
`background-color', `background-mode' and `display-type' are also
meaningful.

* Menu:

* Parameter Access::       How to change a frame's parameters.
* Initial Parameters::	   Specifying frame parameters when you make a frame.
* Window Frame Parameters:: List of frame parameters for window systems.
* Size and Position::      Changing the size and position of a frame.
* Geometry::               Parsing geometry specifications.


File: elisp,  Node: Parameter Access,  Next: Initial Parameters,  Up: Frame Parameters

29.3.1 Access to Frame Parameters
---------------------------------

These functions let you read and change the parameter values of a frame.

 -- Function: frame-parameter frame parameter
     This function returns the value of the parameter PARAMETER (a
     symbol) of FRAME.  If FRAME is `nil', it returns the selected
     frame's parameter.  If FRAME has no setting for PARAMETER, this
     function returns `nil'.

 -- Function: frame-parameters &optional frame
     The function `frame-parameters' returns an alist listing all the
     parameters of FRAME and their values.  If FRAME is `nil' or
     omitted, this returns the selected frame's parameters

 -- Function: modify-frame-parameters frame alist
     This function alters the parameters of frame FRAME based on the
     elements of ALIST.  Each element of ALIST has the form `(PARM .
     VALUE)', where PARM is a symbol naming a parameter.  If you don't
     mention a parameter in ALIST, its value doesn't change.  If FRAME
     is `nil', it defaults to the selected frame.

 -- Function: modify-all-frames-parameters alist
     This function alters the frame parameters of all existing frames
     according to ALIST, then modifies `default-frame-alist' (and, if
     necessary, `initial-frame-alist') to apply the same parameter
     values to frames that will be created henceforth.


File: elisp,  Node: Initial Parameters,  Next: Window Frame Parameters,  Prev: Parameter Access,  Up: Frame Parameters

29.3.2 Initial Frame Parameters
-------------------------------

You can specify the parameters for the initial startup frame by setting
`initial-frame-alist' in your init file (*note Init File::).

 -- Variable: initial-frame-alist
     This variable's value is an alist of parameter values used when
     creating the initial window frame.  You can set this variable to
     specify the appearance of the initial frame without altering
     subsequent frames.  Each element has the form:

          (PARAMETER . VALUE)

     Emacs creates the initial frame before it reads your init file.
     After reading that file, Emacs checks `initial-frame-alist', and
     applies the parameter settings in the altered value to the already
     created initial frame.

     If these settings affect the frame geometry and appearance, you'll
     see the frame appear with the wrong ones and then change to the
     specified ones.  If that bothers you, you can specify the same
     geometry and appearance with X resources; those do take effect
     before the frame is created.  *Note X Resources: (emacs)X
     Resources.

     X resource settings typically apply to all frames.  If you want to
     specify some X resources solely for the sake of the initial frame,
     and you don't want them to apply to subsequent frames, here's how
     to achieve this.  Specify parameters in `default-frame-alist' to
     override the X resources for subsequent frames; then, to prevent
     these from affecting the initial frame, specify the same
     parameters in `initial-frame-alist' with values that match the X
     resources.

   If these parameters specify a separate minibuffer-only frame with
`(minibuffer . nil)', and you have not created one, Emacs creates one
for you.

 -- Variable: minibuffer-frame-alist
     This variable's value is an alist of parameter values used when
     creating an initial minibuffer-only frame--if such a frame is
     needed, according to the parameters for the main initial frame.

 -- Variable: default-frame-alist
     This is an alist specifying default values of frame parameters for
     all Emacs frames--the first frame, and subsequent frames.  When
     using the X Window System, you can get the same results by means
     of X resources in many cases.

     Setting this variable does not affect existing frames.

   See also `special-display-frame-alist'.  *Note Definition of
special-display-frame-alist::.

   If you use options that specify window appearance when you invoke
Emacs, they take effect by adding elements to `default-frame-alist'.
One exception is `-geometry', which adds the specified position to
`initial-frame-alist' instead.  *Note Command Line Arguments for Emacs
Invocation: (emacs)Emacs Invocation.


File: elisp,  Node: Window Frame Parameters,  Next: Size and Position,  Prev: Initial Parameters,  Up: Frame Parameters

29.3.3 Window Frame Parameters
------------------------------

Just what parameters a frame has depends on what display mechanism it
uses.  This section describes the parameters that have special meanings
on some or all kinds of terminals.  Of these, `name', `title',
`height', `width', `buffer-list' and `buffer-predicate' provide
meaningful information in terminal frames, and `tty-color-mode' is
meaningful _only_ in terminal frames.

* Menu:

* Basic Parameters::            Parameters that are fundamental.
* Position Parameters::         The position of the frame on the screen.
* Size Parameters::             Frame's size.
* Layout Parameters::           Size of parts of the frame, and
                                  enabling or disabling some parts.
* Buffer Parameters::           Which buffers have been or should be shown.
* Management Parameters::       Communicating with the window manager.
* Cursor Parameters::           Controlling the cursor appearance.
* Color Parameters::            Colors of various parts of the frame.


File: elisp,  Node: Basic Parameters,  Next: Position Parameters,  Up: Window Frame Parameters

29.3.3.1 Basic Parameters
.........................

These frame parameters give the most basic information about the frame.
`title' and `name' are meaningful on all terminals.

`display'
     The display on which to open this frame.  It should be a string of
     the form `"HOST:DPY.SCREEN"', just like the `DISPLAY' environment
     variable.

`display-type'
     This parameter describes the range of possible colors that can be
     used in this frame.  Its value is `color', `grayscale' or `mono'.

`title'
     If a frame has a non-`nil' title, it appears in the window
     system's title bar at the top of the frame, and also in the mode
     line of windows in that frame if `mode-line-frame-identification'
     uses `%F' (*note %-Constructs::).  This is normally the case when
     Emacs is not using a window system, and can only display one frame
     at a time.  *Note Frame Titles::.

`name'
     The name of the frame.  The frame name serves as a default for the
     frame title, if the `title' parameter is unspecified or `nil'.  If
     you don't specify a name, Emacs sets the frame name automatically
     (*note Frame Titles::).

     If you specify the frame name explicitly when you create the
     frame, the name is also used (instead of the name of the Emacs
     executable) when looking up X resources for the frame.


File: elisp,  Node: Position Parameters,  Next: Size Parameters,  Prev: Basic Parameters,  Up: Window Frame Parameters

29.3.3.2 Position Parameters
............................

Position parameters' values are normally measured in pixels, but on
text-only terminals they count characters or lines instead.

`left'
     The screen position of the left edge, in pixels, with respect to
     the left edge of the screen.  The value may be a positive number
     POS, or a list of the form `(+ POS)' which permits specifying a
     negative POS value.

     A negative number -POS, or a list of the form `(- POS)', actually
     specifies the position of the right edge of the window with
     respect to the right edge of the screen.  A positive value of POS
     counts toward the left.  *Reminder:* if the parameter is a
     negative integer -POS, then POS is positive.

     Some window managers ignore program-specified positions.  If you
     want to be sure the position you specify is not ignored, specify a
     non-`nil' value for the `user-position' parameter as well.

`top'
     The screen position of the top edge, in pixels, with respect to the
     top edge of the screen.  It works just like `left', except
     vertically instead of horizontally.

`icon-left'
     The screen position of the left edge _of the frame's icon_, in
     pixels, counting from the left edge of the screen.  This takes
     effect if and when the frame is iconified.

     If you specify a value for this parameter, then you must also
     specify a value for `icon-top' and vice versa.  The window manager
     may ignore these two parameters.

`icon-top'
     The screen position of the top edge _of the frame's icon_, in
     pixels, counting from the top edge of the screen.  This takes
     effect if and when the frame is iconified.

`user-position'
     When you create a frame and specify its screen position with the
     `left' and `top' parameters, use this parameter to say whether the
     specified position was user-specified (explicitly requested in some
     way by a human user) or merely program-specified (chosen by a
     program).  A non-`nil' value says the position was user-specified.

     Window managers generally heed user-specified positions, and some
     heed program-specified positions too.  But many ignore
     program-specified positions, placing the window in a default
     fashion or letting the user place it with the mouse.  Some window
     managers, including `twm', let the user specify whether to obey
     program-specified positions or ignore them.

     When you call `make-frame', you should specify a non-`nil' value
     for this parameter if the values of the `left' and `top'
     parameters represent the user's stated preference; otherwise, use
     `nil'.


File: elisp,  Node: Size Parameters,  Next: Layout Parameters,  Prev: Position Parameters,  Up: Window Frame Parameters

29.3.3.3 Size Parameters
........................

Size parameters' values are normally measured in pixels, but on
text-only terminals they count characters or lines instead.

`height'
     The height of the frame contents, in characters.  (To get the
     height in pixels, call `frame-pixel-height'; see *note Size and
     Position::.)

`width'
     The width of the frame contents, in characters.  (To get the width
     in pixels, call `frame-pixel-width'; see *note Size and
     Position::.)

`user-size'
     This does for the size parameters `height' and `width' what the
     `user-position' parameter (see above) does for the position
     parameters `top' and `left'.

`fullscreen'
     Specify that width, height or both shall be set to the size of the
     screen.  The value `fullwidth' specifies that width shall be the
     size of the screen.  The value `fullheight' specifies that height
     shall be the size of the screen.  The value `fullboth' specifies
     that both the width and the height shall be set to the size of the
     screen.


File: elisp,  Node: Layout Parameters,  Next: Buffer Parameters,  Prev: Size Parameters,  Up: Window Frame Parameters

29.3.3.4 Layout Parameters
..........................

These frame parameters enable or disable various parts of the frame, or
control their sizes.

`border-width'
     The width in pixels of the frame's border.

`internal-border-width'
     The distance in pixels between text (or fringe) and the frame's
     border.

`vertical-scroll-bars'
     Whether the frame has scroll bars for vertical scrolling, and
     which side of the frame they should be on.  The possible values
     are `left', `right', and `nil' for no scroll bars.

`scroll-bar-width'
     The width of vertical scroll bars, in pixels, or `nil' meaning to
     use the default width.

`left-fringe'
`right-fringe'
     The default width of the left and right fringes of windows in this
     frame (*note Fringes::).  If either of these is zero, that
     effectively removes the corresponding fringe.  A value of `nil'
     stands for the standard fringe width, which is the width needed to
     display the fringe bitmaps.

     The combined fringe widths must add up to an integral number of
     columns, so the actual default fringe widths for the frame may be
     larger than the specified values.  The extra width needed to reach
     an acceptable total is distributed evenly between the left and
     right fringe.  However, you can force one fringe or the other to a
     precise width by specifying that width as a negative integer.  If
     both widths are negative, only the left fringe gets the specified
     width.

`menu-bar-lines'
     The number of lines to allocate at the top of the frame for a menu
     bar.  The default is 1.  A value of `nil' means don't display a
     menu bar.  *Note Menu Bar::.  (The X toolkit and GTK allow at most
     one menu bar line; they treat larger values as 1.)

`tool-bar-lines'
     The number of lines to use for the tool bar.  A value of `nil'
     means don't display a tool bar.  (GTK allows at most one tool bar
     line; it treats larger values as 1.)

`line-spacing'
     Additional space to leave below each text line, in pixels (a
     positive integer).  *Note Line Height::, for more information.


File: elisp,  Node: Buffer Parameters,  Next: Management Parameters,  Prev: Layout Parameters,  Up: Window Frame Parameters

29.3.3.5 Buffer Parameters
..........................

These frame parameters, meaningful on all kinds of terminals, deal with
which buffers have been, or should, be displayed in the frame.

`minibuffer'
     Whether this frame has its own minibuffer.  The value `t' means
     yes, `nil' means no, `only' means this frame is just a minibuffer.
     If the value is a minibuffer window (in some other frame), the new
     frame uses that minibuffer.

`buffer-predicate'
     The buffer-predicate function for this frame.  The function
     `other-buffer' uses this predicate (from the selected frame) to
     decide which buffers it should consider, if the predicate is not
     `nil'.  It calls the predicate with one argument, a buffer, once
     for each buffer; if the predicate returns a non-`nil' value, it
     considers that buffer.

`buffer-list'
     A list of buffers that have been selected in this frame, ordered
     most-recently-selected first.

`unsplittable'
     If non-`nil', this frame's window is never split automatically.


File: elisp,  Node: Management Parameters,  Next: Cursor Parameters,  Prev: Buffer Parameters,  Up: Window Frame Parameters

29.3.3.6 Window Management Parameters
.....................................

These frame parameters, meaningful only on window system displays,
interact with the window manager.

`visibility'
     The state of visibility of the frame.  There are three
     possibilities: `nil' for invisible, `t' for visible, and `icon' for
     iconified.  *Note Visibility of Frames::.

`auto-raise'
     Whether selecting the frame raises it (non-`nil' means yes).

`auto-lower'
     Whether deselecting the frame lowers it (non-`nil' means yes).

`icon-type'
     The type of icon to use for this frame when it is iconified.  If
     the value is a string, that specifies a file containing a bitmap
     to use.  Any other non-`nil' value specifies the default bitmap
     icon (a picture of a gnu); `nil' specifies a text icon.

`icon-name'
     The name to use in the icon for this frame, when and if the icon
     appears.  If this is `nil', the frame's title is used.

`window-id'
     The number of the window-system window used by the frame to
     contain the actual Emacs windows.

`outer-window-id'
     The number of the outermost window-system window used for the
     whole frame.

`wait-for-wm'
     If non-`nil', tell Xt to wait for the window manager to confirm
     geometry changes.  Some window managers, including versions of
     Fvwm2 and KDE, fail to confirm, so Xt hangs.  Set this to `nil' to
     prevent hanging with those window managers.



File: elisp,  Node: Cursor Parameters,  Next: Color Parameters,  Prev: Management Parameters,  Up: Window Frame Parameters

29.3.3.7 Cursor Parameters
..........................

This frame parameter controls the way the cursor looks.

`cursor-type'
     How to display the cursor.  Legitimate values are:

    `box'
          Display a filled box.  (This is the default.)

    `hollow'
          Display a hollow box.

    `nil'
          Don't display a cursor.

    `bar'
          Display a vertical bar between characters.

    `(bar . WIDTH)'
          Display a vertical bar WIDTH pixels wide between characters.

    `hbar'
          Display a horizontal bar.

    `(hbar . HEIGHT)'
          Display a horizontal bar HEIGHT pixels high.

   The buffer-local variable `cursor-type' overrides the value of the
`cursor-type' frame parameter, but if it is `t', that means to use the
cursor specified for the frame.

 -- Variable: blink-cursor-alist
     This variable specifies how to blink the cursor.  Each element has
     the form `(ON-STATE . OFF-STATE)'.  Whenever the cursor type
     equals ON-STATE (comparing using `equal'), the corresponding
     OFF-STATE specifies what the cursor looks like when it blinks
     "off."  Both ON-STATE and OFF-STATE should be suitable values for
     the `cursor-type' frame parameter.

     There are various defaults for how to blink each type of cursor, if
     the type is not mentioned as an ON-STATE here.  Changes in this
     variable do not take effect immediately, only when you specify the
     `cursor-type' frame parameter.

 -- Variable: cursor-in-non-selected-windows
     This variable controls how the cursor looks in a window that is not
     selected.  It supports the same values as the `cursor-type' frame
     parameter; also, `nil' means don't display a cursor in nonselected
     windows, and `t' (the default) means use a standard modificatoin
     of the usual cursor type (solid box becomes hollow box, and bar
     becomes a narrower bar).


File: elisp,  Node: Color Parameters,  Prev: Cursor Parameters,  Up: Window Frame Parameters

29.3.3.8 Color Parameters
.........................

These frame parameters control the use of colors.

`background-mode'
     This parameter is either `dark' or `light', according to whether
     the background color is a light one or a dark one.

`tty-color-mode'
     This parameter overrides the terminal's color support as given by
     the system's terminal capabilities database in that this
     parameter's value specifies the color mode to use in terminal
     frames.  The value can be either a symbol or a number.  A number
     specifies the number of colors to use (and, indirectly, what
     commands to issue to produce each color).  For example,
     `(tty-color-mode . 8)' specifies use of the ANSI escape sequences
     for 8 standard text colors.  A value of -1 turns off color support.

     If the parameter's value is a symbol, it specifies a number through
     the value of `tty-color-mode-alist', and the associated number is
     used instead.

`screen-gamma'
     If this is a number, Emacs performs "gamma correction" which
     adjusts the brightness of all colors.  The value should be the
     screen gamma of your display, a floating point number.

     Usual PC monitors have a screen gamma of 2.2, so color values in
     Emacs, and in X windows generally, are calibrated to display
     properly on a monitor with that gamma value.  If you specify 2.2
     for `screen-gamma', that means no correction is needed.  Other
     values request correction, designed to make the corrected colors
     appear on your screen the way they would have appeared without
     correction on an ordinary monitor with a gamma value of 2.2.

     If your monitor displays colors too light, you should specify a
     `screen-gamma' value smaller than 2.2.  This requests correction
     that makes colors darker.  A screen gamma value of 1.5 may give
     good results for LCD color displays.

   These frame parameters are semi-obsolete in that they are
automatically equivalent to particular face attributes of particular
faces.  *Note Standard Faces: (emacs)Standard Faces.

`font'
     The name of the font for displaying text in the frame.  This is a
     string, either a valid font name for your system or the name of an
     Emacs fontset (*note Fontsets::).  It is equivalent to the `font'
     attribute of the `default' face.

`foreground-color'
     The color to use for the image of a character.  It is equivalent to
     the `:foreground' attribute of the `default' face.

`background-color'
     The color to use for the background of characters.  It is
     equivalent to the `:background' attribute of the `default' face.

`mouse-color'
     The color for the mouse pointer.  It is equivalent to the
     `:background' attribute of the `mouse' face.

`cursor-color'
     The color for the cursor that shows point.  It is equivalent to the
     `:background' attribute of the `cursor' face.

`border-color'
     The color for the border of the frame.  It is equivalent to the
     `:background' attribute of the `border' face.

`scroll-bar-foreground'
     If non-`nil', the color for the foreground of scroll bars.  It is
     equivalent to the `:foreground' attribute of the `scroll-bar' face.

`scroll-bar-background'
     If non-`nil', the color for the background of scroll bars.  It is
     equivalent to the `:background' attribute of the `scroll-bar' face.


File: elisp,  Node: Size and Position,  Next: Geometry,  Prev: Window Frame Parameters,  Up: Frame Parameters

29.3.4 Frame Size And Position
------------------------------

You can read or change the size and position of a frame using the frame
parameters `left', `top', `height', and `width'.  Whatever geometry
parameters you don't specify are chosen by the window manager in its
usual fashion.

   Here are some special features for working with sizes and positions.
(For the precise meaning of "selected frame" used by these functions,
see *note Input Focus::.)

 -- Function: set-frame-position frame left top
     This function sets the position of the top left corner of FRAME to
     LEFT and TOP.  These arguments are measured in pixels, and
     normally count from the top left corner of the screen.

     Negative parameter values position the bottom edge of the window
     up from the bottom edge of the screen, or the right window edge to
     the left of the right edge of the screen.  It would probably be
     better if the values were always counted from the left and top, so
     that negative arguments would position the frame partly off the
     top or left edge of the screen, but it seems inadvisable to change
     that now.

 -- Function: frame-height &optional frame
 -- Function: frame-width &optional frame
     These functions return the height and width of FRAME, measured in
     lines and columns.  If you don't supply FRAME, they use the
     selected frame.

 -- Function: screen-height
 -- Function: screen-width
     These functions are old aliases for `frame-height' and
     `frame-width'.  When you are using a non-window terminal, the size
     of the frame is normally the same as the size of the terminal
     screen.

 -- Function: frame-pixel-height &optional frame
 -- Function: frame-pixel-width &optional frame
     These functions return the height and width of the main display
     area of FRAME, measured in pixels.  If you don't supply FRAME,
     they use the selected frame.

     These values include the internal borders, and windows' scroll bars
     and fringes (which belong to individual windows, not to the frame
     itself), but do not include menu bars or tool bars (except when
     using X without an X toolkit).

 -- Function: frame-char-height &optional frame
 -- Function: frame-char-width &optional frame
     These functions return the height and width of a character in
     FRAME, measured in pixels.  The values depend on the choice of
     font.  If you don't supply FRAME, these functions use the selected
     frame.

 -- Function: set-frame-size frame cols rows
     This function sets the size of FRAME, measured in characters; COLS
     and ROWS specify the new width and height.

     To set the size based on values measured in pixels, use
     `frame-char-height' and `frame-char-width' to convert them to
     units of characters.

 -- Function: set-frame-height frame lines &optional pretend
     This function resizes FRAME to a height of LINES lines.  The sizes
     of existing windows in FRAME are altered proportionally to fit.

     If PRETEND is non-`nil', then Emacs displays LINES lines of output
     in FRAME, but does not change its value for the actual height of
     the frame.  This is only useful for a terminal frame.  Using a
     smaller height than the terminal actually implements may be useful
     to reproduce behavior observed on a smaller screen, or if the
     terminal malfunctions when using its whole screen.  Setting the
     frame height "for real" does not always work, because knowing the
     correct actual size may be necessary for correct cursor
     positioning on a terminal frame.

 -- Function: set-frame-width frame width &optional pretend
     This function sets the width of FRAME, measured in characters.
     The argument PRETEND has the same meaning as in `set-frame-height'.

   The older functions `set-screen-height' and `set-screen-width' were
used to specify the height and width of the screen, in Emacs versions
that did not support multiple frames.  They are semi-obsolete, but
still work; they apply to the selected frame.


File: elisp,  Node: Geometry,  Prev: Size and Position,  Up: Frame Parameters

29.3.5 Geometry
---------------

Here's how to examine the data in an X-style window geometry
specification:

 -- Function: x-parse-geometry geom
     The function `x-parse-geometry' converts a standard X window
     geometry string to an alist that you can use as part of the
     argument to `make-frame'.

     The alist describes which parameters were specified in GEOM, and
     gives the values specified for them.  Each element looks like
     `(PARAMETER . VALUE)'.  The possible PARAMETER values are `left',
     `top', `width', and `height'.

     For the size parameters, the value must be an integer.  The
     position parameter names `left' and `top' are not totally accurate,
     because some values indicate the position of the right or bottom
     edges instead.  These are the VALUE possibilities for the position
     parameters:

    an integer
          A positive integer relates the left edge or top edge of the
          window to the left or top edge of the screen.  A negative
          integer relates the right or bottom edge of the window to the
          right or bottom edge of the screen.

    `(+ POSITION)'
          This specifies the position of the left or top edge of the
          window relative to the left or top edge of the screen.  The
          integer POSITION may be positive or negative; a negative
          value specifies a position outside the screen.

    `(- POSITION)'
          This specifies the position of the right or bottom edge of
          the window relative to the right or bottom edge of the
          screen.  The integer POSITION may be positive or negative; a
          negative value specifies a position outside the screen.

     Here is an example:

          (x-parse-geometry "35x70+0-0")
               => ((height . 70) (width . 35)
                   (top - 0) (left . 0))


File: elisp,  Node: Frame Titles,  Next: Deleting Frames,  Prev: Frame Parameters,  Up: Frames

29.4 Frame Titles
=================

Every frame has a `name' parameter; this serves as the default for the
frame title which window systems typically display at the top of the
frame.  You can specify a name explicitly by setting the `name' frame
property.

   Normally you don't specify the name explicitly, and Emacs computes
the frame name automatically based on a template stored in the variable
`frame-title-format'.  Emacs recomputes the name each time the frame is
redisplayed.

 -- Variable: frame-title-format
     This variable specifies how to compute a name for a frame when you
     have not explicitly specified one.  The variable's value is
     actually a mode line construct, just like `mode-line-format',
     except that the `%c' and `%l' constructs are ignored.  *Note Mode
     Line Data::.

 -- Variable: icon-title-format
     This variable specifies how to compute the name for an iconified
     frame, when you have not explicitly specified the frame title.
     This title appears in the icon itself.

 -- Variable: multiple-frames
     This variable is set automatically by Emacs.  Its value is `t' when
     there are two or more frames (not counting minibuffer-only frames
     or invisible frames).  The default value of `frame-title-format'
     uses `multiple-frames' so as to put the buffer name in the frame
     title only when there is more than one frame.

     The value of this variable is not guaranteed to be accurate except
     while processing `frame-title-format' or `icon-title-format'.


File: elisp,  Node: Deleting Frames,  Next: Finding All Frames,  Prev: Frame Titles,  Up: Frames

29.5 Deleting Frames
====================

Frames remain potentially visible until you explicitly "delete" them.
A deleted frame cannot appear on the screen, but continues to exist as
a Lisp object until there are no references to it.

 -- Command: delete-frame &optional frame force
     This function deletes the frame FRAME.  Unless FRAME is a tooltip,
     it first runs the hook `delete-frame-functions' (each function
     gets one argument, FRAME).  By default, FRAME is the selected
     frame.

     A frame cannot be deleted if its minibuffer is used by other
     frames.  Normally, you cannot delete a frame if all other frames
     are invisible, but if the FORCE is non-`nil', then you are allowed
     to do so.

 -- Function: frame-live-p frame
     The function `frame-live-p' returns non-`nil' if the frame FRAME
     has not been deleted.  The possible non-`nil' return values are
     like those of `framep'.  *Note Frames::.

   Some window managers provide a command to delete a window.  These
work by sending a special message to the program that operates the
window.  When Emacs gets one of these commands, it generates a
`delete-frame' event, whose normal definition is a command that calls
the function `delete-frame'.  *Note Misc Events::.


File: elisp,  Node: Finding All Frames,  Next: Frames and Windows,  Prev: Deleting Frames,  Up: Frames

29.6 Finding All Frames
=======================

 -- Function: frame-list
     The function `frame-list' returns a list of all the frames that
     have not been deleted.  It is analogous to `buffer-list' for
     buffers, and includes frames on all terminals.  The list that you
     get is newly created, so modifying the list doesn't have any
     effect on the internals of Emacs.

 -- Function: visible-frame-list
     This function returns a list of just the currently visible frames.
     *Note Visibility of Frames::.  (Terminal frames always count as
     "visible," even though only the selected one is actually
     displayed.)

 -- Function: next-frame &optional frame minibuf
     The function `next-frame' lets you cycle conveniently through all
     the frames on the current display from an arbitrary starting
     point.  It returns the "next" frame after FRAME in the cycle.  If
     FRAME is omitted or `nil', it defaults to the selected frame
     (*note Input Focus::).

     The second argument, MINIBUF, says which frames to consider:

    `nil'
          Exclude minibuffer-only frames.

    `visible'
          Consider all visible frames.

    0
          Consider all visible or iconified frames.

    a window
          Consider only the frames using that particular window as their
          minibuffer.

    anything else
          Consider all frames.

 -- Function: previous-frame &optional frame minibuf
     Like `next-frame', but cycles through all frames in the opposite
     direction.

   See also `next-window' and `previous-window', in *note Cyclic Window
Ordering::.


File: elisp,  Node: Frames and Windows,  Next: Minibuffers and Frames,  Prev: Finding All Frames,  Up: Frames

29.7 Frames and Windows
=======================

Each window is part of one and only one frame; you can get the frame
with `window-frame'.

 -- Function: window-frame window
     This function returns the frame that WINDOW is on.

   All the non-minibuffer windows in a frame are arranged in a cyclic
order.  The order runs from the frame's top window, which is at the
upper left corner, down and to the right, until it reaches the window at
the lower right corner (always the minibuffer window, if the frame has
one), and then it moves back to the top.  *Note Cyclic Window
Ordering::.

 -- Function: frame-first-window &optional frame
     This returns the topmost, leftmost window of frame FRAME.  If
     omitted or `nil', FRAME defaults to the selected frame.

   At any time, exactly one window on any frame is "selected within the
frame".  The significance of this designation is that selecting the
frame also selects this window.  You can get the frame's current
selected window with `frame-selected-window'.

 -- Function: frame-selected-window &optional frame
     This function returns the window on FRAME that is selected within
     FRAME.  If omitted or `nil', FRAME defaults to the selected frame.

 -- Function: set-frame-selected-window frame window
     This sets the selected window of frame FRAME to WINDOW.  If FRAME
     is `nil', it operates on the selected frame.  If FRAME is the
     selected frame, this makes WINDOW the selected window.  This
     function returns WINDOW.

   Conversely, selecting a window for Emacs with `select-window' also
makes that window selected within its frame.  *Note Selecting Windows::.

   Another function that (usually) returns one of the windows in a given
frame is `minibuffer-window'.  *Note Definition of minibuffer-window::.


File: elisp,  Node: Minibuffers and Frames,  Next: Input Focus,  Prev: Frames and Windows,  Up: Frames

29.8 Minibuffers and Frames
===========================

Normally, each frame has its own minibuffer window at the bottom, which
is used whenever that frame is selected.  If the frame has a minibuffer,
you can get it with `minibuffer-window' (*note Definition of
minibuffer-window::).

   However, you can also create a frame with no minibuffer.  Such a
frame must use the minibuffer window of some other frame.  When you
create the frame, you can specify explicitly the minibuffer window to
use (in some other frame).  If you don't, then the minibuffer is found
in the frame which is the value of the variable
`default-minibuffer-frame'.  Its value should be a frame that does have
a minibuffer.

   If you use a minibuffer-only frame, you might want that frame to
raise when you enter the minibuffer.  If so, set the variable
`minibuffer-auto-raise' to `t'.  *Note Raising and Lowering::.

 -- Variable: default-minibuffer-frame
     This variable specifies the frame to use for the minibuffer
     window, by default.  It does not affect existing frames.  It is
     always local to the current terminal and cannot be buffer-local.
     *Note Multiple Displays::.


File: elisp,  Node: Input Focus,  Next: Visibility of Frames,  Prev: Minibuffers and Frames,  Up: Frames

29.9 Input Focus
================

At any time, one frame in Emacs is the "selected frame".  The selected
window always resides on the selected frame.

   When Emacs displays its frames on several terminals (*note Multiple
Displays::), each terminal has its own selected frame.  But only one of
these is "_the_ selected frame": it's the frame that belongs to the
terminal from which the most recent input came.  That is, when Emacs
runs a command that came from a certain terminal, the selected frame is
the one of that terminal.  Since Emacs runs only a single command at any
given time, it needs to consider only one selected frame at a time; this
frame is what we call "the selected frame" in this manual.  The display
on which the selected frame is displayed is the "selected frame's
display".

 -- Function: selected-frame
     This function returns the selected frame.

   Some window systems and window managers direct keyboard input to the
window object that the mouse is in; others require explicit clicks or
commands to "shift the focus" to various window objects.  Either way,
Emacs automatically keeps track of which frame has the focus.  To
switch to a different frame from a Lisp function, call
`select-frame-set-input-focus'.

   Lisp programs can also switch frames "temporarily" by calling the
function `select-frame'.  This does not alter the window system's
concept of focus; rather, it escapes from the window manager's control
until that control is somehow reasserted.

   When using a text-only terminal, only one frame can be displayed at a
time on the terminal, so after a call to `select-frame', the next
redisplay actually displays the newly selected frame.  This frame
remains selected until a subsequent call to `select-frame' or
`select-frame-set-input-focus'.  Each terminal frame has a number which
appears in the mode line before the buffer name (*note Mode Line
Variables::).

 -- Function: select-frame-set-input-focus frame
     This function makes FRAME the selected frame, raises it (should it
     happen to be obscured by other frames) and tries to give it the X
     server's focus.  On a text-only terminal, the next redisplay
     displays the new frame on the entire terminal screen.  The return
     value of this function is not significant.

 -- Function: select-frame frame
     This function selects frame FRAME, temporarily disregarding the
     focus of the X server if any.  The selection of FRAME lasts until
     the next time the user does something to select a different frame,
     or until the next time this function is called.  (If you are using
     a window system, the previously selected frame may be restored as
     the selected frame after return to the command loop, because it
     still may have the window system's input focus.)  The specified
     FRAME becomes the selected frame, as explained above, and the
     terminal that FRAME is on becomes the selected terminal.  This
     function returns FRAME, or `nil' if FRAME has been deleted.

     In general, you should never use `select-frame' in a way that could
     switch to a different terminal without switching back when you're
     done.

   Emacs cooperates with the window system by arranging to select
frames as the server and window manager request.  It does so by
generating a special kind of input event, called a "focus" event, when
appropriate.  The command loop handles a focus event by calling
`handle-switch-frame'.  *Note Focus Events::.

 -- Command: handle-switch-frame frame
     This function handles a focus event by selecting frame FRAME.

     Focus events normally do their job by invoking this command.
     Don't call it for any other reason.

 -- Function: redirect-frame-focus frame &optional focus-frame
     This function redirects focus from FRAME to FOCUS-FRAME.  This
     means that FOCUS-FRAME will receive subsequent keystrokes and
     events intended for FRAME.  After such an event, the value of
     `last-event-frame' will be FOCUS-FRAME.  Also, switch-frame events
     specifying FRAME will instead select FOCUS-FRAME.

     If FOCUS-FRAME is omitted or `nil', that cancels any existing
     redirection for FRAME, which therefore once again receives its own
     events.

     One use of focus redirection is for frames that don't have
     minibuffers.  These frames use minibuffers on other frames.
     Activating a minibuffer on another frame redirects focus to that
     frame.  This puts the focus on the minibuffer's frame, where it
     belongs, even though the mouse remains in the frame that activated
     the minibuffer.

     Selecting a frame can also change focus redirections.  Selecting
     frame `bar', when `foo' had been selected, changes any redirections
     pointing to `foo' so that they point to `bar' instead.  This
     allows focus redirection to work properly when the user switches
     from one frame to another using `select-window'.

     This means that a frame whose focus is redirected to itself is
     treated differently from a frame whose focus is not redirected.
     `select-frame' affects the former but not the latter.

     The redirection lasts until `redirect-frame-focus' is called to
     change it.

 -- User Option: focus-follows-mouse
     This option is how you inform Emacs whether the window manager
     transfers focus when the user moves the mouse.  Non-`nil' says
     that it does.  When this is so, the command `other-frame' moves
     the mouse to a position consistent with the new selected frame.
     (This option has no effect on MS-Windows, where the mouse pointer
     is always automatically moved by the OS to the selected frame.)


File: elisp,  Node: Visibility of Frames,  Next: Raising and Lowering,  Prev: Input Focus,  Up: Frames

29.10 Visibility of Frames
==========================

A window frame may be "visible", "invisible", or "iconified".  If it is
visible, you can see its contents, unless other windows cover it.  If
it is iconified, the frame's contents do not appear on the screen, but
an icon does.  If the frame is invisible, it doesn't show on the
screen, not even as an icon.

   Visibility is meaningless for terminal frames, since only the
selected one is actually displayed in any case.

 -- Command: make-frame-visible &optional frame
     This function makes frame FRAME visible.  If you omit FRAME, it
     makes the selected frame visible.  This does not raise the frame,
     but you can do that with `raise-frame' if you wish (*note Raising
     and Lowering::).

 -- Command: make-frame-invisible &optional frame force
     This function makes frame FRAME invisible.  If you omit FRAME, it
     makes the selected frame invisible.

     Unless FORCE is non-`nil', this function refuses to make FRAME
     invisible if all other frames are invisible..

 -- Command: iconify-frame &optional frame
     This function iconifies frame FRAME.  If you omit FRAME, it
     iconifies the selected frame.

 -- Function: frame-visible-p frame
     This returns the visibility status of frame FRAME.  The value is
     `t' if FRAME is visible, `nil' if it is invisible, and `icon' if
     it is iconified.

     On a text-only terminal, all frames are considered visible, whether
     they are currently being displayed or not, and this function
     returns `t' for all frames.

   The visibility status of a frame is also available as a frame
parameter.  You can read or change it as such.  *Note Management
Parameters::.

   The user can iconify and deiconify frames with the window manager.
This happens below the level at which Emacs can exert any control, but
Emacs does provide events that you can use to keep track of such
changes.  *Note Misc Events::.


File: elisp,  Node: Raising and Lowering,  Next: Frame Configurations,  Prev: Visibility of Frames,  Up: Frames

29.11 Raising and Lowering Frames
=================================

Most window systems use a desktop metaphor.  Part of this metaphor is
the idea that windows are stacked in a notional third dimension
perpendicular to the screen surface, and thus ordered from "highest" to
"lowest."  Where two windows overlap, the one higher up covers the one
underneath.  Even a window at the bottom of the stack can be seen if no
other window overlaps it.

   A window's place in this ordering is not fixed; in fact, users tend
to change the order frequently.  "Raising" a window means moving it
"up," to the top of the stack.  "Lowering" a window means moving it to
the bottom of the stack.  This motion is in the notional third
dimension only, and does not change the position of the window on the
screen.

   You can raise and lower Emacs frame Windows with these functions:

 -- Command: raise-frame &optional frame
     This function raises frame FRAME (default, the selected frame).
     If FRAME is invisible or iconified, this makes it visible.

 -- Command: lower-frame &optional frame
     This function lowers frame FRAME (default, the selected frame).

 -- User Option: minibuffer-auto-raise
     If this is non-`nil', activation of the minibuffer raises the frame
     that the minibuffer window is in.

   You can also enable auto-raise (raising automatically when a frame is
selected) or auto-lower (lowering automatically when it is deselected)
for any frame using frame parameters.  *Note Management Parameters::.


File: elisp,  Node: Frame Configurations,  Next: Mouse Tracking,  Prev: Raising and Lowering,  Up: Frames

29.12 Frame Configurations
==========================

A "frame configuration" records the current arrangement of frames, all
their properties, and the window configuration of each one.  (*Note
Window Configurations::.)

 -- Function: current-frame-configuration
     This function returns a frame configuration list that describes
     the current arrangement of frames and their contents.

 -- Function: set-frame-configuration configuration &optional nodelete
     This function restores the state of frames described in
     CONFIGURATION.  However, this function does not restore deleted
     frames.

     Ordinarily, this function deletes all existing frames not listed in
     CONFIGURATION.  But if NODELETE is non-`nil', the unwanted frames
     are iconified instead.


File: elisp,  Node: Mouse Tracking,  Next: Mouse Position,  Prev: Frame Configurations,  Up: Frames

29.13 Mouse Tracking
====================

Sometimes it is useful to "track" the mouse, which means to display
something to indicate where the mouse is and move the indicator as the
mouse moves.  For efficient mouse tracking, you need a way to wait until
the mouse actually moves.

   The convenient way to track the mouse is to ask for events to
represent mouse motion.  Then you can wait for motion by waiting for an
event.  In addition, you can easily handle any other sorts of events
that may occur.  That is useful, because normally you don't want to
track the mouse forever--only until some other event, such as the
release of a button.

 -- Special Form: track-mouse body...
     This special form executes BODY, with generation of mouse motion
     events enabled.  Typically BODY would use `read-event' to read the
     motion events and modify the display accordingly.  *Note Motion
     Events::, for the format of mouse motion events.

     The value of `track-mouse' is that of the last form in BODY.  You
     should design BODY to return when it sees the up-event that
     indicates the release of the button, or whatever kind of event
     means it is time to stop tracking.

   The usual purpose of tracking mouse motion is to indicate on the
screen the consequences of pushing or releasing a button at the current
position.

   In many cases, you can avoid the need to track the mouse by using
the `mouse-face' text property (*note Special Properties::).  That
works at a much lower level and runs more smoothly than Lisp-level
mouse tracking.


File: elisp,  Node: Mouse Position,  Next: Pop-Up Menus,  Prev: Mouse Tracking,  Up: Frames

29.14 Mouse Position
====================

The functions `mouse-position' and `set-mouse-position' give access to
the current position of the mouse.

 -- Function: mouse-position
     This function returns a description of the position of the mouse.
     The value looks like `(FRAME X . Y)', where X and Y are integers
     giving the position in characters relative to the top left corner
     of the inside of FRAME.

 -- Variable: mouse-position-function
     If non-`nil', the value of this variable is a function for
     `mouse-position' to call.  `mouse-position' calls this function
     just before returning, with its normal return value as the sole
     argument, and it returns whatever this function returns to it.

     This abnormal hook exists for the benefit of packages like
     `xt-mouse.el' that need to do mouse handling at the Lisp level.

 -- Function: set-mouse-position frame x y
     This function "warps the mouse" to position X, Y in frame FRAME.
     The arguments X and Y are integers, giving the position in
     characters relative to the top left corner of the inside of FRAME.
     If FRAME is not visible, this function does nothing.  The return
     value is not significant.

 -- Function: mouse-pixel-position
     This function is like `mouse-position' except that it returns
     coordinates in units of pixels rather than units of characters.

 -- Function: set-mouse-pixel-position frame x y
     This function warps the mouse like `set-mouse-position' except that
     X and Y are in units of pixels rather than units of characters.
     These coordinates are not required to be within the frame.

     If FRAME is not visible, this function does nothing.  The return
     value is not significant.


File: elisp,  Node: Pop-Up Menus,  Next: Dialog Boxes,  Prev: Mouse Position,  Up: Frames

29.15 Pop-Up Menus
==================

When using a window system, a Lisp program can pop up a menu so that
the user can choose an alternative with the mouse.

 -- Function: x-popup-menu position menu
     This function displays a pop-up menu and returns an indication of
     what selection the user makes.

     The argument POSITION specifies where on the screen to put the top
     left corner of the menu.  It can be either a mouse button event
     (which says to put the menu where the user actuated the button) or
     a list of this form:

          ((XOFFSET YOFFSET) WINDOW)

     where XOFFSET and YOFFSET are coordinates, measured in pixels,
     counting from the top left corner of WINDOW.  WINDOW may be a
     window or a frame.

     If POSITION is `t', it means to use the current mouse position.
     If POSITION is `nil', it means to precompute the key binding
     equivalents for the keymaps specified in MENU, without actually
     displaying or popping up the menu.

     The argument MENU says what to display in the menu.  It can be a
     keymap or a list of keymaps (*note Menu Keymaps::).  In this case,
     the return value is the list of events corresponding to the user's
     choice.  (This list has more than one element if the choice
     occurred in a submenu.)  Note that `x-popup-menu' does not
     actually execute the command bound to that sequence of events.

     Alternatively, MENU can have the following form:

          (TITLE PANE1 PANE2...)

     where each pane is a list of form

          (TITLE ITEM1 ITEM2...)

     Each item should normally be a cons cell `(LINE . VALUE)', where
     LINE is a string, and VALUE is the value to return if that LINE is
     chosen.  An item can also be a string; this makes a non-selectable
     line in the menu.

     If the user gets rid of the menu without making a valid choice, for
     instance by clicking the mouse away from a valid choice or by
     typing keyboard input, then this normally results in a quit and
     `x-popup-menu' does not return.  But if POSITION is a mouse button
     event (indicating that the user invoked the menu with the mouse)
     then no quit occurs and `x-popup-menu' returns `nil'.

   *Usage note:* Don't use `x-popup-menu' to display a menu if you
could do the job with a prefix key defined with a menu keymap.  If you
use a menu keymap to implement a menu, `C-h c' and `C-h a' can see the
individual items in that menu and provide help for them.  If instead
you implement the menu by defining a command that calls `x-popup-menu',
the help facilities cannot know what happens inside that command, so
they cannot give any help for the menu's items.

   The menu bar mechanism, which lets you switch between submenus by
moving the mouse, cannot look within the definition of a command to see
that it calls `x-popup-menu'.  Therefore, if you try to implement a
submenu using `x-popup-menu', it cannot work with the menu bar in an
integrated fashion.  This is why all menu bar submenus are implemented
with menu keymaps within the parent menu, and never with
`x-popup-menu'.  *Note Menu Bar::.

   If you want a menu bar submenu to have contents that vary, you should
still use a menu keymap to implement it.  To make the contents vary, add
a hook function to `menu-bar-update-hook' to update the contents of the
menu keymap as necessary.


File: elisp,  Node: Dialog Boxes,  Next: Pointer Shape,  Prev: Pop-Up Menus,  Up: Frames

29.16 Dialog Boxes
==================

A dialog box is a variant of a pop-up menu--it looks a little
different, it always appears in the center of a frame, and it has just
one level and one or more buttons.  The main use of dialog boxes is for
asking questions that the user can answer with "yes," "no," and a few
other alternatives.  With a single button, they can also force the user
to acknowledge important information.  The functions `y-or-n-p' and
`yes-or-no-p' use dialog boxes instead of the keyboard, when called
from commands invoked by mouse clicks.

 -- Function: x-popup-dialog position contents &optional header
     This function displays a pop-up dialog box and returns an
     indication of what selection the user makes.  The argument
     CONTENTS specifies the alternatives to offer; it has this format:

          (TITLE (STRING . VALUE)...)

     which looks like the list that specifies a single pane for
     `x-popup-menu'.

     The return value is VALUE from the chosen alternative.

     As for `x-popup-menu', an element of the list may be just a string
     instead of a cons cell `(STRING . VALUE)'.  That makes a box that
     cannot be selected.

     If `nil' appears in the list, it separates the left-hand items from
     the right-hand items; items that precede the `nil' appear on the
     left, and items that follow the `nil' appear on the right.  If you
     don't include a `nil' in the list, then approximately half the
     items appear on each side.

     Dialog boxes always appear in the center of a frame; the argument
     POSITION specifies which frame.  The possible values are as in
     `x-popup-menu', but the precise coordinates or the individual
     window don't matter; only the frame matters.

     If HEADER is non-`nil', the frame title for the box is
     `Information', otherwise it is `Question'.  The former is used for
     `message-box' (*note message-box::).

     In some configurations, Emacs cannot display a real dialog box; so
     instead it displays the same items in a pop-up menu in the center
     of the frame.

     If the user gets rid of the dialog box without making a valid
     choice, for instance using the window manager, then this produces
     a quit and `x-popup-dialog' does not return.


File: elisp,  Node: Pointer Shape,  Next: Window System Selections,  Prev: Dialog Boxes,  Up: Frames

29.17 Pointer Shape
===================

You can specify the mouse pointer style for particular text or images
using the `pointer' text property, and for images with the `:pointer'
and `:map' image properties.  The values you can use in these
properties are `text' (or `nil'), `arrow', `hand', `vdrag', `hdrag',
`modeline', and `hourglass'.  `text' stands for the usual mouse pointer
style used over text.

   Over void parts of the window (parts that do not correspond to any
of the buffer contents), the mouse pointer usually uses the `arrow'
style, but you can specify a different style (one of those above) by
setting `void-text-area-pointer'.

 -- Variable: void-text-area-pointer
     This variable specifies the mouse pointer style for void text
     areas.  These include the areas after the end of a line or below
     the last line in the buffer.  The default is to use the `arrow'
     (non-text) pointer style.

   You can specify what the `text' pointer style really looks like by
setting the variable `x-pointer-shape'.

 -- Variable: x-pointer-shape
     This variable specifies the pointer shape to use ordinarily in the
     Emacs frame, for the `text' pointer style.

 -- Variable: x-sensitive-text-pointer-shape
     This variable specifies the pointer shape to use when the mouse is
     over mouse-sensitive text.

   These variables affect newly created frames.  They do not normally
affect existing frames; however, if you set the mouse color of a frame,
that also installs the current value of those two variables.  *Note
Color Parameters::.

   The values you can use, to specify either of these pointer shapes,
are defined in the file `lisp/term/x-win.el'.  Use `M-x apropos <RET>
x-pointer <RET>' to see a list of them.


File: elisp,  Node: Window System Selections,  Next: Drag and Drop,  Prev: Pointer Shape,  Up: Frames

29.18 Window System Selections
==============================

The X server records a set of "selections" which permit transfer of
data between application programs.  The various selections are
distinguished by "selection types", represented in Emacs by symbols.  X
clients including Emacs can read or set the selection for any given
type.

 -- Command: x-set-selection type data
     This function sets a "selection" in the X server.  It takes two
     arguments: a selection type TYPE, and the value to assign to it,
     DATA.  If DATA is `nil', it means to clear out the selection.
     Otherwise, DATA may be a string, a symbol, an integer (or a cons
     of two integers or list of two integers), an overlay, or a cons of
     two markers pointing to the same buffer.  An overlay or a pair of
     markers stands for text in the overlay or between the markers.

     The argument DATA may also be a vector of valid non-vector
     selection values.

     Each possible TYPE has its own selection value, which changes
     independently.  The usual values of TYPE are `PRIMARY',
     `SECONDARY' and `CLIPBOARD'; these are symbols with upper-case
     names, in accord with X Window System conventions.  If TYPE is
     `nil', that stands for `PRIMARY'.

     This function returns DATA.

 -- Function: x-get-selection &optional type data-type
     This function accesses selections set up by Emacs or by other X
     clients.  It takes two optional arguments, TYPE and DATA-TYPE.
     The default for TYPE, the selection type, is `PRIMARY'.

     The DATA-TYPE argument specifies the form of data conversion to
     use, to convert the raw data obtained from another X client into
     Lisp data.  Meaningful values include `TEXT', `STRING',
     `UTF8_STRING', `TARGETS', `LENGTH', `DELETE', `FILE_NAME',
     `CHARACTER_POSITION', `NAME', `LINE_NUMBER', `COLUMN_NUMBER',
     `OWNER_OS', `HOST_NAME', `USER', `CLASS', `ATOM', and `INTEGER'.
     (These are symbols with upper-case names in accord with X
     conventions.)  The default for DATA-TYPE is `STRING'.

   The X server also has a set of eight numbered "cut buffers" which can
store text or other data being moved between applications.  Cut buffers
are considered obsolete, but Emacs supports them for the sake of X
clients that still use them.  Cut buffers are numbered from 0 to 7.

 -- Function: x-get-cut-buffer &optional n
     This function returns the contents of cut buffer number N.  If
     omitted N defaults to 0.

 -- Function: x-set-cut-buffer string &optional push
     This function stores STRING into the first cut buffer (cut buffer
     0).  If PUSH is `nil', only the first cut buffer is changed.  If
     PUSH is non-`nil', that says to move the values down through the
     series of cut buffers, much like the way successive kills in Emacs
     move down the kill ring.  In other words, the previous value of
     the first cut buffer moves into the second cut buffer, and the
     second to the third, and so on through all eight cut buffers.

 -- Variable: selection-coding-system
     This variable specifies the coding system to use when reading and
     writing selections or the clipboard.  *Note Coding Systems::.  The
     default is `compound-text-with-extensions', which converts to the
     text representation that X11 normally uses.

   When Emacs runs on MS-Windows, it does not implement X selections in
general, but it does support the clipboard.  `x-get-selection' and
`x-set-selection' on MS-Windows support the text data type only; if the
clipboard holds other types of data, Emacs treats the clipboard as
empty.

   On Mac OS, selection-like data transfer between applications is
performed through a mechanism called "scraps".  The clipboard is a
particular scrap named `com.apple.scrap.clipboard'.  Types of scrap
data are called "scrap flavor types", which are identified by four-char
codes such as `TEXT'.  Emacs associates a selection with a scrap, and a
selection type with a scrap flavor type via `mac-scrap-name' and
`mac-ostype' properties, respectively.

     (get 'CLIPBOARD 'mac-scrap-name)
          => "com.apple.scrap.clipboard"
     (get 'com.apple.traditional-mac-plain-text 'mac-ostype)
          => "TEXT"

   Conventionally, selection types for scrap flavor types on Mac OS have
the form of UTI (Uniform Type Identifier) such as
`com.apple.traditional-mac-plain-text', `public.utf16-plain-text', and
`public.file-url'.

 -- User Option: x-select-enable-clipboard
     If this is non-`nil', the Emacs yank functions consult the
     clipboard before the primary selection, and the kill functions
     store in the clipboard as well as the primary selection.
     Otherwise they do not access the clipboard at all.  The default is
     `nil' on most systems, but `t' on MS-Windows and Mac.


File: elisp,  Node: Drag and Drop,  Next: Color Names,  Prev: Window System Selections,  Up: Frames

29.19 Drag and Drop
===================

When a user drags something from another application over Emacs, that
other application expects Emacs to tell it if Emacs can handle the data
that is dragged.  The variable `x-dnd-test-function' is used by Emacs
to determine what to reply.  The default value is
`x-dnd-default-test-function' which accepts drops if the type of the
data to be dropped is present in `x-dnd-known-types'.  You can
customize `x-dnd-test-function' and/or `x-dnd-known-types' if you want
Emacs to accept or reject drops based on some other criteria.

   If you want to change the way Emacs handles drop of different types
or add a new type, customize `x-dnd-types-alist'.  This requires
detailed knowledge of what types other applications use for drag and
drop.

   When an URL is dropped on Emacs it may be a file, but it may also be
another URL type (ftp, http, etc.).  Emacs first checks
`dnd-protocol-alist' to determine what to do with the URL.  If there is
no match there and if `browse-url-browser-function' is an alist, Emacs
looks for a match there.  If no match is found the text for the URL is
inserted.  If you want to alter Emacs behavior, you can customize these
variables.


File: elisp,  Node: Color Names,  Next: Text Terminal Colors,  Prev: Drag and Drop,  Up: Frames

29.20 Color Names
=================

A color name is text (usually in a string) that specifies a color.
Symbolic names such as `black', `white', `red', etc., are allowed; use
`M-x list-colors-display' to see a list of defined names.  You can also
specify colors numerically in forms such as `#RGB' and `RGB:R/G/B',
where R specifies the red level, G specifies the green level, and B
specifies the blue level.  You can use either one, two, three, or four
hex digits for R; then you must use the same number of hex digits for
all G and B as well, making either 3, 6, 9 or 12 hex digits in all.
(See the documentation of the X Window System for more details about
numerical RGB specification of colors.)

   These functions provide a way to determine which color names are
valid, and what they look like.  In some cases, the value depends on the
"selected frame", as described below; see *note Input Focus::, for the
meaning of the term "selected frame."

 -- Function: color-defined-p color &optional frame
     This function reports whether a color name is meaningful.  It
     returns `t' if so; otherwise, `nil'.  The argument FRAME says
     which frame's display to ask about; if FRAME is omitted or `nil',
     the selected frame is used.

     Note that this does not tell you whether the display you are using
     really supports that color.  When using X, you can ask for any
     defined color on any kind of display, and you will get some
     result--typically, the closest it can do.  To determine whether a
     frame can really display a certain color, use `color-supported-p'
     (see below).

     This function used to be called `x-color-defined-p', and that name
     is still supported as an alias.

 -- Function: defined-colors &optional frame
     This function returns a list of the color names that are defined
     and supported on frame FRAME (default, the selected frame).  If
     FRAME does not support colors, the value is `nil'.

     This function used to be called `x-defined-colors', and that name
     is still supported as an alias.

 -- Function: color-supported-p color &optional frame background-p
     This returns `t' if FRAME can really display the color COLOR (or
     at least something close to it).  If FRAME is omitted or `nil',
     the question applies to the selected frame.

     Some terminals support a different set of colors for foreground and
     background.  If BACKGROUND-P is non-`nil', that means you are
     asking whether COLOR can be used as a background; otherwise you
     are asking whether it can be used as a foreground.

     The argument COLOR must be a valid color name.

 -- Function: color-gray-p color &optional frame
     This returns `t' if COLOR is a shade of gray, as defined on
     FRAME's display.  If FRAME is omitted or `nil', the question
     applies to the selected frame.  If COLOR is not a valid color
     name, this function returns `nil'.

 -- Function: color-values color &optional frame
     This function returns a value that describes what COLOR should
     ideally look like on FRAME.  If COLOR is defined, the value is a
     list of three integers, which give the amount of red, the amount
     of green, and the amount of blue.  Each integer ranges in
     principle from 0 to 65535, but some displays may not use the full
     range.  This three-element list is called the "rgb values" of the
     color.

     If COLOR is not defined, the value is `nil'.

          (color-values "black")
               => (0 0 0)
          (color-values "white")
               => (65280 65280 65280)
          (color-values "red")
               => (65280 0 0)
          (color-values "pink")
               => (65280 49152 51968)
          (color-values "hungry")
               => nil

     The color values are returned for FRAME's display.  If FRAME is
     omitted or `nil', the information is returned for the selected
     frame's display.  If the frame cannot display colors, the value is
     `nil'.

     This function used to be called `x-color-values', and that name is
     still supported as an alias.


File: elisp,  Node: Text Terminal Colors,  Next: Resources,  Prev: Color Names,  Up: Frames

29.21 Text Terminal Colors
==========================

Text-only terminals usually support only a small number of colors, and
the computer uses small integers to select colors on the terminal.
This means that the computer cannot reliably tell what the selected
color looks like; instead, you have to inform your application which
small integers correspond to which colors.  However, Emacs does know
the standard set of colors and will try to use them automatically.

   The functions described in this section control how terminal colors
are used by Emacs.

   Several of these functions use or return "rgb values", described in
*note Color Names::.

   These functions accept a display (either a frame or the name of a
terminal) as an optional argument.  We hope in the future to make Emacs
support more than one text-only terminal at one time; then this argument
will specify which terminal to operate on (the default being the
selected frame's terminal; *note Input Focus::).  At present, though,
the FRAME argument has no effect.

 -- Function: tty-color-define name number &optional rgb frame
     This function associates the color name NAME with color number
     NUMBER on the terminal.

     The optional argument RGB, if specified, is an rgb value, a list
     of three numbers that specify what the color actually looks like.
     If you do not specify RGB, then this color cannot be used by
     `tty-color-approximate' to approximate other colors, because Emacs
     will not know what it looks like.

 -- Function: tty-color-clear &optional frame
     This function clears the table of defined colors for a text-only
     terminal.

 -- Function: tty-color-alist &optional frame
     This function returns an alist recording the known colors
     supported by a text-only terminal.

     Each element has the form `(NAME NUMBER . RGB)' or `(NAME
     NUMBER)'.  Here, NAME is the color name, NUMBER is the number used
     to specify it to the terminal.  If present, RGB is a list of three
     color values (for red, green, and blue) that says what the color
     actually looks like.

 -- Function: tty-color-approximate rgb &optional frame
     This function finds the closest color, among the known colors
     supported for DISPLAY, to that described by the rgb value RGB (a
     list of color values).  The return value is an element of
     `tty-color-alist'.

 -- Function: tty-color-translate color &optional frame
     This function finds the closest color to COLOR among the known
     colors supported for DISPLAY and returns its index (an integer).
     If the name COLOR is not defined, the value is `nil'.


File: elisp,  Node: Resources,  Next: Display Feature Testing,  Prev: Text Terminal Colors,  Up: Frames

29.22 X Resources
=================

 -- Function: x-get-resource attribute class &optional component
          subclass
     The function `x-get-resource' retrieves a resource value from the X
     Window defaults database.

     Resources are indexed by a combination of a "key" and a "class".
     This function searches using a key of the form
     `INSTANCE.ATTRIBUTE' (where INSTANCE is the name under which Emacs
     was invoked), and using `Emacs.CLASS' as the class.

     The optional arguments COMPONENT and SUBCLASS add to the key and
     the class, respectively.  You must specify both of them or neither.
     If you specify them, the key is `INSTANCE.COMPONENT.ATTRIBUTE',
     and the class is `Emacs.CLASS.SUBCLASS'.

 -- Variable: x-resource-class
     This variable specifies the application name that `x-get-resource'
     should look up.  The default value is `"Emacs"'.  You can examine X
     resources for application names other than "Emacs" by binding this
     variable to some other string, around a call to `x-get-resource'.

 -- Variable: x-resource-name
     This variable specifies the instance name that `x-get-resource'
     should look up.  The default value is the name Emacs was invoked
     with, or the value specified with the `-name' or `-rn' switches.

   To illustrate some of the above, suppose that you have the line:

     xterm.vt100.background: yellow

in your X resources file (whose name is usually `~/.Xdefaults' or
`~/.Xresources').  Then:

     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "vt100.background" "VT100.Background"))
          => "yellow"
     (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
       (x-get-resource "background" "VT100" "vt100" "Background"))
          => "yellow"

   *Note X Resources: (emacs)X Resources.


File: elisp,  Node: Display Feature Testing,  Prev: Resources,  Up: Frames

29.23 Display Feature Testing
=============================

The functions in this section describe the basic capabilities of a
particular display.  Lisp programs can use them to adapt their behavior
to what the display can do.  For example, a program that ordinarily uses
a popup menu could use the minibuffer if popup menus are not supported.

   The optional argument DISPLAY in these functions specifies which
display to ask the question about.  It can be a display name, a frame
(which designates the display that frame is on), or `nil' (which refers
to the selected frame's display, *note Input Focus::).

   *Note Color Names::, *note Text Terminal Colors::, for other
functions to obtain information about displays.

 -- Function: display-popup-menus-p &optional display
     This function returns `t' if popup menus are supported on DISPLAY,
     `nil' if not.  Support for popup menus requires that the mouse be
     available, since the user cannot choose menu items without a mouse.

 -- Function: display-graphic-p &optional display
     This function returns `t' if DISPLAY is a graphic display capable
     of displaying several frames and several different fonts at once.
     This is true for displays that use a window system such as X, and
     false for text-only terminals.

 -- Function: display-mouse-p &optional display
     This function returns `t' if DISPLAY has a mouse available, `nil'
     if not.

 -- Function: display-color-p &optional display
     This function returns `t' if the screen is a color screen.  It
     used to be called `x-display-color-p', and that name is still
     supported as an alias.

 -- Function: display-grayscale-p &optional display
     This function returns `t' if the screen can display shades of gray.
     (All color displays can do this.)

 -- Function: display-supports-face-attributes-p attributes &optional
          display
     This function returns non-`nil' if all the face attributes in
     ATTRIBUTES are supported (*note Face Attributes::).

     The definition of `supported' is somewhat heuristic, but basically
     means that a face containing all the attributes in ATTRIBUTES,
     when merged with the default face for display, can be represented
     in a way that's

       1. different in appearance than the default face, and

       2. `close in spirit' to what the attributes specify, if not
          exact.

     Point (2) implies that a `:weight black' attribute will be
     satisfied by any display that can display bold, as will
     `:foreground "yellow"' as long as some yellowish color can be
     displayed, but `:slant italic' will _not_ be satisfied by the tty
     display code's automatic substitution of a `dim' face for italic.

 -- Function: display-selections-p &optional display
     This function returns `t' if DISPLAY supports selections.
     Windowed displays normally support selections, but they may also be
     supported in some other cases.

 -- Function: display-images-p &optional display
     This function returns `t' if DISPLAY can display images.  Windowed
     displays ought in principle to handle images, but some systems
     lack the support for that.  On a display that does not support
     images, Emacs cannot display a tool bar.

 -- Function: display-screens &optional display
     This function returns the number of screens associated with the
     display.

 -- Function: display-pixel-height &optional display
     This function returns the height of the screen in pixels.  On a
     character terminal, it gives the height in characters.

     For graphical terminals, note that on "multi-monitor" setups this
     refers to the pixel width for all physical monitors associated with
     DISPLAY.  *Note Multiple Displays::.

 -- Function: display-pixel-width &optional display
     This function returns the width of the screen in pixels.  On a
     character terminal, it gives the width in characters.

     For graphical terminals, note that on "multi-monitor" setups this
     refers to the pixel width for all physical monitors associated with
     DISPLAY.  *Note Multiple Displays::.

 -- Function: display-mm-height &optional display
     This function returns the height of the screen in millimeters, or
     `nil' if Emacs cannot get that information.

 -- Function: display-mm-width &optional display
     This function returns the width of the screen in millimeters, or
     `nil' if Emacs cannot get that information.

 -- Variable: display-mm-dimensions-alist
     This variable allows the user to specify the dimensions of
     graphical displays returned by `display-mm-height' and
     `display-mm-width' in case the system provides incorrect values.

 -- Function: display-backing-store &optional display
     This function returns the backing store capability of the display.
     Backing store means recording the pixels of windows (and parts of
     windows) that are not exposed, so that when exposed they can be
     displayed very quickly.

     Values can be the symbols `always', `when-mapped', or
     `not-useful'.  The function can also return `nil' when the
     question is inapplicable to a certain kind of display.

 -- Function: display-save-under &optional display
     This function returns non-`nil' if the display supports the
     SaveUnder feature.  That feature is used by pop-up windows to save
     the pixels they obscure, so that they can pop down quickly.

 -- Function: display-planes &optional display
     This function returns the number of planes the display supports.
     This is typically the number of bits per pixel.  For a tty
     display, it is log to base two of the number of colors supported.

 -- Function: display-visual-class &optional display
     This function returns the visual class for the screen.  The value
     is one of the symbols `static-gray', `gray-scale', `static-color',
     `pseudo-color', `true-color', and `direct-color'.

 -- Function: display-color-cells &optional display
     This function returns the number of color cells the screen
     supports.

   These functions obtain additional information specifically about X
displays.

 -- Function: x-server-version &optional display
     This function returns the list of version numbers of the X server
     running the display.  The value is a list of three integers: the
     major and minor version numbers of the X protocol, and the
     distributor-specific release number of the X server software
     itself.

 -- Function: x-server-vendor &optional display
     This function returns the "vendor" that provided the X server
     software (as a string).  Really this means whoever distributes the
     X server.

     When the developers of X labelled software distributors as
     "vendors," they showed their false assumption that no system could
     ever be developed and distributed noncommercially.


File: elisp,  Node: Positions,  Next: Markers,  Prev: Frames,  Up: Top

30 Positions
************

A "position" is the index of a character in the text of a buffer.  More
precisely, a position identifies the place between two characters (or
before the first character, or after the last character), so we can
speak of the character before or after a given position.  However, we
often speak of the character "at" a position, meaning the character
after that position.

   Positions are usually represented as integers starting from 1, but
can also be represented as "markers"--special objects that relocate
automatically when text is inserted or deleted so they stay with the
surrounding characters.  Functions that expect an argument to be a
position (an integer), but accept a marker as a substitute, normally
ignore which buffer the marker points into; they convert the marker to
an integer, and use that integer, exactly as if you had passed the
integer as the argument, even if the marker points to the "wrong"
buffer.  A marker that points nowhere cannot convert to an integer;
using it instead of an integer causes an error.  *Note Markers::.

   See also the "field" feature (*note Fields::), which provides
functions that are used by many cursor-motion commands.

* Menu:

* Point::         The special position where editing takes place.
* Motion::        Changing point.
* Excursions::    Temporary motion and buffer changes.
* Narrowing::     Restricting editing to a portion of the buffer.


File: elisp,  Node: Point,  Next: Motion,  Up: Positions

30.1 Point
==========

"Point" is a special buffer position used by many editing commands,
including the self-inserting typed characters and text insertion
functions.  Other commands move point through the text to allow editing
and insertion at different places.

   Like other positions, point designates a place between two characters
(or before the first character, or after the last character), rather
than a particular character.  Usually terminals display the cursor over
the character that immediately follows point; point is actually before
the character on which the cursor sits.

   The value of point is a number no less than 1, and no greater than
the buffer size plus 1.  If narrowing is in effect (*note Narrowing::),
then point is constrained to fall within the accessible portion of the
buffer (possibly at one end of it).

   Each buffer has its own value of point, which is independent of the
value of point in other buffers.  Each window also has a value of point,
which is independent of the value of point in other windows on the same
buffer.  This is why point can have different values in various windows
that display the same buffer.  When a buffer appears in only one window,
the buffer's point and the window's point normally have the same value,
so the distinction is rarely important.  *Note Window Point::, for more
details.

 -- Function: point
     This function returns the value of point in the current buffer, as
     an integer.

          (point)
               => 175

 -- Function: point-min
     This function returns the minimum accessible value of point in the
     current buffer.  This is normally 1, but if narrowing is in
     effect, it is the position of the start of the region that you
     narrowed to.  (*Note Narrowing::.)

 -- Function: point-max
     This function returns the maximum accessible value of point in the
     current buffer.  This is `(1+ (buffer-size))', unless narrowing is
     in effect, in which case it is the position of the end of the
     region that you narrowed to.  (*Note Narrowing::.)

 -- Function: buffer-end flag
     This function returns `(point-max)' if FLAG is greater than 0,
     `(point-min)' otherwise.  The argument FLAG must be a number.

 -- Function: buffer-size &optional buffer
     This function returns the total number of characters in the current
     buffer.  In the absence of any narrowing (*note Narrowing::),
     `point-max' returns a value one larger than this.

     If you specify a buffer, BUFFER, then the value is the size of
     BUFFER.

          (buffer-size)
               => 35
          (point-max)
               => 36


File: elisp,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

30.2 Motion
===========

Motion functions change the value of point, either relative to the
current value of point, relative to the beginning or end of the buffer,
or relative to the edges of the selected window.  *Note Point::.

* Menu:

* Character Motion::       Moving in terms of characters.
* Word Motion::            Moving in terms of words.
* Buffer End Motion::      Moving to the beginning or end of the buffer.
* Text Lines::             Moving in terms of lines of text.
* Screen Lines::           Moving in terms of lines as displayed.
* List Motion::            Moving by parsing lists and sexps.
* Skipping Characters::    Skipping characters belonging to a certain set.


File: elisp,  Node: Character Motion,  Next: Word Motion,  Up: Motion

30.2.1 Motion by Characters
---------------------------

These functions move point based on a count of characters.  `goto-char'
is the fundamental primitive; the other functions use that.

 -- Command: goto-char position
     This function sets point in the current buffer to the value
     POSITION.  If POSITION is less than 1, it moves point to the
     beginning of the buffer.  If POSITION is greater than the length
     of the buffer, it moves point to the end.

     If narrowing is in effect, POSITION still counts from the
     beginning of the buffer, but point cannot go outside the accessible
     portion.  If POSITION is out of range, `goto-char' moves point to
     the beginning or the end of the accessible portion.

     When this function is called interactively, POSITION is the
     numeric prefix argument, if provided; otherwise it is read from the
     minibuffer.

     `goto-char' returns POSITION.

 -- Command: forward-char &optional count
     This function moves point COUNT characters forward, towards the
     end of the buffer (or backward, towards the beginning of the
     buffer, if COUNT is negative).  If COUNT is `nil', the default is
     1.

     If this attempts to move past the beginning or end of the buffer
     (or the limits of the accessible portion, when narrowing is in
     effect), it signals an error with error symbol
     `beginning-of-buffer' or `end-of-buffer'.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Command: backward-char &optional count
     This is just like `forward-char' except that it moves in the
     opposite direction.


File: elisp,  Node: Word Motion,  Next: Buffer End Motion,  Prev: Character Motion,  Up: Motion

30.2.2 Motion by Words
----------------------

These functions for parsing words use the syntax table to decide
whether a given character is part of a word.  *Note Syntax Tables::.

 -- Command: forward-word &optional count
     This function moves point forward COUNT words (or backward if
     COUNT is negative).  If COUNT is `nil', it moves forward one word.

     "Moving one word" means moving until point crosses a
     word-constituent character and then encounters a word-separator
     character.  However, this function cannot move point past the
     boundary of the accessible portion of the buffer, or across a
     field boundary (*note Fields::).  The most common case of a field
     boundary is the end of the prompt in the minibuffer.

     If it is possible to move COUNT words, without being stopped
     prematurely by the buffer boundary or a field boundary, the value
     is `t'.  Otherwise, the return value is `nil' and point stops at
     the buffer boundary or field boundary.

     If `inhibit-field-text-motion' is non-`nil', this function ignores
     field boundaries.

     In an interactive call, COUNT is specified by the numeric prefix
     argument.  If COUNT is omitted or `nil', it defaults to 1.

 -- Command: backward-word &optional count
     This function is just like `forward-word', except that it moves
     backward until encountering the front of a word, rather than
     forward.

 -- Variable: words-include-escapes
     This variable affects the behavior of `forward-word' and everything
     that uses it.  If it is non-`nil', then characters in the "escape"
     and "character quote" syntax classes count as part of words.
     Otherwise, they do not.

 -- Variable: inhibit-field-text-motion
     If this variable is non-`nil', certain motion functions including
     `forward-word', `forward-sentence', and `forward-paragraph' ignore
     field boundaries.


File: elisp,  Node: Buffer End Motion,  Next: Text Lines,  Prev: Word Motion,  Up: Motion

30.2.3 Motion to an End of the Buffer
-------------------------------------

To move point to the beginning of the buffer, write:

     (goto-char (point-min))

Likewise, to move to the end of the buffer, use:

     (goto-char (point-max))

   Here are two commands that users use to do these things.  They are
documented here to warn you not to use them in Lisp programs, because
they set the mark and display messages in the echo area.

 -- Command: beginning-of-buffer &optional n
     This function moves point to the beginning of the buffer (or the
     limits of the accessible portion, when narrowing is in effect),
     setting the mark at the previous position (except in Transient
     Mark mode, if the mark is already active, it does not set the
     mark.)

     If N is non-`nil', then it puts point N tenths of the way from the
     beginning of the accessible portion of the buffer.  In an
     interactive call, N is the numeric prefix argument, if provided;
     otherwise N defaults to `nil'.

     *Warning:* Don't use this function in Lisp programs!

 -- Command: end-of-buffer &optional n
     This function moves point to the end of the buffer (or the limits
     of the accessible portion, when narrowing is in effect), setting
     the mark at the previous position (except in Transient Mark mode
     when the mark is already active).  If N is non-`nil', then it puts
     point N tenths of the way from the end of the accessible portion of
     the buffer.

     In an interactive call, N is the numeric prefix argument, if
     provided; otherwise N defaults to `nil'.

     *Warning:* Don't use this function in Lisp programs!


File: elisp,  Node: Text Lines,  Next: Screen Lines,  Prev: Buffer End Motion,  Up: Motion

30.2.4 Motion by Text Lines
---------------------------

Text lines are portions of the buffer delimited by newline characters,
which are regarded as part of the previous line.  The first text line
begins at the beginning of the buffer, and the last text line ends at
the end of the buffer whether or not the last character is a newline.
The division of the buffer into text lines is not affected by the width
of the window, by line continuation in display, or by how tabs and
control characters are displayed.

 -- Command: goto-line line
     This function moves point to the front of the LINEth line,
     counting from line 1 at beginning of the buffer.  If LINE is less
     than 1, it moves point to the beginning of the buffer.  If LINE is
     greater than the number of lines in the buffer, it moves point to
     the end of the buffer--that is, the _end of the last line_ of the
     buffer.  This is the only case in which `goto-line' does not
     necessarily move to the beginning of a line.

     If narrowing is in effect, then LINE still counts from the
     beginning of the buffer, but point cannot go outside the accessible
     portion.  So `goto-line' moves point to the beginning or end of the
     accessible portion, if the line number specifies an inaccessible
     position.

     The return value of `goto-line' is the difference between LINE and
     the line number of the line to which point actually was able to
     move (in the full buffer, before taking account of narrowing).
     Thus, the value is positive if the scan encounters the real end of
     the buffer before finding the specified line.  The value is zero
     if scan encounters the end of the accessible portion but not the
     real end of the buffer.

     In an interactive call, LINE is the numeric prefix argument if one
     has been provided.  Otherwise LINE is read in the minibuffer.

 -- Command: beginning-of-line &optional count
     This function moves point to the beginning of the current line.
     With an argument COUNT not `nil' or 1, it moves forward COUNT-1
     lines and then to the beginning of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is `nil' or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     either bind `inhibit-field-text-motion' to `t', or use the
     `forward-line' function instead.  For instance, `(forward-line 0)'
     does the same thing as `(beginning-of-line)', except that it
     ignores field boundaries.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-beginning-position &optional count
     Return the position that `(beginning-of-line COUNT)' would move to.

 -- Command: end-of-line &optional count
     This function moves point to the end of the current line.  With an
     argument COUNT not `nil' or 1, it moves forward COUNT-1 lines and
     then to the end of the line.

     This function does not move point across a field boundary (*note
     Fields::) unless doing so would move beyond there to a different
     line; therefore, if COUNT is `nil' or 1, and point starts at a
     field boundary, point does not move.  To ignore field boundaries,
     bind `inhibit-field-text-motion' to `t'.

     If this function reaches the end of the buffer (or of the
     accessible portion, if narrowing is in effect), it positions point
     there.  No error is signaled.

 -- Function: line-end-position &optional count
     Return the position that `(end-of-line COUNT)' would move to.

 -- Command: forward-line &optional count
     This function moves point forward COUNT lines, to the beginning of
     the line.  If COUNT is negative, it moves point -COUNT lines
     backward, to the beginning of a line.  If COUNT is zero, it moves
     point to the beginning of the current line.  If COUNT is `nil',
     that means 1.

     If `forward-line' encounters the beginning or end of the buffer (or
     of the accessible portion) before finding that many lines, it sets
     point there.  No error is signaled.

     `forward-line' returns the difference between COUNT and the number
     of lines actually moved.  If you attempt to move down five lines
     from the beginning of a buffer that has only three lines, point
     stops at the end of the last line, and the value will be 2.

     In an interactive call, COUNT is the numeric prefix argument.

 -- Function: count-lines start end
     This function returns the number of lines between the positions
     START and END in the current buffer.  If START and END are equal,
     then it returns 0.  Otherwise it returns at least 1, even if START
     and END are on the same line.  This is because the text between
     them, considered in isolation, must contain at least one line
     unless it is empty.

     Here is an example of using `count-lines':

          (defun current-line ()
            "Return the vertical position of point..."
            (+ (count-lines (window-start) (point))
               (if (= (current-column) 0) 1 0)))

 -- Function: line-number-at-pos &optional pos
     This function returns the line number in the current buffer
     corresponding to the buffer position POS.  If POS is `nil' or
     omitted, the current buffer position is used.

   Also see the functions `bolp' and `eolp' in *note Near Point::.
These functions do not move point, but test whether it is already at the
beginning or end of a line.


File: elisp,  Node: Screen Lines,  Next: List Motion,  Prev: Text Lines,  Up: Motion

30.2.5 Motion by Screen Lines
-----------------------------

The line functions in the previous section count text lines, delimited
only by newline characters.  By contrast, these functions count screen
lines, which are defined by the way the text appears on the screen.  A
text line is a single screen line if it is short enough to fit the width
of the selected window, but otherwise it may occupy several screen
lines.

   In some cases, text lines are truncated on the screen rather than
continued onto additional screen lines.  In these cases,
`vertical-motion' moves point much like `forward-line'.  *Note
Truncation::.

   Because the width of a given string depends on the flags that control
the appearance of certain characters, `vertical-motion' behaves
differently, for a given piece of text, depending on the buffer it is
in, and even on the selected window (because the width, the truncation
flag, and display table may vary between windows).  *Note Usual
Display::.

   These functions scan text to determine where screen lines break, and
thus take time proportional to the distance scanned.  If you intend to
use them heavily, Emacs provides caches which may improve the
performance of your code.  *Note cache-long-line-scans: Truncation.

 -- Function: vertical-motion count &optional window
     This function moves point to the start of the screen line COUNT
     screen lines down from the screen line containing point.  If COUNT
     is negative, it moves up instead.

     `vertical-motion' returns the number of screen lines over which it
     moved point.  The value may be less in absolute value than COUNT
     if the beginning or end of the buffer was reached.

     The window WINDOW is used for obtaining parameters such as the
     width, the horizontal scrolling, and the display table.  But
     `vertical-motion' always operates on the current buffer, even if
     WINDOW currently displays some other buffer.

 -- Function: count-screen-lines &optional beg end count-final-newline
          window
     This function returns the number of screen lines in the text from
     BEG to END.  The number of screen lines may be different from the
     number of actual lines, due to line continuation, the display
     table, etc.  If BEG and END are `nil' or omitted, they default to
     the beginning and end of the accessible portion of the buffer.

     If the region ends with a newline, that is ignored unless the
     optional third argument COUNT-FINAL-NEWLINE is non-`nil'.

     The optional fourth argument WINDOW specifies the window for
     obtaining parameters such as width, horizontal scrolling, and so
     on.  The default is to use the selected window's parameters.

     Like `vertical-motion', `count-screen-lines' always uses the
     current buffer, regardless of which buffer is displayed in WINDOW.
     This makes possible to use `count-screen-lines' in any buffer,
     whether or not it is currently displayed in some window.

 -- Command: move-to-window-line count
     This function moves point with respect to the text currently
     displayed in the selected window.  It moves point to the beginning
     of the screen line COUNT screen lines from the top of the window.
     If COUNT is negative, that specifies a position -COUNT lines from
     the bottom (or the last line of the buffer, if the buffer ends
     above the specified screen position).

     If COUNT is `nil', then point moves to the beginning of the line
     in the middle of the window.  If the absolute value of COUNT is
     greater than the size of the window, then point moves to the place
     that would appear on that screen line if the window were tall
     enough.  This will probably cause the next redisplay to scroll to
     bring that location onto the screen.

     In an interactive call, COUNT is the numeric prefix argument.

     The value returned is the window line number point has moved to,
     with the top line in the window numbered 0.

 -- Function: compute-motion from frompos to topos width offsets window
     This function scans the current buffer, calculating screen
     positions.  It scans the buffer forward from position FROM,
     assuming that is at screen coordinates FROMPOS, to position TO or
     coordinates TOPOS, whichever comes first.  It returns the ending
     buffer position and screen coordinates.

     The coordinate arguments FROMPOS and TOPOS are cons cells of the
     form `(HPOS . VPOS)'.

     The argument WIDTH is the number of columns available to display
     text; this affects handling of continuation lines.  `nil' means
     the actual number of usable text columns in the window, which is
     equivalent to the value returned by `(window-width window)'.

     The argument OFFSETS is either `nil' or a cons cell of the form
     `(HSCROLL . TAB-OFFSET)'.  Here HSCROLL is the number of columns
     not being displayed at the left margin; most callers get this by
     calling `window-hscroll'.  Meanwhile, TAB-OFFSET is the offset
     between column numbers on the screen and column numbers in the
     buffer.  This can be nonzero in a continuation line, when the
     previous screen lines' widths do not add up to a multiple of
     `tab-width'.  It is always zero in a non-continuation line.

     The window WINDOW serves only to specify which display table to
     use.  `compute-motion' always operates on the current buffer,
     regardless of what buffer is displayed in WINDOW.

     The return value is a list of five elements:

          (POS HPOS VPOS PREVHPOS CONTIN)

     Here POS is the buffer position where the scan stopped, VPOS is
     the vertical screen position, and HPOS is the horizontal screen
     position.

     The result PREVHPOS is the horizontal position one character back
     from POS.  The result CONTIN is `t' if the last line was continued
     after (or within) the previous character.

     For example, to find the buffer position of column COL of screen
     line LINE of a certain window, pass the window's display start
     location as FROM and the window's upper-left coordinates as
     FROMPOS.  Pass the buffer's `(point-max)' as TO, to limit the scan
     to the end of the accessible portion of the buffer, and pass LINE
     and COL as TOPOS.  Here's a function that does this:

          (defun coordinates-of-position (col line)
            (car (compute-motion (window-start)
                                 '(0 . 0)
                                 (point-max)
                                 (cons col line)
                                 (window-width)
                                 (cons (window-hscroll) 0)
                                 (selected-window))))

     When you use `compute-motion' for the minibuffer, you need to use
     `minibuffer-prompt-width' to get the horizontal position of the
     beginning of the first screen line.  *Note Minibuffer Contents::.


File: elisp,  Node: List Motion,  Next: Skipping Characters,  Prev: Screen Lines,  Up: Motion

30.2.6 Moving over Balanced Expressions
---------------------------------------

Here are several functions concerned with balanced-parenthesis
expressions (also called "sexps" in connection with moving across them
in Emacs).  The syntax table controls how these functions interpret
various characters; see *note Syntax Tables::.  *Note Parsing
Expressions::, for lower-level primitives for scanning sexps or parts of
sexps.  For user-level commands, see *note Commands for Editing with
Parentheses: (emacs)Parentheses.

 -- Command: forward-list &optional arg
     This function moves forward across ARG (default 1) balanced groups
     of parentheses.  (Other syntactic entities such as words or paired
     string quotes are ignored.)

 -- Command: backward-list &optional arg
     This function moves backward across ARG (default 1) balanced
     groups of parentheses.  (Other syntactic entities such as words or
     paired string quotes are ignored.)

 -- Command: up-list &optional arg
     This function moves forward out of ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still to
     a less deep spot.

 -- Command: down-list &optional arg
     This function moves forward into ARG (default 1) levels of
     parentheses.  A negative argument means move backward but still go
     deeper in parentheses (-ARG levels).

 -- Command: forward-sexp &optional arg
     This function moves forward across ARG (default 1) balanced
     expressions.  Balanced expressions include both those delimited by
     parentheses and other kinds, such as words and string constants.
     *Note Parsing Expressions::.  For example,

          ---------- Buffer: foo ----------
          (concat-!- "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               => nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y-!- z)
          ---------- Buffer: foo ----------

 -- Command: backward-sexp &optional arg
     This function moves backward across ARG (default 1) balanced
     expressions.

 -- Command: beginning-of-defun &optional arg
     This function moves back to the ARGth beginning of a defun.  If
     ARG is negative, this actually moves forward, but it still moves
     to the beginning of a defun, not to the end of one.  ARG defaults
     to 1.

 -- Command: end-of-defun &optional arg
     This function moves forward to the ARGth end of a defun.  If ARG
     is negative, this actually moves backward, but it still moves to
     the end of a defun, not to the beginning of one.  ARG defaults to
     1.

 -- User Option: defun-prompt-regexp
     If non-`nil', this buffer-local variable holds a regular
     expression that specifies what text can appear before the
     open-parenthesis that starts a defun.  That is to say, a defun
     begins on a line that starts with a match for this regular
     expression, followed by a character with open-parenthesis syntax.

 -- User Option: open-paren-in-column-0-is-defun-start
     If this variable's value is non-`nil', an open parenthesis in
     column 0 is considered to be the start of a defun.  If it is
     `nil', an open parenthesis in column 0 has no special meaning.
     The default is `t'.

 -- Variable: beginning-of-defun-function
     If non-`nil', this variable holds a function for finding the
     beginning of a defun.  The function `beginning-of-defun' calls
     this function instead of using its normal method.

 -- Variable: end-of-defun-function
     If non-`nil', this variable holds a function for finding the end of
     a defun.  The function `end-of-defun' calls this function instead
     of using its normal method.


File: elisp,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

30.2.7 Skipping Characters
--------------------------

The following two functions move point over a specified set of
characters.  For example, they are often used to skip whitespace.  For
related functions, see *note Motion and Syntax::.

   These functions convert the set string to multibyte if the buffer is
multibyte, and they convert it to unibyte if the buffer is unibyte, as
the search functions do (*note Searching and Matching::).

 -- Function: skip-chars-forward character-set &optional limit
     This function moves point in the current buffer forward, skipping
     over a given set of characters.  It examines the character
     following point, then advances point if the character matches
     CHARACTER-SET.  This continues until it reaches a character that
     does not match.  The function returns the number of characters
     moved over.

     The argument CHARACTER-SET is a string, like the inside of a
     `[...]' in a regular expression except that `]' does not terminate
     it, and `\' quotes `^', `-' or `\'.  Thus, `"a-zA-Z"' skips over
     all letters, stopping before the first nonletter, and `"^a-zA-Z"'
     skips nonletters stopping before the first letter.  See *Note
     Regular Expressions::.  Character classes can also be used, e.g.
     `"[:alnum:]"'.  See *note Char Classes::.

     If LIMIT is supplied (it must be a number or a marker), it
     specifies the maximum position in the buffer that point can be
     skipped to.  Point will stop at or before LIMIT.

     In the following example, point is initially located directly
     before the `T'.  After the form is evaluated, point is located at
     the end of that line (between the `t' of `hat' and the newline).
     The function skips all letters and spaces, but not newlines.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               => nil

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward character-set &optional limit
     This function moves point backward, skipping characters that match
     CHARACTER-SET, until LIMIT.  It is just like `skip-chars-forward'
     except for the direction of motion.

     The return value indicates the distance traveled.  It is an
     integer that is zero or less.


File: elisp,  Node: Excursions,  Next: Narrowing,  Prev: Motion,  Up: Positions

30.3 Excursions
===============

It is often useful to move point "temporarily" within a localized
portion of the program, or to switch buffers temporarily.  This is
called an "excursion", and it is done with the `save-excursion' special
form.  This construct initially remembers the identity of the current
buffer, and its values of point and the mark, and restores them after
the completion of the excursion.

   The forms for saving and restoring the configuration of windows are
described elsewhere (see *note Window Configurations::, and *note Frame
Configurations::).

 -- Special Form: save-excursion body...
     The `save-excursion' special form saves the identity of the current
     buffer and the values of point and the mark in it, evaluates BODY,
     and finally restores the buffer and its saved values of point and
     the mark.  All three saved values are restored even in case of an
     abnormal exit via `throw' or error (*note Nonlocal Exits::).

     The `save-excursion' special form is the standard way to switch
     buffers or move point within one part of a program and avoid
     affecting the rest of the program.  It is used more than 4000
     times in the Lisp sources of Emacs.

     `save-excursion' does not save the values of point and the mark for
     other buffers, so changes in other buffers remain in effect after
     `save-excursion' exits.

     Likewise, `save-excursion' does not restore window-buffer
     correspondences altered by functions such as `switch-to-buffer'.
     One way to restore these correspondences, and the selected window,
     is to use `save-window-excursion' inside `save-excursion' (*note
     Window Configurations::).

     The value returned by `save-excursion' is the result of the last
     form in BODY, or `nil' if no body forms were given.

          (save-excursion FORMS)
          ==
          (let ((old-buf (current-buffer))
                (old-pnt (point-marker))
                (old-mark (copy-marker (mark-marker))))
            (unwind-protect
                (progn FORMS)
              (set-buffer old-buf)
              (goto-char old-pnt)
              (set-marker (mark-marker) old-mark)))

   *Warning:* Ordinary insertion of text adjacent to the saved point
value relocates the saved value, just as it relocates all markers.
More precisely, the saved value is a marker with insertion type `nil'.
*Note Marker Insertion Types::.  Therefore, when the saved point value
is restored, it normally comes before the inserted text.

   Although `save-excursion' saves the location of the mark, it does
not prevent functions which modify the buffer from setting
`deactivate-mark', and thus causing the deactivation of the mark after
the command finishes.  *Note The Mark::.


File: elisp,  Node: Narrowing,  Prev: Excursions,  Up: Positions

30.4 Narrowing
==============

"Narrowing" means limiting the text addressable by Emacs editing
commands to a limited range of characters in a buffer.  The text that
remains addressable is called the "accessible portion" of the buffer.

   Narrowing is specified with two buffer positions which become the
beginning and end of the accessible portion.  For most editing commands
and most Emacs primitives, these positions replace the values of the
beginning and end of the buffer.  While narrowing is in effect, no text
outside the accessible portion is displayed, and point cannot move
outside the accessible portion.

   Values such as positions or line numbers, which usually count from
the beginning of the buffer, do so despite narrowing, but the functions
which use them refuse to operate on text that is inaccessible.

   The commands for saving buffers are unaffected by narrowing; they
save the entire buffer regardless of any narrowing.

 -- Command: narrow-to-region start end
     This function sets the accessible portion of the current buffer to
     start at START and end at END.  Both arguments should be character
     positions.

     In an interactive call, START and END are set to the bounds of the
     current region (point and the mark, with the smallest first).

 -- Command: narrow-to-page &optional move-count
     This function sets the accessible portion of the current buffer to
     include just the current page.  An optional first argument
     MOVE-COUNT non-`nil' means to move forward or backward by
     MOVE-COUNT pages and then narrow to one page.  The variable
     `page-delimiter' specifies where pages start and end (*note
     Standard Regexps::).

     In an interactive call, MOVE-COUNT is set to the numeric prefix
     argument.

 -- Command: widen
     This function cancels any narrowing in the current buffer, so that
     the entire contents are accessible.  This is called "widening".
     It is equivalent to the following expression:

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Special Form: save-restriction body...
     This special form saves the current bounds of the accessible
     portion, evaluates the BODY forms, and finally restores the saved
     bounds, thus restoring the same state of narrowing (or absence
     thereof) formerly in effect.  The state of narrowing is restored
     even in the event of an abnormal exit via `throw' or error (*note
     Nonlocal Exits::).  Therefore, this construct is a clean way to
     narrow a buffer temporarily.

     The value returned by `save-restriction' is that returned by the
     last form in BODY, or `nil' if no body forms were given.

     *Caution:* it is easy to make a mistake when using the
     `save-restriction' construct.  Read the entire description here
     before you try it.

     If BODY changes the current buffer, `save-restriction' still
     restores the restrictions on the original buffer (the buffer whose
     restrictions it saved from), but it does not restore the identity
     of the current buffer.

     `save-restriction' does _not_ restore point and the mark; use
     `save-excursion' for that.  If you use both `save-restriction' and
     `save-excursion' together, `save-excursion' should come first (on
     the outside).  Otherwise, the old point value would be restored
     with temporary narrowing still in effect.  If the old point value
     were outside the limits of the temporary narrowing, this would
     fail to restore it accurately.

     Here is a simple example of correct use of `save-restriction':

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo-!-
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo-!-
          ---------- Buffer: foo ----------


File: elisp,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

31 Markers
**********

A "marker" is a Lisp object used to specify a position in a buffer
relative to the surrounding text.  A marker changes its offset from the
beginning of the buffer automatically whenever text is inserted or
deleted, so that it stays with the two characters on either side of it.

* Menu:

* Overview of Markers::      The components of a marker, and how it relocates.
* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker's buffer or character position.
* Marker Insertion Types::   Two ways a marker can relocate when you
                               insert where it points.
* Moving Markers::           Moving the marker to a new buffer or position.
* The Mark::                 How "the mark" is implemented with a marker.
* The Region::               How to access "the region".


File: elisp,  Node: Overview of Markers,  Next: Predicates on Markers,  Up: Markers

31.1 Overview of Markers
========================

A marker specifies a buffer and a position in that buffer.  The marker
can be used to represent a position in the functions that require one,
just as an integer could be used.  In that case, the marker's buffer is
normally ignored.  Of course, a marker used in this way usually points
to a position in the buffer that the function operates on, but that is
entirely the programmer's responsibility.  *Note Positions::, for a
complete description of positions.

   A marker has three attributes: the marker position, the marker
buffer, and the insertion type.  The marker position is an integer that
is equivalent (at a given time) to the marker as a position in that
buffer.  But the marker's position value can change often during the
life of the marker.  Insertion and deletion of text in the buffer
relocate the marker.  The idea is that a marker positioned between two
characters remains between those two characters despite insertion and
deletion elsewhere in the buffer.  Relocation changes the integer
equivalent of the marker.

   Deleting text around a marker's position leaves the marker between
the characters immediately before and after the deleted text.  Inserting
text at the position of a marker normally leaves the marker either in
front of or after the new text, depending on the marker's "insertion
type" (*note Marker Insertion Types::)--unless the insertion is done
with `insert-before-markers' (*note Insertion::).

   Insertion and deletion in a buffer must check all the markers and
relocate them if necessary.  This slows processing in a buffer with a
large number of markers.  For this reason, it is a good idea to make a
marker point nowhere if you are sure you don't need it any more.
Unreferenced markers are garbage collected eventually, but until then
will continue to use time if they do point somewhere.

   Because it is common to perform arithmetic operations on a marker
position, most of the arithmetic operations (including `+' and `-')
accept markers as arguments.  In such cases, the marker stands for its
current position.

   Here are examples of creating markers, setting markers, and moving
point to markers:

     ;; Make a new marker that initially does not point anywhere:
     (setq m1 (make-marker))
          => #<marker in no buffer>

     ;; Set `m1' to point between the 99th and 100th characters
     ;;   in the current buffer:
     (set-marker m1 100)
          => #<marker at 100 in markers.texi>

     ;; Now insert one character at the beginning of the buffer:
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil

     ;; `m1' is updated appropriately.
     m1
          => #<marker at 101 in markers.texi>

     ;; Two markers that point to the same position
     ;;   are not `eq', but they are `equal'.
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texi>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t

     ;; When you are finished using a marker, make it point nowhere.
     (set-marker m1 nil)
          => #<marker in no buffer>


File: elisp,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Overview of Markers,  Up: Markers

31.2 Predicates on Markers
==========================

You can test an object to see whether it is a marker, or whether it is
either an integer or a marker.  The latter test is useful in connection
with the arithmetic functions that work with both markers and integers.

 -- Function: markerp object
     This function returns `t' if OBJECT is a marker, `nil' otherwise.
     Note that integers are not markers, even though many functions
     will accept either a marker or an integer.

 -- Function: integer-or-marker-p object
     This function returns `t' if OBJECT is an integer or a marker,
     `nil' otherwise.

 -- Function: number-or-marker-p object
     This function returns `t' if OBJECT is a number (either integer or
     floating point) or a marker, `nil' otherwise.


File: elisp,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

31.3 Functions that Create Markers
==================================

When you create a new marker, you can make it point nowhere, or point
to the present position of point, or to the beginning or end of the
accessible portion of the buffer, or to the same place as another given
marker.

   The next four functions all return markers with insertion type
`nil'.  *Note Marker Insertion Types::.

 -- Function: make-marker
     This function returns a newly created marker that does not point
     anywhere.

          (make-marker)
               => #<marker in no buffer>

 -- Function: point-marker
     This function returns a new marker that points to the present
     position of point in the current buffer.  *Note Point::.  For an
     example, see `copy-marker', below.

 -- Function: point-min-marker
     This function returns a new marker that points to the beginning of
     the accessible portion of the buffer.  This will be the beginning
     of the buffer unless narrowing is in effect.  *Note Narrowing::.

 -- Function: point-max-marker
     This function returns a new marker that points to the end of the
     accessible portion of the buffer.  This will be the end of the
     buffer unless narrowing is in effect.  *Note Narrowing::.

     Here are examples of this function and `point-min-marker', shown in
     a buffer containing a version of the source file for the text of
     this chapter.

          (point-min-marker)
               => #<marker at 1 in markers.texi>
          (point-max-marker)
               => #<marker at 15573 in markers.texi>

          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texi>
          (point-max-marker)
               => #<marker at 200 in markers.texi>

 -- Function: copy-marker marker-or-integer &optional insertion-type
     If passed a marker as its argument, `copy-marker' returns a new
     marker that points to the same place and the same buffer as does
     MARKER-OR-INTEGER.  If passed an integer as its argument,
     `copy-marker' returns a new marker that points to position
     MARKER-OR-INTEGER in the current buffer.

     The new marker's insertion type is specified by the argument
     INSERTION-TYPE.  *Note Marker Insertion Types::.

     If passed an integer argument less than 1, `copy-marker' returns a
     new marker that points to the beginning of the current buffer.  If
     passed an integer argument greater than the length of the buffer,
     `copy-marker' returns a new marker that points to the end of the
     buffer.

          (copy-marker 0)
               => #<marker at 1 in markers.texi>

          (copy-marker 20000)
               => #<marker at 7572 in markers.texi>

     An error is signaled if MARKER is neither a marker nor an integer.

   Two distinct markers are considered `equal' (even though not `eq')
to each other if they have the same position and buffer, or if they
both point nowhere.

     (setq p (point-marker))
          => #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          => #<marker at 2139 in markers.texi>

     (eq p q)
          => nil

     (equal p q)
          => t


File: elisp,  Node: Information from Markers,  Next: Marker Insertion Types,  Prev: Creating Markers,  Up: Markers

31.4 Information from Markers
=============================

This section describes the functions for accessing the components of a
marker object.

 -- Function: marker-position marker
     This function returns the position that MARKER points to, or `nil'
     if it points nowhere.

 -- Function: marker-buffer marker
     This function returns the buffer that MARKER points into, or `nil'
     if it points nowhere.

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil

          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texi>
          (marker-buffer m)
               => #<buffer markers.texi>
          (marker-position m)
               => 3770

 -- Function: buffer-has-markers-at position
     This function returns `t' if one or more markers point at position
     POSITION in the current buffer.


File: elisp,  Node: Marker Insertion Types,  Next: Moving Markers,  Prev: Information from Markers,  Up: Markers

31.5 Marker Insertion Types
===========================

When you insert text directly at the place where a marker points, there
are two possible ways to relocate that marker: it can point before the
inserted text, or point after it.  You can specify which one a given
marker should do by setting its "insertion type".  Note that use of
`insert-before-markers' ignores markers' insertion types, always
relocating a marker to point after the inserted text.

 -- Function: set-marker-insertion-type marker type
     This function sets the insertion type of marker MARKER to TYPE.
     If TYPE is `t', MARKER will advance when text is inserted at its
     position.  If TYPE is `nil', MARKER does not advance when text is
     inserted there.

 -- Function: marker-insertion-type marker
     This function reports the current insertion type of MARKER.

   Most functions that create markers, without an argument allowing to
specify the insertion type, create them with insertion type `nil'.
Also, the mark has, by default, insertion type `nil'.


File: elisp,  Node: Moving Markers,  Next: The Mark,  Prev: Marker Insertion Types,  Up: Markers

31.6 Moving Marker Positions
============================

This section describes how to change the position of an existing
marker.  When you do this, be sure you know whether the marker is used
outside of your program, and, if so, what effects will result from
moving it--otherwise, confusing things may happen in other parts of
Emacs.

 -- Function: set-marker marker position &optional buffer
     This function moves MARKER to POSITION in BUFFER.  If BUFFER is
     not provided, it defaults to the current buffer.

     If POSITION is less than 1, `set-marker' moves MARKER to the
     beginning of the buffer.  If POSITION is greater than the size of
     the buffer, `set-marker' moves marker to the end of the buffer.
     If POSITION is `nil' or a marker that points nowhere, then MARKER
     is set to point nowhere.

     The value returned is MARKER.

          (setq m (point-marker))
               => #<marker at 4714 in markers.texi>
          (set-marker m 55)
               => #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 -- Function: move-marker marker position &optional buffer
     This is another name for `set-marker'.


File: elisp,  Node: The Mark,  Next: The Region,  Prev: Moving Markers,  Up: Markers

31.7 The Mark
=============

One special marker in each buffer is designated "the mark".  It
specifies a position to bound a range of text for commands such as
`kill-region' and `indent-rigidly'.  Lisp programs should set the mark
only to values that have a potential use to the user, and never for
their own internal purposes.  For example, the `replace-regexp' command
sets the mark to the value of point before doing any replacements,
because this enables the user to move back there conveniently after the
replace is finished.

   Many commands are designed to operate on the text between point and
the mark when called interactively.  If you are writing such a command,
don't examine the mark directly; instead, use `interactive' with the
`r' specification.  This provides the values of point and the mark as
arguments to the command in an interactive call, but permits other Lisp
programs to specify arguments explicitly.  *Note Interactive Codes::.

   Each buffer has a marker which represents the value of the mark in
that buffer, independent of any other buffer.  When a buffer is newly
created, this marker exists but does not point anywhere.  That means
the mark "doesn't exist" in that buffer as yet.

   Once the mark "exists" in a buffer, it normally never ceases to
exist.  However, it may become "inactive", if Transient Mark mode is
enabled.  The variable `mark-active', which is always buffer-local in
all buffers, indicates whether the mark is active: non-`nil' means yes.
A command can request deactivation of the mark upon return to the
editor command loop by setting `deactivate-mark' to a non-`nil' value
(but this causes deactivation only if Transient Mark mode is enabled).

   The main motivation for using Transient Mark mode is that this mode
also enables highlighting of the region when the mark is active.  *Note
Display::.

   In addition to the mark, each buffer has a "mark ring" which is a
list of markers containing previous values of the mark.  When editing
commands change the mark, they should normally save the old value of the
mark on the mark ring.  The variable `mark-ring-max' specifies the
maximum number of entries in the mark ring; once the list becomes this
long, adding a new element deletes the last element.

   There is also a separate global mark ring, but that is used only in a
few particular user-level commands, and is not relevant to Lisp
programming.  So we do not describe it here.

 -- Function: mark &optional force
     This function returns the current buffer's mark position as an
     integer, or `nil' if no mark has ever been set in this buffer.

     If Transient Mark mode is enabled, and `mark-even-if-inactive' is
     `nil', `mark' signals an error if the mark is inactive.  However,
     if FORCE is non-`nil', then `mark' disregards inactivity of the
     mark, and returns the mark position anyway (or `nil').

 -- Function: mark-marker
     This function returns the marker that represents the current
     buffer's mark.  It is not a copy, it is the marker used
     internally.  Therefore, changing this marker's position will
     directly affect the buffer's mark.  Don't do that unless that is
     the effect you want.

          (setq m (mark-marker))
               => #<marker at 3420 in markers.texi>
          (set-marker m 100)
               => #<marker at 100 in markers.texi>
          (mark-marker)
               => #<marker at 100 in markers.texi>

     Like any marker, this marker can be set to point at any buffer you
     like.  If you make it point at any buffer other than the one of
     which it is the mark, it will yield perfectly consistent, but
     rather odd, results.  We recommend that you not do it!

 -- Function: set-mark position
     This function sets the mark to POSITION, and activates the mark.
     The old value of the mark is _not_ pushed onto the mark ring.

     *Please note:* Use this function only if you want the user to see
     that the mark has moved, and you want the previous mark position to
     be lost.  Normally, when a new mark is set, the old one should go
     on the `mark-ring'.  For this reason, most applications should use
     `push-mark' and `pop-mark', not `set-mark'.

     Novice Emacs Lisp programmers often try to use the mark for the
     wrong purposes.  The mark saves a location for the user's
     convenience.  An editing command should not alter the mark unless
     altering the mark is part of the user-level functionality of the
     command.  (And, in that case, this effect should be documented.)
     To remember a location for internal use in the Lisp program, store
     it in a Lisp variable.  For example:

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point))).

 -- Function: push-mark &optional position nomsg activate
     This function sets the current buffer's mark to POSITION, and
     pushes a copy of the previous mark onto `mark-ring'.  If POSITION
     is `nil', then the value of point is used.  `push-mark' returns
     `nil'.

     The function `push-mark' normally _does not_ activate the mark.
     To do that, specify `t' for the argument ACTIVATE.

     A `Mark set' message is displayed unless NOMSG is non-`nil'.

 -- Function: pop-mark
     This function pops off the top element of `mark-ring' and makes
     that mark become the buffer's actual mark.  This does not move
     point in the buffer, and it does nothing if `mark-ring' is empty.
     It deactivates the mark.

     The return value is not meaningful.

 -- User Option: transient-mark-mode
     This variable if non-`nil' enables Transient Mark mode, in which
     every buffer-modifying primitive sets `deactivate-mark'.  The
     consequence of this is that commands that modify the buffer
     normally make the mark inactive.

     Lisp programs can set `transient-mark-mode' to `only' to enable
     Transient Mark mode for the following command only.  During that
     following command, the value of `transient-mark-mode' is
     `identity'.  If it is still `identity' at the end of the command,
     it changes to `nil'.

 -- User Option: mark-even-if-inactive
     If this is non-`nil', Lisp programs and the Emacs user can use the
     mark even when it is inactive.  This option affects the behavior of
     Transient Mark mode.  When the option is non-`nil', deactivation of
     the mark turns off region highlighting, but commands that use the
     mark behave as if the mark were still active.

 -- Variable: deactivate-mark
     If an editor command sets this variable non-`nil', then the editor
     command loop deactivates the mark after the command returns (if
     Transient Mark mode is enabled).  All the primitives that change
     the buffer set `deactivate-mark', to deactivate the mark when the
     command is finished.

     To write Lisp code that modifies the buffer without causing
     deactivation of the mark at the end of the command, bind
     `deactivate-mark' to `nil' around the code that does the
     modification.  For example:

          (let (deactivate-mark)
            (insert " "))

 -- Function: deactivate-mark
     This function deactivates the mark, if Transient Mark mode is
     enabled.  Otherwise it does nothing.

 -- Variable: mark-active
     The mark is active when this variable is non-`nil'.  This variable
     is always buffer-local in each buffer.

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     These normal hooks are run, respectively, when the mark becomes
     active and when it becomes inactive.  The hook
     `activate-mark-hook' is also run at the end of a command if the
     mark is active and it is possible that the region may have changed.

 -- Variable: mark-ring
     The value of this buffer-local variable is the list of saved former
     marks of the current buffer, most recent first.

          mark-ring
          => (#<marker at 11050 in markers.texi>
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     The value of this variable is the maximum size of `mark-ring'.  If
     more marks than this are pushed onto the `mark-ring', `push-mark'
     discards an old mark when it adds a new one.


File: elisp,  Node: The Region,  Prev: The Mark,  Up: Markers

31.8 The Region
===============

The text between point and the mark is known as "the region".  Various
functions operate on text delimited by point and the mark, but only
those functions specifically related to the region itself are described
here.

   The next two functions signal an error if the mark does not point
anywhere.  If Transient Mark mode is enabled and
`mark-even-if-inactive' is `nil', they also signal an error if the mark
is inactive.

 -- Function: region-beginning
     This function returns the position of the beginning of the region
     (as an integer).  This is the position of either point or the mark,
     whichever is smaller.

 -- Function: region-end
     This function returns the position of the end of the region (as an
     integer).  This is the position of either point or the mark,
     whichever is larger.

   Few programs need to use the `region-beginning' and `region-end'
functions.  A command designed to operate on a region should normally
use `interactive' with the `r' specification to find the beginning and
end of the region.  This lets other Lisp programs specify the bounds
explicitly as arguments.  (*Note Interactive Codes::.)


File: elisp,  Node: Text,  Next: Non-ASCII Characters,  Prev: Markers,  Up: Top

32 Text
*******

This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often operating at point or on text adjacent to point.  Many are
interactive.  All the functions that change the text provide for undoing
the changes (*note Undo::).

   Many text-related functions operate on a region of text defined by
two buffer positions passed in arguments named START and END.  These
arguments should be either markers (*note Markers::) or numeric
character positions (*note Positions::).  The order of these arguments
does not matter; it is all right for START to be the end of the region
and END the beginning.  For example, `(delete-region 1 10)' and
`(delete-region 10 1)' are equivalent.  An `args-out-of-range' error is
signaled if either START or END is outside the accessible portion of
the buffer.  In an interactive call, point and the mark are used for
these arguments.

   Throughout this chapter, "text" refers to the characters in the
buffer, together with their properties (when relevant).  Keep in mind
that point is always between two characters, and the cursor appears on
the character after point.

* Menu:

* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Base 64::          Conversion to or from base 64 encoding.
* MD5 Checksum::     Compute the MD5 "message digest"/"checksum".
* Atomic Changes::   Installing several buffer changes "atomically".
* Change Hooks::     Supplying functions to be run when text is changed.


File: elisp,  Node: Near Point,  Next: Buffer Contents,  Up: Text

32.1 Examining Text Near Point
==============================

Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also `looking-at' in
*note Regexp Search::.

   In the following four functions, "beginning" or "end" of buffer
refers to the beginning or end of the accessible portion.

 -- Function: char-after &optional position
     This function returns the character in the current buffer at (i.e.,
     immediately after) position POSITION.  If POSITION is out of range
     for this purpose, either before the beginning of the buffer, or at
     or beyond the end, then the value is `nil'.  The default for
     POSITION is point.

     In the following example, assume that the first character in the
     buffer is `@':

          (char-to-string (char-after 1))
               => "@"

 -- Function: char-before &optional position
     This function returns the character in the current buffer
     immediately before position POSITION.  If POSITION is out of range
     for this purpose, either at or before the beginning of the buffer,
     or beyond the end, then the value is `nil'.  The default for
     POSITION is point.

 -- Function: following-char
     This function returns the character following point in the current
     buffer.  This is similar to `(char-after (point))'.  However, if
     point is at the end of the buffer, then `following-char' returns 0.

     Remember that point is always between characters, and the cursor
     normally appears over the character following point.  Therefore,
     the character returned by `following-char' is the character the
     cursor is over.

     In this example, point is between the `a' and the `c'.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea-!-ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (char-to-string (preceding-char))
               => "a"
          (char-to-string (following-char))
               => "c"

 -- Function: preceding-char
     This function returns the character preceding point in the current
     buffer.  See above, under `following-char', for an example.  If
     point is at the beginning of the buffer, `preceding-char' returns
     0.

 -- Function: bobp
     This function returns `t' if point is at the beginning of the
     buffer.  If narrowing is in effect, this means the beginning of the
     accessible portion of the text.  See also `point-min' in *note
     Point::.

 -- Function: eobp
     This function returns `t' if point is at the end of the buffer.
     If narrowing is in effect, this means the end of accessible
     portion of the text.  See also `point-max' in *Note Point::.

 -- Function: bolp
     This function returns `t' if point is at the beginning of a line.
     *Note Text Lines::.  The beginning of the buffer (or of its
     accessible portion) always counts as the beginning of a line.

 -- Function: eolp
     This function returns `t' if point is at the end of a line.  The
     end of the buffer (or of its accessible portion) is always
     considered the end of a line.


File: elisp,  Node: Buffer Contents,  Next: Comparing Text,  Prev: Near Point,  Up: Text

32.2 Examining Buffer Contents
==============================

This section describes functions that allow a Lisp program to convert
any portion of the text in the buffer into a string.

 -- Function: buffer-substring start end
     This function returns a string containing a copy of the text of the
     region defined by positions START and END in the current buffer.
     If the arguments are not positions in the accessible portion of
     the buffer, `buffer-substring' signals an `args-out-of-range'
     error.

     It is not necessary for START to be less than END; the arguments
     can be given in either order.  But most often the smaller argument
     is written first.

     Here's an example which assumes Font-Lock mode is not enabled:

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
               => "This is t"
          (buffer-substring (point-max) 10)
               => "he contents of buffer foo\n"

     If the text being copied has any text properties, these are copied
     into the string along with the characters they belong to.  *Note
     Text Properties::.  However, overlays (*note Overlays::) in the
     buffer and their properties are ignored, not copied.

     For example, if Font-Lock mode is enabled, you might get results
     like these:

          (buffer-substring 1 10)
               => #("This is t" 0 1 (fontified t) 1 9 (fontified t))

 -- Function: buffer-substring-no-properties start end
     This is like `buffer-substring', except that it does not copy text
     properties, just the characters themselves.  *Note Text
     Properties::.

 -- Function: filter-buffer-substring start end &optional delete noprops
     This function passes the buffer text between START and END through
     the filter functions specified by the variable
     `buffer-substring-filters', and returns the value from the last
     filter function.  If `buffer-substring-filters' is `nil', the
     value is the unaltered text from the buffer, what
     `buffer-substring' would return.

     If DELETE is non-`nil', this function deletes the text between
     START and END after copying it, like `delete-and-extract-region'.

     If NOPROPS is non-`nil', the final string returned does not
     include text properties, while the string passed through the
     filters still includes text properties from the buffer text.

     Lisp code should use this function instead of `buffer-substring',
     `buffer-substring-no-properties', or `delete-and-extract-region'
     when copying into user-accessible data structures such as the
     kill-ring, X clipboard, and registers.  Major and minor modes can
     add functions to `buffer-substring-filters' to alter such text as
     it is copied out of the buffer.

 -- Variable: buffer-substring-filters
     This variable should be a list of functions that accept a single
     argument, a string, and return a string.
     `filter-buffer-substring' passes the buffer substring to the first
     function in this list, and the return value of each function is
     passed to the next function.  The return value of the last
     function is used as the return value of `filter-buffer-substring'.

     As a special convention, point is set to the start of the buffer
     text being operated on (i.e., the START argument for
     `filter-buffer-substring') before these functions are called.

     If this variable is `nil', no filtering is performed.

 -- Function: buffer-string
     This function returns the contents of the entire accessible
     portion of the current buffer as a string.  It is equivalent to

          (buffer-substring (point-min) (point-max))

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-string)
               => "This is the contents of buffer foo\n"

 -- Function: current-word &optional strict really-word
     This function returns the symbol (or word) at or near point, as a
     string.  The return value includes no text properties.

     If the optional argument REALLY-WORD is non-`nil', it finds a
     word; otherwise, it finds a symbol (which includes both word
     characters and symbol constituent characters).

     If the optional argument STRICT is non-`nil', then point must be
     in or next to the symbol or word--if no symbol or word is there,
     the function returns `nil'.  Otherwise, a nearby symbol or word on
     the same line is acceptable.

 -- Function: thing-at-point thing
     Return the THING around or next to point, as a string.

     The argument THING is a symbol which specifies a kind of syntactic
     entity.  Possibilities include `symbol', `list', `sexp', `defun',
     `filename', `url', `word', `sentence', `whitespace', `line',
     `page', and others.

          ---------- Buffer: foo ----------
          Gentlemen may cry ``Pea-!-ce! Peace!,''
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               => "Peace"
          (thing-at-point 'line)
               => "Gentlemen may cry ``Peace! Peace!,''\n"
          (thing-at-point 'whitespace)
               => nil


File: elisp,  Node: Comparing Text,  Next: Insertion,  Prev: Buffer Contents,  Up: Text

32.3 Comparing Text
===================

This function lets you compare portions of the text in a buffer, without
copying them into strings first.

 -- Function: compare-buffer-substrings buffer1 start1 end1 buffer2
          start2 end2
     This function lets you compare two substrings of the same buffer
     or two different buffers.  The first three arguments specify one
     substring, giving a buffer (or a buffer name) and two positions
     within the buffer.  The last three arguments specify the other
     substring in the same way.  You can use `nil' for BUFFER1,
     BUFFER2, or both to stand for the current buffer.

     The value is negative if the first substring is less, positive if
     the first is greater, and zero if they are equal.  The absolute
     value of the result is one plus the index of the first differing
     characters within the substrings.

     This function ignores case when comparing characters if
     `case-fold-search' is non-`nil'.  It always ignores text
     properties.

     Suppose the current buffer contains the text `foobarbar
     haha!rara!'; then in this example the two substrings are `rbar '
     and `rara!'.  The value is 2 because the first substring is greater
     at the second character.

          (compare-buffer-substrings nil 6 11 nil 16 21)
               => 2


File: elisp,  Node: Insertion,  Next: Commands for Insertion,  Prev: Comparing Text,  Up: Text

32.4 Inserting Text
===================

"Insertion" means adding new text to a buffer.  The inserted text goes
at point--between the character before point and the character after
point.  Some insertion functions leave point before the inserted text,
while other functions leave it after.  We call the former insertion
"after point" and the latter insertion "before point".

   Insertion relocates markers that point at positions after the
insertion point, so that they stay with the surrounding text (*note
Markers::).  When a marker points at the place of insertion, insertion
may or may not relocate the marker, depending on the marker's insertion
type (*note Marker Insertion Types::).  Certain special functions such
as `insert-before-markers' relocate all such markers to point after the
inserted text, regardless of the markers' insertion type.

   Insertion functions signal an error if the current buffer is
read-only or if they insert within read-only text.

   These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

   The insertion functions convert text from unibyte to multibyte in
order to insert in a multibyte buffer, and vice versa--if the text
comes from a string or from a buffer.  However, they do not convert
unibyte character codes 128 through 255 to multibyte characters, not
even if the current buffer is a multibyte buffer.  *Note Converting
Representations::.

 -- Function: insert &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  In other words, it
     inserts the text before point.  An error is signaled unless all
     ARGS are either strings or characters.  The value is `nil'.

 -- Function: insert-before-markers &rest args
     This function inserts the strings and/or characters ARGS into the
     current buffer, at point, moving point forward.  An error is
     signaled unless all ARGS are either strings or characters.  The
     value is `nil'.

     This function is unlike the other insertion functions in that it
     relocates markers initially pointing at the insertion point, to
     point after the inserted text.  If an overlay begins at the
     insertion point, the inserted text falls outside the overlay; if a
     nonempty overlay ends at the insertion point, the inserted text
     falls inside that overlay.

 -- Function: insert-char character count &optional inherit
     This function inserts COUNT instances of CHARACTER into the
     current buffer before point.  The argument COUNT should be an
     integer, and CHARACTER must be a character.  The value is `nil'.

     This function does not convert unibyte character codes 128 through
     255 to multibyte characters, not even if the current buffer is a
     multibyte buffer.  *Note Converting Representations::.

     If INHERIT is non-`nil', then the inserted characters inherit
     sticky text properties from the two characters before and after the
     insertion point.  *Note Sticky Properties::.

 -- Function: insert-buffer-substring from-buffer-or-name &optional
          start end
     This function inserts a portion of buffer FROM-BUFFER-OR-NAME
     (which must already exist) into the current buffer before point.
     The text inserted is the region between START and END.  (These
     arguments default to the beginning and end of the accessible
     portion of that buffer.)  This function returns `nil'.

     In this example, the form is executed with buffer `bar' as the
     current buffer.  We assume that buffer `bar' is initially empty.

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               => nil

          ---------- Buffer: bar ----------
          We hold these truth-!-
          ---------- Buffer: bar ----------

 -- Function: insert-buffer-substring-no-properties from-buffer-or-name
          &optional start end
     This is like `insert-buffer-substring' except that it does not
     copy any text properties.

   *Note Sticky Properties::, for other insertion functions that inherit
text properties from the nearby text in addition to inserting it.
Whitespace inserted by indentation functions also inherits text
properties.


File: elisp,  Node: Commands for Insertion,  Next: Deletion,  Prev: Insertion,  Up: Text

32.5 User-Level Insertion Commands
==================================

This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

 -- Command: insert-buffer from-buffer-or-name
     This command inserts the entire accessible contents of
     FROM-BUFFER-OR-NAME (which must exist) into the current buffer
     after point.  It leaves the mark after the inserted text.  The
     value is `nil'.

 -- Command: self-insert-command count
     This command inserts the last character typed; it does so COUNT
     times, before point, and returns `nil'.  Most printing characters
     are bound to this command.  In routine use, `self-insert-command'
     is the most frequently called function in Emacs, but programs
     rarely use it except to install it on a keymap.

     In an interactive call, COUNT is the numeric prefix argument.

     Self-insertion translates the input character through
     `translation-table-for-input'.  *Note Translation of Characters::.

     This command calls `auto-fill-function' whenever that is non-`nil'
     and the character inserted is in the table `auto-fill-chars'
     (*note Auto Filling::).

     This command performs abbrev expansion if Abbrev mode is enabled
     and the inserted character does not have word-constituent syntax.
     (*Note Abbrevs::, and *note Syntax Class Table::.)  It is also
     responsible for calling `blink-paren-function' when the inserted
     character has close parenthesis syntax (*note Blinking::).

     Do not try substituting your own definition of
     `self-insert-command' for the standard one.  The editor command
     loop handles this function specially.

 -- Command: newline &optional number-of-newlines
     This command inserts newlines into the current buffer before point.
     If NUMBER-OF-NEWLINES is supplied, that many newline characters
     are inserted.

     This function calls `auto-fill-function' if the current column
     number is greater than the value of `fill-column' and
     NUMBER-OF-NEWLINES is `nil'.  Typically what `auto-fill-function'
     does is insert a newline; thus, the overall result in this case is
     to insert two newlines at different places: one at point, and
     another earlier in the line.  `newline' does not auto-fill if
     NUMBER-OF-NEWLINES is non-`nil'.

     This command indents to the left margin if that is not zero.
     *Note Margins::.

     The value returned is `nil'.  In an interactive call, COUNT is the
     numeric prefix argument.

 -- Variable: overwrite-mode
     This variable controls whether overwrite mode is in effect.  The
     value should be `overwrite-mode-textual', `overwrite-mode-binary',
     or `nil'.  `overwrite-mode-textual' specifies textual overwrite
     mode (treats newlines and tabs specially), and
     `overwrite-mode-binary' specifies binary overwrite mode (treats
     newlines and tabs like any other characters).


File: elisp,  Node: Deletion,  Next: User-Level Deletion,  Prev: Commands for Insertion,  Up: Text

32.6 Deleting Text
==================

Deletion means removing part of the text in a buffer, without saving it
in the kill ring (*note The Kill Ring::).  Deleted text can't be
yanked, but can be reinserted using the undo mechanism (*note Undo::).
Some deletion functions do save text in the kill ring in some special
cases.

   All of the deletion functions operate on the current buffer.

 -- Command: erase-buffer
     This function deletes the entire text of the current buffer (_not_
     just the accessible portion), leaving it empty.  If the buffer is
     read-only, it signals a `buffer-read-only' error; if some of the
     text in it is read-only, it signals a `text-read-only' error.
     Otherwise, it deletes the text without asking for any
     confirmation.  It returns `nil'.

     Normally, deleting a large amount of text from a buffer inhibits
     further auto-saving of that buffer "because it has shrunk."
     However, `erase-buffer' does not do this, the idea being that the
     future text is not really related to the former text, and its size
     should not be compared with that of the former text.

 -- Command: delete-region start end
     This command deletes the text between positions START and END in
     the current buffer, and returns `nil'.  If point was inside the
     deleted region, its value afterward is START.  Otherwise, point
     relocates with the surrounding text, as markers do.

 -- Function: delete-and-extract-region start end
     This function deletes the text between positions START and END in
     the current buffer, and returns a string containing the text just
     deleted.

     If point was inside the deleted region, its value afterward is
     START.  Otherwise, point relocates with the surrounding text, as
     markers do.

 -- Command: delete-char count &optional killp
     This command deletes COUNT characters directly after point, or
     before point if COUNT is negative.  If KILLP is non-`nil', then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but
     not saved in the kill ring.

     The value returned is always `nil'.

 -- Command: delete-backward-char count &optional killp
     This command deletes COUNT characters directly before point, or
     after point if COUNT is negative.  If KILLP is non-`nil', then it
     saves the deleted characters in the kill ring.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but
     not saved in the kill ring.

     The value returned is always `nil'.

 -- Command: backward-delete-char-untabify count &optional killp
     This command deletes COUNT characters backward, changing tabs into
     spaces.  When the next character to be deleted is a tab, it is
     first replaced with the proper number of spaces to preserve
     alignment and then one of those spaces is deleted instead of the
     tab.  If KILLP is non-`nil', then the command saves the deleted
     characters in the kill ring.

     Conversion of tabs to spaces happens only if COUNT is positive.
     If it is negative, exactly -COUNT characters after point are
     deleted.

     In an interactive call, COUNT is the numeric prefix argument, and
     KILLP is the unprocessed prefix argument.  Therefore, if a prefix
     argument is supplied, the text is saved in the kill ring.  If no
     prefix argument is supplied, then one character is deleted, but
     not saved in the kill ring.

     The value returned is always `nil'.

 -- User Option: backward-delete-char-untabify-method
     This option specifies how `backward-delete-char-untabify' should
     deal with whitespace.  Possible values include `untabify', the
     default, meaning convert a tab to many spaces and delete one;
     `hungry', meaning delete all tabs and spaces before point with one
     command; `all' meaning delete all tabs, spaces and newlines before
     point, and `nil', meaning do nothing special for whitespace
     characters.


File: elisp,  Node: User-Level Deletion,  Next: The Kill Ring,  Prev: Deletion,  Up: Text

32.7 User-Level Deletion Commands
=================================

This section describes higher-level commands for deleting text,
commands intended primarily for the user but useful also in Lisp
programs.

 -- Command: delete-horizontal-space &optional backward-only
     This function deletes all spaces and tabs around point.  It returns
     `nil'.

     If BACKWARD-ONLY is non-`nil', the function deletes spaces and
     tabs before point, but not after point.

     In the following examples, we call `delete-horizontal-space' four
     times, once on each line, with point between the second and third
     characters on the line each time.

          ---------- Buffer: foo ----------
          I -!-thought
          I -!-     thought
          We-!- thought
          Yo-!-u thought
          ---------- Buffer: foo ----------

          (delete-horizontal-space)   ; Four times.
               => nil

          ---------- Buffer: foo ----------
          Ithought
          Ithought
          Wethought
          You thought
          ---------- Buffer: foo ----------

 -- Command: delete-indentation &optional join-following-p
     This function joins the line point is on to the previous line,
     deleting any whitespace at the join and in some cases replacing it
     with one space.  If JOIN-FOLLOWING-P is non-`nil',
     `delete-indentation' joins this line to the following line
     instead.  The function returns `nil'.

     If there is a fill prefix, and the second of the lines being joined
     starts with the prefix, then `delete-indentation' deletes the fill
     prefix before joining the lines.  *Note Margins::.

     In the example below, point is located on the line starting
     `events', and it makes no difference if there are trailing spaces
     in the preceding line.

          ---------- Buffer: foo ----------
          When in the course of human
          -!-    events, it becomes necessary
          ---------- Buffer: foo ----------

          (delete-indentation)
               => nil

          ---------- Buffer: foo ----------
          When in the course of human-!- events, it becomes necessary
          ---------- Buffer: foo ----------

     After the lines are joined, the function `fixup-whitespace' is
     responsible for deciding whether to leave a space at the junction.

 -- Command: fixup-whitespace
     This function replaces all the horizontal whitespace surrounding
     point with either one space or no space, according to the context.
     It returns `nil'.

     At the beginning or end of a line, the appropriate amount of space
     is none.  Before a character with close parenthesis syntax, or
     after a character with open parenthesis or expression-prefix
     syntax, no space is also appropriate.  Otherwise, one space is
     appropriate.  *Note Syntax Class Table::.

     In the example below, `fixup-whitespace' is called the first time
     with point before the word `spaces' in the first line.  For the
     second invocation, point is directly after the `('.

          ---------- Buffer: foo ----------
          This has too many     -!-spaces
          This has too many spaces at the start of (-!-   this list)
          ---------- Buffer: foo ----------

          (fixup-whitespace)
               => nil
          (fixup-whitespace)
               => nil

          ---------- Buffer: foo ----------
          This has too many spaces
          This has too many spaces at the start of (this list)
          ---------- Buffer: foo ----------

 -- Command: just-one-space &optional n
     This command replaces any spaces and tabs around point with a
     single space, or N spaces if N is specified.  It returns `nil'.

 -- Command: delete-blank-lines
     This function deletes blank lines surrounding point.  If point is
     on a blank line with one or more blank lines before or after it,
     then all but one of them are deleted.  If point is on an isolated
     blank line, then it is deleted.  If point is on a nonblank line,
     the command deletes all blank lines immediately following it.

     A blank line is defined as a line containing only tabs and spaces.

     `delete-blank-lines' returns `nil'.


File: elisp,  Node: The Kill Ring,  Next: Undo,  Prev: User-Level Deletion,  Up: Text

32.8 The Kill Ring
==================

"Kill functions" delete text like the deletion functions, but save it
so that the user can reinsert it by "yanking".  Most of these functions
have `kill-' in their name.  By contrast, the functions whose names
start with `delete-' normally do not save text for yanking (though they
can still be undone); these are "deletion" functions.

   Most of the kill commands are primarily for interactive use, and are
not described here.  What we do describe are the functions provided for
use in writing such commands.  You can use these functions to write
commands for killing text.  When you need to delete text for internal
purposes within a Lisp function, you should normally use deletion
functions, so as not to disturb the kill ring contents.  *Note
Deletion::.

   Killed text is saved for later yanking in the "kill ring".  This is
a list that holds a number of recent kills, not just the last text
kill.  We call this a "ring" because yanking treats it as having
elements in a cyclic order.  The list is kept in the variable
`kill-ring', and can be operated on with the usual functions for lists;
there are also specialized functions, described in this section, that
treat it as a ring.

   Some people think this use of the word "kill" is unfortunate, since
it refers to operations that specifically _do not_ destroy the entities
"killed."  This is in sharp contrast to ordinary life, in which death
is permanent and "killed" entities do not come back to life.
Therefore, other metaphors have been proposed.  For example, the term
"cut ring" makes sense to people who, in pre-computer days, used
scissors and paste to cut up and rearrange manuscripts.  However, it
would be difficult to change the terminology now.

* Menu:

* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yanking::                How yanking is done.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill ring data.


File: elisp,  Node: Kill Ring Concepts,  Next: Kill Functions,  Up: The Kill Ring

32.8.1 Kill Ring Concepts
-------------------------

The kill ring records killed text as strings in a list, most recent
first.  A short kill ring, for example, might look like this:

     ("some text" "a different piece of text" "even older text")

When the list reaches `kill-ring-max' entries in length, adding a new
entry automatically deletes the last entry.

   When kill commands are interwoven with other commands, each kill
command makes a new entry in the kill ring.  Multiple kill commands in
succession build up a single kill ring entry, which would be yanked as a
unit; the second and subsequent consecutive kill commands add text to
the entry made by the first one.

   For yanking, one entry in the kill ring is designated the "front" of
the ring.  Some yank commands "rotate" the ring by designating a
different element as the "front."  But this virtual rotation doesn't
change the list itself--the most recent entry always comes first in the
list.


File: elisp,  Node: Kill Functions,  Next: Yanking,  Prev: Kill Ring Concepts,  Up: The Kill Ring

32.8.2 Functions for Killing
----------------------------

`kill-region' is the usual subroutine for killing text.  Any command
that calls this function is a "kill command" (and should probably have
`kill' in its name).  `kill-region' puts the newly killed text in a new
element at the beginning of the kill ring or adds it to the most recent
element.  It determines automatically (using `last-command') whether
the previous command was a kill command, and if so appends the killed
text to the most recent entry.

 -- Command: kill-region start end &optional yank-handler
     This function kills the text in the region defined by START and
     END.  The text is deleted but saved in the kill ring, along with
     its text properties.  The value is always `nil'.

     In an interactive call, START and END are point and the mark.

     If the buffer or text is read-only, `kill-region' modifies the kill
     ring just the same, then signals an error without modifying the
     buffer.  This is convenient because it lets the user use a series
     of kill commands to copy text from a read-only buffer into the
     kill ring.

     If YANK-HANDLER is non-`nil', this puts that value onto the string
     of killed text, as a `yank-handler' text property.  *Note
     Yanking::.  Note that if YANK-HANDLER is `nil', any `yank-handler'
     properties present on the killed text are copied onto the kill
     ring, like other text properties.

 -- User Option: kill-read-only-ok
     If this option is non-`nil', `kill-region' does not signal an
     error if the buffer or text is read-only.  Instead, it simply
     returns, updating the kill ring but not changing the buffer.

 -- Command: copy-region-as-kill start end
     This command saves the region defined by START and END on the kill
     ring (including text properties), but does not delete the text
     from the buffer.  It returns `nil'.

     The command does not set `this-command' to `kill-region', so a
     subsequent kill command does not append to the same kill ring
     entry.

     Don't call `copy-region-as-kill' in Lisp programs unless you aim to
     support Emacs 18.  For newer Emacs versions, it is better to use
     `kill-new' or `kill-append' instead.  *Note Low-Level Kill Ring::.


File: elisp,  Node: Yanking,  Next: Yank Commands,  Prev: Kill Functions,  Up: The Kill Ring

32.8.3 Yanking
--------------

Yanking means inserting text from the kill ring, but it does not insert
the text blindly.  Yank commands and some other commands use
`insert-for-yank' to perform special processing on the text that they
copy into the buffer.

 -- Function: insert-for-yank string
     This function normally works like `insert' except that it doesn't
     insert the text properties in the `yank-excluded-properties' list.
     However, if any part of STRING has a non-`nil' `yank-handler' text
     property, that property can do various special processing on that
     part of the text being inserted.

 -- Function: insert-buffer-substring-as-yank buf &optional start end
     This function resembles `insert-buffer-substring' except that it
     doesn't insert the text properties in the
     `yank-excluded-properties' list.

   You can put a `yank-handler' text property on all or part of the
text to control how it will be inserted if it is yanked.  The
`insert-for-yank' function looks for that property.  The property value
must be a list of one to four elements, with the following format
(where elements after the first may be omitted):

     (FUNCTION PARAM NOEXCLUDE UNDO)

   Here is what the elements do:

FUNCTION
     When FUNCTION is present and non-`nil', it is called instead of
     `insert' to insert the string.  FUNCTION takes one argument--the
     string to insert.

PARAM
     If PARAM is present and non-`nil', it replaces STRING (or the part
     of STRING being processed) as the object passed to FUNCTION (or
     `insert'); for example, if FUNCTION is `yank-rectangle', PARAM
     should be a list of strings to insert as a rectangle.

NOEXCLUDE
     If NOEXCLUDE is present and non-`nil', the normal removal of the
     yank-excluded-properties is not performed; instead FUNCTION is
     responsible for removing those properties.  This may be necessary
     if FUNCTION adjusts point before or after inserting the object.

UNDO
     If UNDO is present and non-`nil', it is a function that will be
     called by `yank-pop' to undo the insertion of the current object.
     It is called with two arguments, the start and end of the current
     region.  FUNCTION can set `yank-undo-function' to override the
     UNDO value.


File: elisp,  Node: Yank Commands,  Next: Low-Level Kill Ring,  Prev: Yanking,  Up: The Kill Ring

32.8.4 Functions for Yanking
----------------------------

This section describes higher-level commands for yanking, which are
intended primarily for the user but useful also in Lisp programs.  Both
`yank' and `yank-pop' honor the `yank-excluded-properties' variable and
`yank-handler' text property (*note Yanking::).

 -- Command: yank &optional arg
     This command inserts before point the text at the front of the
     kill ring.  It positions the mark at the beginning of that text,
     and point at the end.

     If ARG is a non-`nil' list (which occurs interactively when the
     user types `C-u' with no digits), then `yank' inserts the text as
     described above, but puts point before the yanked text and puts
     the mark after it.

     If ARG is a number, then `yank' inserts the ARGth most recently
     killed text--the ARGth element of the kill ring list, counted
     cyclically from the front, which is considered the first element
     for this purpose.

     `yank' does not alter the contents of the kill ring, unless it
     used text provided by another program, in which case it pushes
     that text onto the kill ring.  However if ARG is an integer
     different from one, it rotates the kill ring to place the yanked
     string at the front.

     `yank' returns `nil'.

 -- Command: yank-pop &optional arg
     This command replaces the just-yanked entry from the kill ring
     with a different entry from the kill ring.

     This is allowed only immediately after a `yank' or another
     `yank-pop'.  At such a time, the region contains text that was just
     inserted by yanking.  `yank-pop' deletes that text and inserts in
     its place a different piece of killed text.  It does not add the
     deleted text to the kill ring, since it is already in the kill
     ring somewhere.  It does however rotate the kill ring to place the
     newly yanked string at the front.

     If ARG is `nil', then the replacement text is the previous element
     of the kill ring.  If ARG is numeric, the replacement is the ARGth
     previous kill.  If ARG is negative, a more recent kill is the
     replacement.

     The sequence of kills in the kill ring wraps around, so that after
     the oldest one comes the newest one, and before the newest one
     goes the oldest.

     The return value is always `nil'.

 -- Variable: yank-undo-function
     If this variable is non-`nil', the function `yank-pop' uses its
     value instead of `delete-region' to delete the text inserted by
     the previous `yank' or `yank-pop' command.  The value must be a
     function of two arguments, the start and end of the current region.

     The function `insert-for-yank' automatically sets this variable
     according to the UNDO element of the `yank-handler' text property,
     if there is one.


File: elisp,  Node: Low-Level Kill Ring,  Next: Internals of Kill Ring,  Prev: Yank Commands,  Up: The Kill Ring

32.8.5 Low-Level Kill Ring
--------------------------

These functions and variables provide access to the kill ring at a
lower level, but still convenient for use in Lisp programs, because they
take care of interaction with window system selections (*note Window
System Selections::).

 -- Function: current-kill n &optional do-not-move
     The function `current-kill' rotates the yanking pointer, which
     designates the "front" of the kill ring, by N places (from newer
     kills to older ones), and returns the text at that place in the
     ring.

     If the optional second argument DO-NOT-MOVE is non-`nil', then
     `current-kill' doesn't alter the yanking pointer; it just returns
     the Nth kill, counting from the current yanking pointer.

     If N is zero, indicating a request for the latest kill,
     `current-kill' calls the value of `interprogram-paste-function'
     (documented below) before consulting the kill ring.  If that value
     is a function and calling it returns a string, `current-kill'
     pushes that string onto the kill ring and returns it.  It also
     sets the yanking pointer to point to that new entry, regardless of
     the value of DO-NOT-MOVE.  Otherwise, `current-kill' does not
     treat a zero value for N specially: it returns the entry pointed
     at by the yanking pointer and does not move the yanking pointer.

 -- Function: kill-new string &optional replace yank-handler
     This function pushes the text STRING onto the kill ring and makes
     the yanking pointer point to it.  It discards the oldest entry if
     appropriate.  It also invokes the value of
     `interprogram-cut-function' (see below).

     If REPLACE is non-`nil', then `kill-new' replaces the first
     element of the kill ring with STRING, rather than pushing STRING
     onto the kill ring.

     If YANK-HANDLER is non-`nil', this puts that value onto the string
     of killed text, as a `yank-handler' property.  *Note Yanking::.
     Note that if YANK-HANDLER is `nil', then `kill-new' copies any
     `yank-handler' properties present on STRING onto the kill ring, as
     it does with other text properties.

 -- Function: kill-append string before-p &optional yank-handler
     This function appends the text STRING to the first entry in the
     kill ring and makes the yanking pointer point to the combined
     entry.  Normally STRING goes at the end of the entry, but if
     BEFORE-P is non-`nil', it goes at the beginning.  This function
     also invokes the value of `interprogram-cut-function' (see below).
     This handles YANK-HANDLER just like `kill-new', except that if
     YANK-HANDLER is different from the `yank-handler' property of the
     first entry of the kill ring, `kill-append' pushes the
     concatenated string onto the kill ring, instead of replacing the
     original first entry with it.

 -- Variable: interprogram-paste-function
     This variable provides a way of transferring killed text from other
     programs, when you are using a window system.  Its value should be
     `nil' or a function of no arguments.

     If the value is a function, `current-kill' calls it to get the
     "most recent kill."  If the function returns a non-`nil' value,
     then that value is used as the "most recent kill."  If it returns
     `nil', then the front of the kill ring is used.

     The normal use of this hook is to get the window system's primary
     selection as the most recent kill, even if the selection belongs to
     another application.  *Note Window System Selections::.

 -- Variable: interprogram-cut-function
     This variable provides a way of communicating killed text to other
     programs, when you are using a window system.  Its value should be
     `nil' or a function of one required and one optional argument.

     If the value is a function, `kill-new' and `kill-append' call it
     with the new first element of the kill ring as the first argument.
     The second, optional, argument has the same meaning as the PUSH
     argument to `x-set-cut-buffer' (*note Definition of
     x-set-cut-buffer::) and only affects the second and later cut
     buffers.

     The normal use of this hook is to set the window system's primary
     selection (and first cut buffer) from the newly killed text.
     *Note Window System Selections::.


File: elisp,  Node: Internals of Kill Ring,  Prev: Low-Level Kill Ring,  Up: The Kill Ring

32.8.6 Internals of the Kill Ring
---------------------------------

The variable `kill-ring' holds the kill ring contents, in the form of a
list of strings.  The most recent kill is always at the front of the
list.

   The `kill-ring-yank-pointer' variable points to a link in the kill
ring list, whose CAR is the text to yank next.  We say it identifies
the "front" of the ring.  Moving `kill-ring-yank-pointer' to a
different link is called "rotating the kill ring".  We call the kill
ring a "ring" because the functions that move the yank pointer wrap
around from the end of the list to the beginning, or vice-versa.
Rotation of the kill ring is virtual; it does not change the value of
`kill-ring'.

   Both `kill-ring' and `kill-ring-yank-pointer' are Lisp variables
whose values are normally lists.  The word "pointer" in the name of the
`kill-ring-yank-pointer' indicates that the variable's purpose is to
identify one element of the list for use by the next yank command.

   The value of `kill-ring-yank-pointer' is always `eq' to one of the
links in the kill ring list.  The element it identifies is the CAR of
that link.  Kill commands, which change the kill ring, also set this
variable to the value of `kill-ring'.  The effect is to rotate the ring
so that the newly killed text is at the front.

   Here is a diagram that shows the variable `kill-ring-yank-pointer'
pointing to the second entry in the kill ring `("some text" "a
different piece of text" "yet older text")'.

     kill-ring                  ---- kill-ring-yank-pointer
       |                       |
       |                       v
       |     --- ---          --- ---      --- ---
        --> |   |   |------> |   |   |--> |   |   |--> nil
             --- ---          --- ---      --- ---
              |                |            |
              |                |            |
              |                |             -->"yet older text"
              |                |
              |                 --> "a different piece of text"
              |
               --> "some text"

This state of affairs might occur after `C-y' (`yank') immediately
followed by `M-y' (`yank-pop').

 -- Variable: kill-ring
     This variable holds the list of killed text sequences, most
     recently killed first.

 -- Variable: kill-ring-yank-pointer
     This variable's value indicates which element of the kill ring is
     at the "front" of the ring for yanking.  More precisely, the value
     is a tail of the value of `kill-ring', and its CAR is the kill
     string that `C-y' should yank.

 -- User Option: kill-ring-max
     The value of this variable is the maximum length to which the kill
     ring can grow, before elements are thrown away at the end.  The
     default value for `kill-ring-max' is 60.


File: elisp,  Node: Undo,  Next: Maintaining Undo,  Prev: The Kill Ring,  Up: Text

32.9 Undo
=========

Most buffers have an "undo list", which records all changes made to the
buffer's text so that they can be undone.  (The buffers that don't have
one are usually special-purpose buffers for which Emacs assumes that
undoing is not useful.  In particular, any buffer whose name begins
with a space has its undo recording off by default; see *note Buffer
Names::.)  All the primitives that modify the text in the buffer
automatically add elements to the front of the undo list, which is in
the variable `buffer-undo-list'.

 -- Variable: buffer-undo-list
     This buffer-local variable's value is the undo list of the current
     buffer. A value of `t' disables the recording of undo information.

   Here are the kinds of elements an undo list can have:

`POSITION'
     This kind of element records a previous value of point; undoing
     this element moves point to POSITION.  Ordinary cursor motion does
     not make any sort of undo record, but deletion operations use
     these entries to record where point was before the command.

`(BEG . END)'
     This kind of element indicates how to delete text that was
     inserted.  Upon insertion, the text occupied the range BEG-END in
     the buffer.

`(TEXT . POSITION)'
     This kind of element indicates how to reinsert text that was
     deleted.  The deleted text itself is the string TEXT.  The place to
     reinsert it is `(abs POSITION)'.  If POSITION is positive, point
     was at the beginning of the deleted text, otherwise it was at the
     end.

`(t HIGH . LOW)'
     This kind of element indicates that an unmodified buffer became
     modified.  The elements HIGH and LOW are two integers, each
     recording 16 bits of the visited file's modification time as of
     when it was previously visited or saved.  `primitive-undo' uses
     those values to determine whether to mark the buffer as unmodified
     once again; it does so only if the file's modification time
     matches those numbers.

`(nil PROPERTY VALUE BEG . END)'
     This kind of element records a change in a text property.  Here's
     how you might undo the change:

          (put-text-property BEG END PROPERTY VALUE)

`(MARKER . ADJUSTMENT)'
     This kind of element records the fact that the marker MARKER was
     relocated due to deletion of surrounding text, and that it moved
     ADJUSTMENT character positions.  Undoing this element moves MARKER
     - ADJUSTMENT characters.

`(apply FUNNAME . ARGS)'
     This is an extensible undo item, which is undone by calling
     FUNNAME with arguments ARGS.

`(apply DELTA BEG END FUNNAME . ARGS)'
     This is an extensible undo item, which records a change limited to
     the range BEG to END, which increased the size of the buffer by
     DELTA.  It is undone by calling FUNNAME with arguments ARGS.

     This kind of element enables undo limited to a region to determine
     whether the element pertains to that region.

`nil'
     This element is a boundary.  The elements between two boundaries
     are called a "change group"; normally, each change group
     corresponds to one keyboard command, and undo commands normally
     undo an entire group as a unit.

 -- Function: undo-boundary
     This function places a boundary element in the undo list.  The undo
     command stops at such a boundary, and successive undo commands undo
     to earlier and earlier boundaries.  This function returns `nil'.

     The editor command loop automatically creates an undo boundary
     before each key sequence is executed.  Thus, each undo normally
     undoes the effects of one command.  Self-inserting input
     characters are an exception.  The command loop makes a boundary
     for the first such character; the next 19 consecutive
     self-inserting input characters do not make boundaries, and then
     the 20th does, and so on as long as self-inserting characters
     continue.

     All buffer modifications add a boundary whenever the previous
     undoable change was made in some other buffer.  This is to ensure
     that each command makes a boundary in each buffer where it makes
     changes.

     Calling this function explicitly is useful for splitting the
     effects of a command into more than one unit.  For example,
     `query-replace' calls `undo-boundary' after each replacement, so
     that the user can undo individual replacements one by one.

 -- Variable: undo-in-progress
     This variable is normally `nil', but the undo commands bind it to
     `t'.  This is so that various kinds of change hooks can tell when
     they're being called for the sake of undoing.

 -- Function: primitive-undo count list
     This is the basic function for undoing elements of an undo list.
     It undoes the first COUNT elements of LIST, returning the rest of
     LIST.

     `primitive-undo' adds elements to the buffer's undo list when it
     changes the buffer.  Undo commands avoid confusion by saving the
     undo list value at the beginning of a sequence of undo operations.
     Then the undo operations use and update the saved value.  The new
     elements added by undoing are not part of this saved value, so
     they don't interfere with continuing to undo.

     This function does not bind `undo-in-progress'.


File: elisp,  Node: Maintaining Undo,  Next: Filling,  Prev: Undo,  Up: Text

32.10 Maintaining Undo Lists
============================

This section describes how to enable and disable undo information for a
given buffer.  It also explains how the undo list is truncated
automatically so it doesn't get too big.

   Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
`buffer-undo-list' yourself.

 -- Command: buffer-enable-undo &optional buffer-or-name
     This command enables recording undo information for buffer
     BUFFER-OR-NAME, so that subsequent changes can be undone.  If no
     argument is supplied, then the current buffer is used.  This
     function does nothing if undo recording is already enabled in the
     buffer.  It returns `nil'.

     In an interactive call, BUFFER-OR-NAME is the current buffer.  You
     cannot specify any other buffer.

 -- Command: buffer-disable-undo &optional buffer-or-name
     This function discards the undo list of BUFFER-OR-NAME, and
     disables further recording of undo information.  As a result, it
     is no longer possible to undo either previous changes or any
     subsequent changes.  If the undo list of BUFFER-OR-NAME is already
     disabled, this function has no effect.

     This function returns `nil'.

   As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the "size" of
an undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Three variables control the range of
acceptable sizes: `undo-limit', `undo-strong-limit' and
`undo-outer-limit'.  In these variables, size is counted as the number
of bytes occupied, which includes both saved text and other data.

 -- User Option: undo-limit
     This is the soft limit for the acceptable size of an undo list.
     The change group at which this size is exceeded is the last one
     kept.

 -- User Option: undo-strong-limit
     This is the upper limit for the acceptable size of an undo list.
     The change group at which this size is exceeded is discarded
     itself (along with all older change groups).  There is one
     exception: the very latest change group is only discarded if it
     exceeds `undo-outer-limit'.

 -- User Option: undo-outer-limit
     If at garbage collection time the undo info for the current command
     exceeds this limit, Emacs discards the info and displays a warning.
     This is a last ditch limit to prevent memory overflow.

 -- User Option: undo-ask-before-discard
     If this variable is non-`nil', when the undo info exceeds
     `undo-outer-limit', Emacs asks in the echo area whether to discard
     the info.  The default value is `nil', which means to discard it
     automatically.

     This option is mainly intended for debugging.  Garbage collection
     is inhibited while the question is asked, which means that Emacs
     might leak memory if the user waits too long before answering the
     question.


File: elisp,  Node: Filling,  Next: Margins,  Prev: Maintaining Undo,  Up: Text

32.11 Filling
=============

"Filling" means adjusting the lengths of lines (by moving the line
breaks) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be "justified", which means
inserting spaces to make the left and/or right margins line up
precisely.  The width is controlled by the variable `fill-column'.  For
ease of reading, lines should be no longer than 70 or so columns.

   You can use Auto Fill mode (*note Auto Filling::) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

   Most of the commands in this section return values that are not
meaningful.  All the functions that do filling take note of the current
left margin, current right margin, and current justification style
(*note Margins::).  If the current justification style is `none', the
filling functions don't actually do anything.

   Several of the filling functions have an argument JUSTIFY.  If it is
non-`nil', that requests some kind of justification.  It can be `left',
`right', `full', or `center', to request a specific style of
justification.  If it is `t', that means to use the current
justification style for this part of the text (see
`current-justification', below).  Any other value is treated as `full'.

   When you call the filling functions interactively, using a prefix
argument implies the value `full' for JUSTIFY.

 -- Command: fill-paragraph justify
     This command fills the paragraph at or after point.  If JUSTIFY is
     non-`nil', each line is justified as well.  It uses the ordinary
     paragraph motion commands to find paragraph boundaries.  *Note
     Paragraphs: (emacs)Paragraphs.

 -- Command: fill-region start end &optional justify nosqueeze to-eop
     This command fills each of the paragraphs in the region from START
     to END.  It justifies as well if JUSTIFY is non-`nil'.

     If NOSQUEEZE is non-`nil', that means to leave whitespace other
     than line breaks untouched.  If TO-EOP is non-`nil', that means to
     keep filling to the end of the paragraph--or the next hard
     newline, if `use-hard-newlines' is enabled (see below).

     The variable `paragraph-separate' controls how to distinguish
     paragraphs.  *Note Standard Regexps::.

 -- Command: fill-individual-paragraphs start end &optional justify
          citation-regexp
     This command fills each paragraph in the region according to its
     individual fill prefix.  Thus, if the lines of a paragraph were
     indented with spaces, the filled paragraph will remain indented in
     the same fashion.

     The first two arguments, START and END, are the beginning and end
     of the region to be filled.  The third and fourth arguments,
     JUSTIFY and CITATION-REGEXP, are optional.  If JUSTIFY is
     non-`nil', the paragraphs are justified as well as filled.  If
     CITATION-REGEXP is non-`nil', it means the function is operating
     on a mail message and therefore should not fill the header lines.
     If CITATION-REGEXP is a string, it is used as a regular
     expression; if it matches the beginning of a line, that line is
     treated as a citation marker.

     Ordinarily, `fill-individual-paragraphs' regards each change in
     indentation as starting a new paragraph.  If
     `fill-individual-varying-indent' is non-`nil', then only separator
     lines separate paragraphs.  That mode can handle indented
     paragraphs with additional indentation on the first line.

 -- User Option: fill-individual-varying-indent
     This variable alters the action of `fill-individual-paragraphs' as
     described above.

 -- Command: fill-region-as-paragraph start end &optional justify
          nosqueeze squeeze-after
     This command considers a region of text as a single paragraph and
     fills it.  If the region was made up of many paragraphs, the blank
     lines between paragraphs are removed.  This function justifies as
     well as filling when JUSTIFY is non-`nil'.

     If NOSQUEEZE is non-`nil', that means to leave whitespace other
     than line breaks untouched.  If SQUEEZE-AFTER is non-`nil', it
     specifies a position in the region, and means don't canonicalize
     spaces before that position.

     In Adaptive Fill mode, this command calls `fill-context-prefix' to
     choose a fill prefix by default.  *Note Adaptive Fill::.

 -- Command: justify-current-line &optional how eop nosqueeze
     This command inserts spaces between the words of the current line
     so that the line ends exactly at `fill-column'.  It returns `nil'.

     The argument HOW, if non-`nil' specifies explicitly the style of
     justification.  It can be `left', `right', `full', `center', or
     `none'.  If it is `t', that means to do follow specified
     justification style (see `current-justification', below).  `nil'
     means to do full justification.

     If EOP is non-`nil', that means do only left-justification if
     `current-justification' specifies full justification.  This is
     used for the last line of a paragraph; even if the paragraph as a
     whole is fully justified, the last line should not be.

     If NOSQUEEZE is non-`nil', that means do not change interior
     whitespace.

 -- User Option: default-justification
     This variable's value specifies the style of justification to use
     for text that doesn't specify a style with a text property.  The
     possible values are `left', `right', `full', `center', or `none'.
     The default value is `left'.

 -- Function: current-justification
     This function returns the proper justification style to use for
     filling the text around point.

     This returns the value of the `justification' text property at
     point, or the variable DEFAULT-JUSTIFICATION if there is no such
     text property.  However, it returns `nil' rather than `none' to
     mean "don't justify".

 -- User Option: sentence-end-double-space
     If this variable is non-`nil', a period followed by just one space
     does not count as the end of a sentence, and the filling functions
     avoid breaking the line at such a place.

 -- User Option: sentence-end-without-period
     If this variable is non-`nil', a sentence can end without a
     period.  This is used for languages like Thai, where sentences end
     with a double space but without a period.

 -- User Option: sentence-end-without-space
     If this variable is non-`nil', it should be a string of characters
     that can end a sentence without following spaces.

 -- Variable: fill-paragraph-function
     This variable provides a way for major modes to override the
     filling of paragraphs.  If the value is non-`nil',
     `fill-paragraph' calls this function to do the work.  If the
     function returns a non-`nil' value, `fill-paragraph' assumes the
     job is done, and immediately returns that value.

     The usual use of this feature is to fill comments in programming
     language modes.  If the function needs to fill a paragraph in the
     usual way, it can do so as follows:

          (let ((fill-paragraph-function nil))
            (fill-paragraph arg))

 -- Variable: use-hard-newlines
     If this variable is non-`nil', the filling functions do not delete
     newlines that have the `hard' text property.  These "hard
     newlines" act as paragraph separators.


File: elisp,  Node: Margins,  Next: Adaptive Fill,  Prev: Filling,  Up: Text

32.12 Margins for Filling
=========================

 -- User Option: fill-prefix
     This buffer-local variable, if non-`nil', specifies a string of
     text that appears at the beginning of normal text lines and should
     be disregarded when filling them.  Any line that fails to start
     with the fill prefix is considered the start of a paragraph; so is
     any line that starts with the fill prefix followed by additional
     whitespace.  Lines that start with the fill prefix but no
     additional whitespace are ordinary text lines that can be filled
     together.  The resulting filled lines also start with the fill
     prefix.

     The fill prefix follows the left margin whitespace, if any.

 -- User Option: fill-column
     This buffer-local variable specifies the maximum width of filled
     lines.  Its value should be an integer, which is a number of
     columns.  All the filling, justification, and centering commands
     are affected by this variable, including Auto Fill mode (*note
     Auto Filling::).

     As a practical matter, if you are writing text for other people to
     read, you should set `fill-column' to no more than 70.  Otherwise
     the line will be too long for people to read comfortably, and this
     can make the text seem clumsy.

 -- Variable: default-fill-column
     The value of this variable is the default value for `fill-column'
     in buffers that do not override it.  This is the same as
     `(default-value 'fill-column)'.

     The default value for `default-fill-column' is 70.

 -- Command: set-left-margin from to margin
     This sets the `left-margin' property on the text from FROM to TO
     to the value MARGIN.  If Auto Fill mode is enabled, this command
     also refills the region to fit the new margin.

 -- Command: set-right-margin from to margin
     This sets the `right-margin' property on the text from FROM to TO
     to the value MARGIN.  If Auto Fill mode is enabled, this command
     also refills the region to fit the new margin.

 -- Function: current-left-margin
     This function returns the proper left margin value to use for
     filling the text around point.  The value is the sum of the
     `left-margin' property of the character at the start of the
     current line (or zero if none), and the value of the variable
     `left-margin'.

 -- Function: current-fill-column
     This function returns the proper fill column value to use for
     filling the text around point.  The value is the value of the
     `fill-column' variable, minus the value of the `right-margin'
     property of the character after point.

 -- Command: move-to-left-margin &optional n force
     This function moves point to the left margin of the current line.
     The column moved to is determined by calling the function
     `current-left-margin'.  If the argument N is non-`nil',
     `move-to-left-margin' moves forward N-1 lines first.

     If FORCE is non-`nil', that says to fix the line's indentation if
     that doesn't match the left margin value.

 -- Function: delete-to-left-margin &optional from to
     This function removes left margin indentation from the text between
     FROM and TO.  The amount of indentation to delete is determined by
     calling `current-left-margin'.  In no case does this function
     delete non-whitespace.  If FROM and TO are omitted, they default
     to the whole buffer.

 -- Function: indent-to-left-margin
     This function adjusts the indentation at the beginning of the
     current line to the value specified by the variable `left-margin'.
     (That may involve either inserting or deleting whitespace.)  This
     function is value of `indent-line-function' in Paragraph-Indent
     Text mode.

 -- Variable: left-margin
     This variable specifies the base left margin column.  In
     Fundamental mode, `C-j' indents to this column.  This variable
     automatically becomes buffer-local when set in any fashion.

 -- Variable: fill-nobreak-predicate
     This variable gives major modes a way to specify not to break a
     line at certain places.  Its value should be a list of functions.
     Whenever filling considers breaking the line at a certain place in
     the buffer, it calls each of these functions with no arguments and
     with point located at that place.  If any of the functions returns
     non-`nil', then the line won't be broken there.


File: elisp,  Node: Adaptive Fill,  Next: Auto Filling,  Prev: Margins,  Up: Text

32.13 Adaptive Fill Mode
========================

When "Adaptive Fill Mode" is enabled, Emacs determines the fill prefix
automatically from the text in each paragraph being filled rather than
using a predetermined value.  During filling, this fill prefix gets
inserted at the start of the second and subsequent lines of the
paragraph as described in *note Filling::, and in *note Auto Filling::.

 -- User Option: adaptive-fill-mode
     Adaptive Fill mode is enabled when this variable is non-`nil'.  It
     is `t' by default.

 -- Function: fill-context-prefix from to
     This function implements the heart of Adaptive Fill mode; it
     chooses a fill prefix based on the text between FROM and TO,
     typically the start and end of a paragraph.  It does this by
     looking at the first two lines of the paragraph, based on the
     variables described below.

     Usually, this function returns the fill prefix, a string.  However,
     before doing this, the function makes a final check (not specially
     mentioned in the following) that a line starting with this prefix
     wouldn't look like the start of a paragraph.  Should this happen,
     the function signals the anomaly by returning `nil' instead.

     In detail, `fill-context-prefix' does this:

       1. It takes a candidate for the fill prefix from the first
          line--it tries first the function in `adaptive-fill-function'
          (if any), then the regular expression `adaptive-fill-regexp'
          (see below).  The first non-`nil' result of these, or the
          empty string if they're both `nil', becomes the first line's
          candidate.

       2. If the paragraph has as yet only one line, the function tests
          the validity of the prefix candidate just found.  The
          function then returns the candidate if it's valid, or a
          string of spaces otherwise.  (see the description of
          `adaptive-fill-first-line-regexp' below).

       3. When the paragraph already has two lines, the function next
          looks for a prefix candidate on the second line, in just the
          same way it did for the first line.  If it doesn't find one,
          it returns `nil'.

       4. The function now compares the two candidate prefixes
          heuristically: if the non-whitespace characters in the line 2
          candidate occur in the same order in the line 1 candidate,
          the function returns the line 2 candidate.  Otherwise, it
          returns the largest initial substring which is common to both
          candidates (which might be the empty string).

 -- User Option: adaptive-fill-regexp
     Adaptive Fill mode matches this regular expression against the text
     starting after the left margin whitespace (if any) on a line; the
     characters it matches are that line's candidate for the fill
     prefix.

     The default value matches whitespace with certain punctuation
     characters intermingled.

 -- User Option: adaptive-fill-first-line-regexp
     Used only in one-line paragraphs, this regular expression acts as
     an additional check of the validity of the one available candidate
     fill prefix: the candidate must match this regular expression, or
     match `comment-start-skip'.  If it doesn't, `fill-context-prefix'
     replaces the candidate with a string of spaces "of the same width"
     as it.

     The default value of this variable is `"\\`[ \t]*\\'"', which
     matches only a string of whitespace.  The effect of this default
     is to force the fill prefixes found in one-line paragraphs always
     to be pure whitespace.

 -- User Option: adaptive-fill-function
     You can specify more complex ways of choosing a fill prefix
     automatically by setting this variable to a function.  The
     function is called with point after the left margin (if any) of a
     line, and it must preserve point.  It should return either "that
     line's" fill prefix or `nil', meaning it has failed to determine a
     prefix.


File: elisp,  Node: Auto Filling,  Next: Sorting,  Prev: Adaptive Fill,  Up: Text

32.14 Auto Filling
==================

Auto Fill mode is a minor mode that fills lines automatically as text
is inserted.  This section describes the hook used by Auto Fill mode.
For a description of functions that you can call explicitly to fill and
justify existing text, see *note Filling::.

   Auto Fill mode also enables the functions that change the margins and
justification style to refill portions of the text.  *Note Margins::.

 -- Variable: auto-fill-function
     The value of this buffer-local variable should be a function (of no
     arguments) to be called after self-inserting a character from the
     table `auto-fill-chars'.  It may be `nil', in which case nothing
     special is done in that case.

     The value of `auto-fill-function' is `do-auto-fill' when Auto-Fill
     mode is enabled.  That is a function whose sole purpose is to
     implement the usual strategy for breaking a line.

          In older Emacs versions, this variable was named
          `auto-fill-hook', but since it is not called with the
          standard convention for hooks, it was renamed to
          `auto-fill-function' in version 19.

 -- Variable: normal-auto-fill-function
     This variable specifies the function to use for
     `auto-fill-function', if and when Auto Fill is turned on.  Major
     modes can set buffer-local values for this variable to alter how
     Auto Fill works.

 -- Variable: auto-fill-chars
     A char table of characters which invoke `auto-fill-function' when
     self-inserted--space and newline in most language environments.
     They have an entry `t' in the table.


File: elisp,  Node: Sorting,  Next: Columns,  Prev: Auto Filling,  Up: Text

32.15 Sorting Text
==================

The sorting functions described in this section all rearrange text in a
buffer.  This is in contrast to the function `sort', which rearranges
the order of the elements of a list (*note Rearrangement::).  The
values returned by these functions are not meaningful.

 -- Function: sort-subr reverse nextrecfun endrecfun &optional
          startkeyfun endkeyfun predicate
     This function is the general text-sorting routine that subdivides a
     buffer into records and then sorts them.  Most of the commands in
     this section use this function.

     To understand how `sort-subr' works, consider the whole accessible
     portion of the buffer as being divided into disjoint pieces called
     "sort records".  The records may or may not be contiguous, but they
     must not overlap.  A portion of each sort record (perhaps all of
     it) is designated as the sort key.  Sorting rearranges the records
     in order by their sort keys.

     Usually, the records are rearranged in order of ascending sort key.
     If the first argument to the `sort-subr' function, REVERSE, is
     non-`nil', the sort records are rearranged in order of descending
     sort key.

     The next four arguments to `sort-subr' are functions that are
     called to move point across a sort record.  They are called many
     times from within `sort-subr'.

       1. NEXTRECFUN is called with point at the end of a record.  This
          function moves point to the start of the next record.  The
          first record is assumed to start at the position of point
          when `sort-subr' is called.  Therefore, you should usually
          move point to the beginning of the buffer before calling
          `sort-subr'.

          This function can indicate there are no more sort records by
          leaving point at the end of the buffer.

       2. ENDRECFUN is called with point within a record.  It moves
          point to the end of the record.

       3. STARTKEYFUN is called to move point from the start of a
          record to the start of the sort key.  This argument is
          optional; if it is omitted, the whole record is the sort key.
          If supplied, the function should either return a non-`nil'
          value to be used as the sort key, or return `nil' to indicate
          that the sort key is in the buffer starting at point.  In the
          latter case, ENDKEYFUN is called to find the end of the sort
          key.

       4. ENDKEYFUN is called to move point from the start of the sort
          key to the end of the sort key.  This argument is optional.
          If STARTKEYFUN returns `nil' and this argument is omitted (or
          `nil'), then the sort key extends to the end of the record.
          There is no need for ENDKEYFUN if STARTKEYFUN returns a
          non-`nil' value.

     The argument PREDICATE is the function to use to compare keys.  If
     keys are numbers, it defaults to `<'; otherwise it defaults to
     `string<'.

     As an example of `sort-subr', here is the complete function
     definition for `sort-lines':

          ;; Note that the first two lines of doc string
          ;; are effectively one line when viewed by a user.
          (defun sort-lines (reverse beg end)
            "Sort lines in region alphabetically;\
           argument means descending order.
          Called from a program, there are three arguments:
          REVERSE (non-nil means reverse order),\
           BEG and END (region to sort).
          The variable `sort-fold-case' determines\
           whether alphabetic case affects
          the sort order."
            (interactive "P\nr")
            (save-excursion
              (save-restriction
                (narrow-to-region beg end)
                (goto-char (point-min))
                (let ((inhibit-field-text-motion t))
                  (sort-subr reverse 'forward-line 'end-of-line)))))

     Here `forward-line' moves point to the start of the next record,
     and `end-of-line' moves point to the end of record.  We do not pass
     the arguments STARTKEYFUN and ENDKEYFUN, because the entire record
     is used as the sort key.

     The `sort-paragraphs' function is very much the same, except that
     its `sort-subr' call looks like this:

          (sort-subr reverse
                     (function
                       (lambda ()
                         (while (and (not (eobp))
                                (looking-at paragraph-separate))
                           (forward-line 1))))
                     'forward-paragraph)

     Markers pointing into any sort records are left with no useful
     position after `sort-subr' returns.

 -- User Option: sort-fold-case
     If this variable is non-`nil', `sort-subr' and the other buffer
     sorting functions ignore case when comparing strings.

 -- Command: sort-regexp-fields reverse record-regexp key-regexp start
          end
     This command sorts the region between START and END alphabetically
     as specified by RECORD-REGEXP and KEY-REGEXP.  If REVERSE is a
     negative integer, then sorting is in reverse order.

     Alphabetical sorting means that two sort keys are compared by
     comparing the first characters of each, the second characters of
     each, and so on.  If a mismatch is found, it means that the sort
     keys are unequal; the sort key whose character is less at the
     point of first mismatch is the lesser sort key.  The individual
     characters are compared according to their numerical character
     codes in the Emacs character set.

     The value of the RECORD-REGEXP argument specifies how to divide
     the buffer into sort records.  At the end of each record, a search
     is done for this regular expression, and the text that matches it
     is taken as the next record.  For example, the regular expression
     `^.+$', which matches lines with at least one character besides a
     newline, would make each such line into a sort record.  *Note
     Regular Expressions::, for a description of the syntax and meaning
     of regular expressions.

     The value of the KEY-REGEXP argument specifies what part of each
     record is the sort key.  The KEY-REGEXP could match the whole
     record, or only a part.  In the latter case, the rest of the
     record has no effect on the sorted order of records, but it is
     carried along when the record moves to its new position.

     The KEY-REGEXP argument can refer to the text matched by a
     subexpression of RECORD-REGEXP, or it can be a regular expression
     on its own.

     If KEY-REGEXP is:

    `\DIGIT'
          then the text matched by the DIGITth `\(...\)' parenthesis
          grouping in RECORD-REGEXP is the sort key.

    `\&'
          then the whole record is the sort key.

    a regular expression
          then `sort-regexp-fields' searches for a match for the regular
          expression within the record.  If such a match is found, it
          is the sort key.  If there is no match for KEY-REGEXP within
          a record then that record is ignored, which means its
          position in the buffer is not changed.  (The other records
          may move around it.)

     For example, if you plan to sort all the lines in the region by the
     first word on each line starting with the letter `f', you should
     set RECORD-REGEXP to `^.*$' and set KEY-REGEXP to `\<f\w*\>'.  The
     resulting expression looks like this:

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     If you call `sort-regexp-fields' interactively, it prompts for
     RECORD-REGEXP and KEY-REGEXP in the minibuffer.

 -- Command: sort-lines reverse start end
     This command alphabetically sorts lines in the region between
     START and END.  If REVERSE is non-`nil', the sort is in reverse
     order.

 -- Command: sort-paragraphs reverse start end
     This command alphabetically sorts paragraphs in the region between
     START and END.  If REVERSE is non-`nil', the sort is in reverse
     order.

 -- Command: sort-pages reverse start end
     This command alphabetically sorts pages in the region between
     START and END.  If REVERSE is non-`nil', the sort is in reverse
     order.

 -- Command: sort-fields field start end
     This command sorts lines in the region between START and END,
     comparing them alphabetically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     If FIELD is negative, sorting is by the -FIELDth field from the
     end of the line.  This command is useful for sorting tables.

 -- Command: sort-numeric-fields field start end
     This command sorts lines in the region between START and END,
     comparing them numerically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     The specified field must contain a number in each line of the
     region.  Numbers starting with 0 are treated as octal, and numbers
     starting with `0x' are treated as hexadecimal.

     If FIELD is negative, sorting is by the -FIELDth field from the
     end of the line.  This command is useful for sorting tables.

 -- User Option: sort-numeric-base
     This variable specifies the default radix for
     `sort-numeric-fields' to parse numbers.

 -- Command: sort-columns reverse &optional beg end
     This command sorts the lines in the region between BEG and END,
     comparing them alphabetically by a certain range of columns.  The
     column positions of BEG and END bound the range of columns to sort
     on.

     If REVERSE is non-`nil', the sort is in reverse order.

     One unusual thing about this command is that the entire line
     containing position BEG, and the entire line containing position
     END, are included in the region sorted.

     Note that `sort-columns' rejects text that contains tabs, because
     tabs could be split across the specified columns.  Use `M-x
     untabify' to convert tabs to spaces before sorting.

     When possible, this command actually works by calling the `sort'
     utility program.

