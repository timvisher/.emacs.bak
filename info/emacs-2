This is ../info/emacs, produced by makeinfo version 4.11 from
emacs.texi.

This is the Sixteenth edition of the `GNU Emacs Manual',
updated for Emacs version 22.3.

   Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with the Invariant Sections being "The GNU Manifesto,"
     "Distribution" and "GNU GENERAL PUBLIC LICENSE," with the
     Front-Cover texts being "A GNU Manual," and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You are free to copy and modify
     this GNU Manual. Buying copies from GNU Press supports the FSF in
     developing GNU and promoting software freedom."

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


File: emacs,  Node: Regexps,  Next: Regexp Backslash,  Prev: Regexp Search,  Up: Search

20.5 Syntax of Regular Expressions
==================================

This manual describes regular expression features that users typically
want to use.  There are additional features that are mainly used in
Lisp programs; see *note Regular Expressions: (elisp)Regular
Expressions.

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that same character and
nothing else.  The special characters are `$', `^', `.', `*', `+', `?',
`[', and `\'.  The character `]' is special if it ends a character
alternative (see later).  The character `-' is special inside a
character alternative.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.  (When you use
regular expressions in a Lisp program, each `\' must be doubled, see
the example near the end of this section.)

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does _not_ match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regexps also match `F' and `O', but we
consider this a generalization of "the same string," rather than an
exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`.' (Period)
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b', which matches any three-character string that begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator that means
     to match the preceding regular expression repetitively as many
     times as possible.  Thus, `o*' matches any number of `o's
     (including no `o's).

     `*' always applies to the _smallest_ possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     in matching `ca*ar' against the string `caaar', the `a*' first
     tries to match all three `a's; but the rest of the pattern is `ar'
     and there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a postfix operator, similar to `*' except that it must match
     the preceding expression at least once.  So, for example, `ca+r'
     matches the strings `car' and `caaaar' but not the string `cr',
     whereas `ca*r' matches all three strings.

`?'
     is a postfix operator, similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' matches `car' or `cr'; nothing else.

`*?', `+?', `??'
     are non-greedy variants of the operators above.  The normal
     operators `*', `+', `?' are "greedy" in that they match as much as
     they can, as long as the overall regexp can still match.  With a
     following `?', they are non-greedy: they will match as little as
     possible.

     Thus, both `ab*' and `ab*?' can match the string `a' and the
     string `abbbb'; but if you try to match them both against the text
     `abbb', `ab*' will match it all (the longest valid match), while
     `ab*?'  will match just `a' (the shortest valid match).

     Non-greedy operators match the shortest possible string starting
     at a given starting point; in a forward search, though, the
     earliest possible starting point for match is always the one
     chosen.  Thus, if you search for `a.*?$' against the text `abbab'
     followed by a newline, it matches the whole string.  Since it
     _can_ match starting at the first `a', it does.

`\{N\}'
     is a postfix operator that specifies repetition N times--that is,
     the preceding regular expression must match exactly N times in a
     row.  For example, `x\{4\}' matches the string `xxxx' and nothing
     else.

`\{N,M\}'
     is a postfix operator that specifies repetition between N and M
     times--that is, the preceding regular expression must match at
     least N times, but no more than M times.  If M is omitted, then
     there is no upper limit, but the preceding regular expression must
     match at least N times.
     `\{0,1\}' is equivalent to `?'.
     `\{0,\}' is equivalent to `*'.
     `\{1,\}' is equivalent to `+'.

`[ ... ]'
     is a "character set", which begins with `[' and is terminated by
     `]'.  In the simplest case, the characters between the two
     brackets are what this set can match.

     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can also include character ranges in a character set, by
     writing the starting and ending characters with a `-' between
     them.  Thus, `[a-z]' matches any lower-case ASCII letter.  Ranges
     may be intermixed freely with individual characters, as in
     `[a-z$%.]', which matches any lower-case ASCII letter or `$', `%'
     or period.

     Note that the usual regexp special characters are not special
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' as the first or last character of the set, or put
     it after a range.  Thus, `[]-]' matches both `]' and `-'.

     To include `^' in a set, put it anywhere but at the beginning of
     the set.  (At the beginning, it complements the set--see below.)

     When you use a range in case-insensitive search, you should write
     both ends of the range in upper case, or both in lower case, or
     both should be non-letters.  The behavior of a mixed-case range
     such as `A-z' is somewhat ill-defined, and it may change in future
     Emacs versions.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters _except_ ASCII letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (in other words, `-' and `]' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as `grep'.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' that occurs
     at the beginning of a line.

     For historical compatibility reasons, `^' can be used with this
     meaning only at the beginning of the regular expression, or after
     `\(' or `\|'.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `x+$' matches a string of one `x' or more at the end of a line.

     For historical compatibility reasons, `$' can be used with this
     meaning only at the end of the regular expression, or before `\)'
     or `\|'.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression that matches only `$', and `\[' is a regular expression
     that matches only `[', and so on.

     See the following section for the special constructs that begin
     with `\'.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; it is better to quote the special character
anyway, regardless of where it appears.

   As a `\' is not special inside a character alternative, it can never
remove the special meaning of `-' or `]'.  So you should not quote
these characters when they have no special meaning either.  This would
not clarify anything, since backslashes can legitimately precede these
characters where they _have_ special meaning, as in `[^\]' (`"[^\\]"'
for Lisp string syntax), which matches any single character except a
backslash.


File: emacs,  Node: Regexp Backslash,  Next: Regexp Example,  Prev: Regexps,  Up: Search

20.6 Backslash in Regular Expressions
=====================================

For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with `\' that have special meanings.  The second
character in the sequence is always an ordinary character when used on
its own.  Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches some text if
     either A matches it or B matches it.  It works by trying to match
     A, and if that fails, by trying to match B.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the grouping
     power of `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix operators
          `*', `+' and `?' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To record a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature that is assigned
     as a second meaning to the same `\( ... \)' construct.  In practice
     there is usually no conflict between the two meanings; when there
     is a conflict, you can use a "shy" group.

`\(?: ... \)'
     specifies a "shy" group that does not record the matched substring;
     you can't refer back to it with `\D'.  This is useful in
     mechanically combining regular expressions, so that you can add
     groups for syntactic purposes without interfering with the
     numbering of the groups that are meant to be referred to.

`\D'
     matches the same text that matched the Dth occurrence of a `\( ...
     \)' construct.  This is called a "back reference".

     After the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in the order that the open-parentheses appear in the regular
     expression.  So you can use `\1' through `\9' to refer to the text
     matched by the corresponding `\( ... \)' constructs.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

     If a particular `\( ... \)' construct matches more than once
     (which can easily happen if it is followed by `*'), only the last
     match is recorded.

`\`'
     matches the empty string, but only at the beginning of the string
     or buffer (or its accessible portion) being matched against.

`\''
     matches the empty string, but only at the end of the string or
     buffer (or its accessible portion) being matched against.

`\='
     matches the empty string, but only at point.

`\b'
     matches the empty string, but only at the beginning or end of a
     word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

     `\b' matches at the beginning or end of the buffer regardless of
     what text appears next to it.

`\B'
     matches the empty string, but _not_ at the beginning or end of a
     word.

`\<'
     matches the empty string, but only at the beginning of a word.
     `\<' matches at the beginning of the buffer only if a
     word-constituent character follows.

`\>'
     matches the empty string, but only at the end of a word.  `\>'
     matches at the end of the buffer only if the contents end with a
     word-constituent character.

`\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.  *Note Syntax::.

`\W'
     matches any character that is not a word-constituent.

`\_<'
     matches the empty string, but only at the beginning of a symbol.
     A symbol is a sequence of one or more symbol-constituent
     characters.  A symbol-constituent character is a character whose
     syntax is either `w' or `_'.  `\_<' matches at the beginning of the
     buffer only if a symbol-constituent character follows.

`\_>'
     matches the empty string, but only at the end of a symbol.  `\_>'
     matches at the end of the buffer only if the contents end with a
     symbol-constituent character.

`\sC'
     matches any character whose syntax is C.  Here C is a character
     that designates a particular syntax class: thus, `w' for word
     constituent, `-' or ` ' for whitespace, `.' for ordinary
     punctuation, etc.  *Note Syntax::.

`\SC'
     matches any character whose syntax is not C.

`\cC'
     matches any character that belongs to the category C.  For
     example, `\cc' matches Chinese characters, `\cg' matches Greek
     characters, etc.  For the description of the known categories,
     type `M-x describe-categories <RET>'.

`\CC'
     matches any character that does _not_ belong to category C.

   The constructs that pertain to words and syntax are controlled by the
setting of the syntax table (*note Syntax::).


File: emacs,  Node: Regexp Example,  Next: Search Case,  Prev: Regexp Backslash,  Up: Search

20.7 Regular Expression Example
===============================

Here is a complicated regexp--a simplified version of the regexp that
Emacs uses, by default, to recognize the end of a sentence together
with any whitespace that follows.  We show its Lisp syntax to
distinguish the spaces from the tab characters.  In Lisp syntax, the
string constant begins and ends with a double-quote.  `\"' stands for a
double-quote as part of the regexp, `\\' for a backslash as part of the
regexp, `\t' for a tab, and `\n' for a newline.

     "[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

This contains four parts in succession: a character set matching
period, `?', or `!'; a character set matching close-brackets, quotes,
or parentheses, repeated zero or more times; a set of alternatives
within backslash-parentheses that matches either end-of-line, a space
at the end of a line, a tab, or two spaces; and a character set
matching whitespace characters, repeated any number of times.

   To enter the same regexp in incremental search, you would type <TAB>
to enter a tab, and `C-j' to enter a newline.  You would also type
single backslashes as themselves, instead of doubling them for Lisp
syntax.  In commands that use ordinary minibuffer input to read a
regexp, you would quote the `C-j' by preceding it with a `C-q' to
prevent `C-j' from exiting the minibuffer.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexp Example,  Up: Search

20.8 Searching and Case
=======================

Incremental searches in Emacs normally ignore the case of the text they
are searching through, if you specify the text in lower case.  Thus, if
you specify searching for `foo', then `Foo' and `foo' are also
considered a match.  Regexps, and in particular character sets, are
included: `[ab]' would match `a' or `A' or `b' or `B'.

   An upper-case letter anywhere in the incremental search string makes
the search case-sensitive.  Thus, searching for `Foo' does not find
`foo' or `FOO'.  This applies to regular expression search as well as
to string search.  The effect ceases if you delete the upper-case
letter from the search string.

   Typing `M-c' within an incremental search toggles the case
sensitivity of that search.  The effect does not extend beyond the
current incremental search to the next one, but it does override the
effect of including an upper-case letter in the current search.

   If you set the variable `case-fold-search' to `nil', then all
letters must match exactly, including case.  This is a per-buffer
variable; altering the variable affects only the current buffer, but
there is a default value in `default-case-fold-search' that you can
also set.  *Note Locals::.  This variable applies to nonincremental
searches also, including those performed by the replace commands (*note
Replace::) and the minibuffer history matching commands (*note
Minibuffer History::).

   Several related variables control case-sensitivity of searching and
matching for specific commands or activities.  For instance,
`tags-case-fold-search' controls case sensitivity for `find-tag'.  To
find these variables, do `M-x apropos-variable <RET> case-fold-search
<RET>'.


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

20.9 Replacement Commands
=========================

Global search-and-replace operations are not needed often in Emacs, but
they are available.  In addition to the simple `M-x replace-string'
command which replaces all occurrences, there is `M-%'
(`query-replace'), which presents each occurrence of the pattern and
asks you whether to replace it.

   The replace commands normally operate on the text from point to the
end of the buffer; however, in Transient Mark mode (*note Transient
Mark::), when the mark is active, they operate on the region.  The
basic replace commands replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs' (*note Expanding
Abbrevs::).

* Menu:

* Unconditional Replace::	Replacing all matches for a string.
* Regexp Replace::		Replacing all matches for a regexp.
* Replacement and Case::	How replacements preserve case of letters.
* Query Replace::		How to use querying.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

20.9.1 Unconditional Replacement
--------------------------------

`M-x replace-string <RET> STRING <RET> NEWSTRING <RET>'
     Replace every occurrence of STRING with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, narrow to that part of the buffer
before doing the replacement (*note Narrowing::).  In Transient Mark
mode, when the region is active, replacement is limited to the region
(*note Transient Mark::).

   When `replace-string' exits, it leaves point at the last occurrence
replaced.  It sets the mark to the prior position of point (where the
`replace-string' command was issued); use `C-u C-<SPC>' to move back
there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.  The argument's value doesn't matter.

   *Note Replacement and Case::, for details about case-sensitivity in
replace commands.

   What if you want to exchange `x' and `y': replace every `x' with a
`y' and vice versa?  You can do it this way:

     M-x replace-string <RET> x <RET> @TEMP@ <RET>
     M-< M-x replace-string <RET> y <RET> x <RET>
     M-< M-x replace-string <RET> @TEMP@ <RET> y <RET>

This works provided the string `@TEMP@' does not appear in your text.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

20.9.2 Regexp Replacement
-------------------------

The `M-x replace-string' command replaces exact matches for a single
string.  The similar command `M-x replace-regexp' replaces any match
for a specified pattern.

`M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace every match for REGEXP with NEWSTRING.

   In `replace-regexp', the NEWSTRING need not be constant: it can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire match being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  (This is called a "back reference.")
`\#' refers to the count of replacements already made in this command,
as a decimal number.  In the first replacement, `\#' stands for `0'; in
the second, for `1'; and so on.  For example,

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

replaces (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

performs the inverse transformation.  To include a `\' in the text to
replace with, you must enter `\\'.

   If you want to enter part of the replacement string by hand each
time, use `\?' in the replacement string.  Each replacement will ask
you to edit the replacement string in the minibuffer, putting point
where the `\?' was.

   The remainder of this subsection is intended for specialized tasks
and requires knowledge of Lisp.  Most readers can skip it.

   You can use Lisp expressions to calculate parts of the replacement
string.  To do this, write `\,' followed by the expression in the
replacement string.  Each replacement calculates the value of the
expression and converts it to text without quoting (if it's a string,
this means using the string's contents), and uses it in the replacement
string in place of the expression itself.  If the expression is a
symbol, one space in the replacement string after the symbol name goes
with the symbol name, so the value replaces them both.

   Inside such an expression, you can use some special sequences.  `\&'
and `\N' refer here, as usual, to the entire match as a string, and to
a submatch as a string.  N may be multiple digits, and the value of
`\N' is `nil' if subexpression N did not match.  You can also use `\#&'
and `\#N' to refer to those matches as numbers (this is valid when the
match or submatch has the form of a numeral).  `\#' here too stands for
the number of already-completed replacements.

   Repeating our example to exchange `x' and `y', we can thus do it
also this way:

     M-x replace-regexp <RET> \(x\)\|y <RET>
     \,(if \1 "y" "x") <RET>

   For computing replacement strings for `\,', the `format' function is
often useful (*note Formatting Strings: (elisp)Formatting Strings.).
For example, to add consecutively numbered strings like `ABC00042' to
columns 73 to 80 (unless they are already occupied), you can use

     M-x replace-regexp <RET> ^.\{0,72\}$ <RET>
     \,(format "%-72sABC%05d" \& \#) <RET>


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

20.9.3 Replace Commands and Case
--------------------------------

If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to
replace--provided `case-fold-search' is non-`nil'.  If
`case-fold-search' is set to `nil', case is always significant in all
searches.

   In addition, when the NEWSTRING argument is all or partly lower
case, replacement commands try to preserve the case pattern of each
occurrence.  Thus, the command

     M-x replace-string <RET> foo <RET> bar <RET>

replaces a lower case `foo' with a lower case `bar', an all-caps `FOO'
with `BAR', and a capitalized `Foo' with `Bar'.  (These three
alternatives--lower case, all caps, and capitalized, are the only ones
that `replace-string' can distinguish.)

   If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
`case-replace' or `case-fold-search' is set to `nil', replacement is
done without case conversion.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

20.9.4 Query Replace
--------------------

`M-% STRING <RET> NEWSTRING <RET>'
`M-x query-replace <RET> STRING <RET> NEWSTRING <RET>'
     Replace some occurrences of STRING with NEWSTRING.

`C-M-% REGEXP <RET> NEWSTRING <RET>'
`M-x query-replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  Aside from querying, `query-replace'
works just like `replace-string' (*note Unconditional Replace::).  In
particular, it preserves case provided `case-replace' is non-`nil', as
it normally is (*note Replacement and Case::).  A numeric argument
means consider only occurrences that are bounded by word-delimiter
characters.

   `C-M-%' performs regexp search and replace (`query-replace-regexp').
It works like `replace-regexp' except that it queries like
`query-replace'.

   These commands highlight the current match using the face
`query-replace'.  They highlight other matches using `lazy-highlight'
just like incremental search (*note Incremental Search::).

   The characters you can type when you are shown a match for the string
or regexp are:

`<SPC>'
     to replace the occurrence with NEWSTRING.

`<DEL>'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character to say what to do next.  Since
     the replacement has already been made, <DEL> and <SPC> are
     equivalent in this situation; both move to the next occurrence.

     You can type `C-r' at this point (see below) to alter the replaced
     text.  You can also type `C-x u' to undo the replacement; this
     exits the `query-replace', so if you want to do further
     replacement you must use `C-x <ESC> <ESC> <RET>' to restart (*note
     Repetition::).

`<RET>'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the position of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake or
     want to reexamine it.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' to proceed
     to the next occurrence.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' to proceed to the next occurrence.

`e'
     to edit the replacement string in the minibuffer.  When you exit
     the minibuffer by typing <RET>, the minibuffer contents replace the
     current occurrence of the pattern.  They also become the new
     replacement string for any further occurrences.

`C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

`C-h'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Some other characters are aliases for the ones listed above: `y',
`n' and `q' are equivalent to <SPC>, <DEL> and <RET>.

   Aside from this, any other character exits the `query-replace', and
is then reread as part of a key sequence.  Thus, if you type `C-k', it
exits the `query-replace' and then kills to end of line.

   To restart a `query-replace' once it is exited, use `C-x <ESC>
<ESC>', which repeats the `query-replace' because it used the
minibuffer to read its arguments.  *Note C-x ESC ESC: Repetition.

   *Note Operating on Files::, for the Dired `Q' command which performs
query replace on selected files.  See also *note Transforming File
Names::, for Dired commands to rename, copy, or link files by replacing
regexp matches in file names.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

20.10 Other Search-and-Loop Commands
====================================

Here are some other commands that find matches for a regular
expression.  They all ignore case in matching, if the pattern contains
no upper-case letters and `case-fold-search' is non-`nil'.  Aside from
`occur' and its variants, all operate on the text from point to the end
of the buffer, or on the active region in Transient Mark mode.

`M-x occur <RET> REGEXP <RET>'
     Display a list showing each line in the buffer that contains a
     match for REGEXP.  To limit the search to part of the buffer,
     narrow to that part (*note Narrowing::).  A numeric argument N
     specifies that N lines of context are to be displayed before and
     after each matching line.  Currently, `occur' can not correctly
     handle multiline matches.

     The buffer `*Occur*' containing the output serves as a menu for
     finding the occurrences in their original context.  Click
     `Mouse-2' on an occurrence listed in `*Occur*', or position point
     there and type <RET>; this switches to the buffer that was
     searched and moves point to the original of the chosen occurrence.
     `o' and `C-o' display the match in another window; `C-o' does not
     select it.

     After using `M-x occur', you can use `next-error' to visit the
     occurrences found, one by one.  *note Compilation Mode::.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x multi-occur <RET> BUFFERS <RET> REGEXP <RET>'
     This function is just like `occur', except it is able to search
     through multiple buffers.  It asks you to specify the buffer names
     one by one.

`M-x multi-occur-in-matching-buffers <RET> BUFREGEXP <RET> REGEXP <RET>'
     This function is similar to `multi-occur', except the buffers to
     search are specified by a regular expression that matches visited
     file names.  With a prefix argument, it uses the regular
     expression to match buffer names instead.

`M-x how-many <RET> REGEXP <RET>'
     Print the number of matches for REGEXP that exist in the buffer
     after point.  In Transient Mark mode, if the region is active, the
     command operates on the region instead.

`M-x flush-lines <RET> REGEXP <RET>'
     This command deletes each line that contains a match for REGEXP,
     operating on the text after point; it deletes the current line if
     it contains a match starting after point.  In Transient Mark mode,
     if the region is active, the command operates on the region
     instead; it deletes a line partially contained in the region if it
     contains a match entirely contained in the region.

     If a match is split across lines, `flush-lines' deletes all those
     lines.  It deletes the lines before starting to look for the next
     match; hence, it ignores a match starting on the same line at which
     another match ended.

`M-x keep-lines <RET> REGEXP <RET>'
     This command deletes each line that _does not_ contain a match for
     REGEXP, operating on the text after point; if point is not at the
     beginning of a line, it always keeps the current line.  In
     Transient Mark mode, if the region is active, the command operates
     on the region instead; it never deletes lines that are only
     partially contained in the region (a newline that ends a line
     counts as part of that line).

     If a match is split across lines, this command keeps all those
     lines.


File: emacs,  Node: Fixit,  Next: Keyboard Macros,  Prev: Search,  Up: Top

21 Commands for Fixing Typos
****************************

In this chapter we describe the commands that are especially useful for
the times when you catch a mistake in your text just after you have made
it, or change your mind while composing text on the fly.

   The most fundamental command for correcting erroneous editing is the
undo command, `C-x u' or `C-_' or `C-/'.  This command undoes a single
command (usually), a part of a command (in the case of
`query-replace'), or several consecutive self-inserting characters.
Consecutive repetitions of the undo command undo earlier and earlier
changes, back to the limit of the undo information available.  *Note
Undo::, for more information.

* Menu:

* Undo::        The Undo commands.
* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Undo,  Next: Kill Errors,  Up: Fixit

21.1 Undo
=========

The "undo" commands undo recent changes in the buffer's text.  Each
buffer records changes individually, and the undo command always
applies to the current buffer.  You can undo all the changes in a
buffer for as far as back these records go.  Usually each editing
command makes a separate entry in the undo records, but some commands
such as `query-replace' divide their changes into multiple entries for
flexibility in undoing.  Meanwhile, self-inserting characters are
usually grouped to make undoing less tedious.

`C-x u'
`C-_'
`C-/'
     Undo one entry in the current buffer's undo records (`undo').

   To begin to undo, type the command `C-x u' (or its aliases, `C-_' or
`C-/').  This undoes the most recent change in the buffer, and moves
point back to where it was before that change.

   Consecutive repetitions of `C-x u' (or its aliases) undo earlier and
earlier changes in the current buffer, back to the limit of the current
buffer's undo records.  If all the recorded changes have already been
undone, the undo command just signals an error.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  At this time, all the
modifications you made have been canceled.  Whenever an undo command
makes the stars disappear from the mode line, it means that the buffer
contents are the same as they were when the file was last read in or
saved.

   If you do not remember whether you changed the buffer deliberately,
type `C-_' once.  When you see the last change you made undone, you
will see whether it was an intentional change.  If it was an accident,
leave it undone.  If it was deliberate, redo the change as described
below.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the previous undo commands become
ordinary changes that you can undo.  Thus, to redo changes you have
undone, type `C-f' or any other command that will harmlessly break the
sequence of undoing, then type undo commands again.  On the other hand,
if you want to resume undoing, without redoing previous undo commands,
use `M-x undo-only'.  This is like `undo', but will not redo changes
you have just undone.

   Ordinary undo applies to all changes made in the current buffer.  You
can also perform "selective undo", limited to the region.

   To do this, specify the region you want, then run the `undo' command
with a prefix argument (the value does not matter): `C-u C-x u' or `C-u
C-_'.  This undoes the most recent change in the region.  To undo
further changes in the same region, repeat the `undo' command (no
prefix argument is needed).  In Transient Mark mode (*note Transient
Mark::), any use of `undo' when there is an active region performs
selective undo; you do not need a prefix argument.

   Some specialized buffers do not make undo records.  Buffers whose
names start with spaces never do; these buffers are used internally by
Emacs and its extensions to hold text that users don't normally look at
or edit.

   When the undo records for a buffer becomes too large, Emacs discards
the oldest undo records from time to time (during garbage collection).
You can specify how much undo records to keep by setting three
variables: `undo-limit', `undo-strong-limit', and `undo-outer-limit'.
Their values are expressed in units of bytes of space.

   The variable `undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 20000.  The variable `undo-strong-limit' sets a stricter limit: a
previous command (not the most recent one) which pushes the size past
this amount is itself forgotten.  The default value of
`undo-strong-limit' is 30000.

   Regardless of the values of those variables, the most recent change
is never discarded unless it gets bigger than `undo-outer-limit'
(normally 3,000,000).  At that point, Emacs discards the undo data and
warns you about it.  This is the only situation in which you cannot
undo the last command.  If this happens, you can increase the value of
`undo-outer-limit' to make it even less likely to happen in the future.
But if you didn't expect the command to create such large undo data,
then it is probably a bug and you should report it.  *Note Reporting
Bugs: Bugs.

   The reason the `undo' command has three key bindings, `C-x u', `C-_'
and `C-/', is that it is worthy of a single-character key, but `C-x u'
is more straightforward for beginners to remember and type.  Meanwhile,
`C--' on a text-only terminal is really `C-_', which makes it a natural
and easily typed binding for undoing.


File: emacs,  Node: Kill Errors,  Next: Transpose,  Prev: Undo,  Up: Fixit

21.2 Killing Your Mistakes
==========================

`<DEL>'
     Delete last character (`delete-backward-char').

`M-<DEL>'
     Kill last word (`backward-kill-word').

`C-x <DEL>'
     Kill to beginning of sentence (`backward-kill-sentence').

   The <DEL> character (`delete-backward-char') is the most important
correction command.  It deletes the character before point.  When <DEL>
follows a self-inserting character command, you can think of it as
canceling that command.  However, avoid the confusion of thinking of
<DEL> as a general way to cancel a command!

   When your mistake is longer than a couple of characters, it might be
more convenient to use `M-<DEL>' or `C-x <DEL>'.  `M-<DEL>' kills back
to the start of the last word, and `C-x <DEL>' kills back to the start
of the last sentence.  `C-x <DEL>' is particularly useful when you
change your mind about the phrasing of the text you are writing.
`M-<DEL>' and `C-x <DEL>' save the killed text for `C-y' and `M-y' to
retrieve.  *Note Yanking::.

   `M-<DEL>' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and aren't
sure exactly what you typed.  At such a time, you cannot correct with
<DEL> except by looking at the screen to see what you did.  Often it
requires less thought to kill the whole word and start again.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

21.3 Transposing Text
=====================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars').
Normally, `C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back between the
two transposed characters before you type `C-t'.  If you transposed a
space with the last character of the word before it, the word motion
commands are a good way of getting there.  Otherwise, a reverse search
(`C-r') is often the best way.  *Note Search::.

   `M-t' transposes the word before point with the word after point
(`transpose-words').  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Expressions::), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except as regards what units of
text they transpose.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, expression,
line) before or containing point across several other characters (words,
expressions, lines).  For example, `C-u 3 C-t' moves the character
before point forward across three other characters.  It would change
`f-!-oobar' into `oobf-!-ar'.  This is equivalent to repeating `C-t'
three times.  `C-u - 4 M-t' moves the word before point backward across
four words.  `C-u - C-M-t' would cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, expression, line) ending after point
with the one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

21.4 Case Conversion
====================

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.


File: emacs,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

21.5 Checking and Correcting Spelling
=====================================

This section describes the commands to check the spelling of a single
word or of a portion of a buffer.  These commands work with the spelling
checker programs Aspell and Ispell, which are not part of Emacs.  *Note
Aspell: (aspell)Top.

`M-x flyspell-mode'
     Enable Flyspell mode, which highlights all misspelled words.

`M-x flyspell-prog-mode'
     Enable Flyspell mode for comments and strings only.

`M-$'
     Check and correct spelling of the word at point (`ispell-word').

`M-<TAB>'
`<ESC> <TAB>'
     Complete the word before point based on the spelling dictionary
     (`ispell-complete-word').

`M-x ispell'
     Spell-check the active region or the current buffer.

`M-x ispell-buffer'
     Check and correct spelling of each word in the buffer.

`M-x ispell-region'
     Check and correct spelling of each word in the region.

`M-x ispell-message'
     Check and correct spelling of each word in a draft mail message,
     excluding cited material.

`M-x ispell-change-dictionary <RET> DICT <RET>'
     Restart the Aspell or Ispell process, using DICT as the dictionary.

`M-x ispell-kill-ispell'
     Kill the Aspell or Ispell subprocess.

   Flyspell mode is a fully-automatic way to check spelling as you edit
in Emacs.  It operates by checking words as you change or insert them.
When it finds a word that it does not recognize, it highlights that
word.  This does not interfere with your editing, but when you see the
highlighted word, you can move to it and fix it.  Type `M-x
flyspell-mode' to enable or disable this mode in the current buffer.

   When Flyspell mode highlights a word as misspelled, you can click on
it with `Mouse-2' to display a menu of possible corrections and
actions.  You can also correct the word by editing it manually in any
way you like.

   Flyspell Prog mode works just like ordinary Flyspell mode, except
that it only checks words in comments and string constants.  This
feature is useful for editing programs.  Type `M-x flyspell-prog-mode'
to enable or disable this mode in the current buffer.

   The other Emacs spell-checking features check or look up words when
you give an explicit command to do so.

   To check the spelling of the word around or before point, and
optionally correct it as well, use the command `M-$' (`ispell-word').
If the word is not correct, the command offers you various alternatives
for what to do about it.

   To check the entire current buffer, use `M-x ispell-buffer'.  Use
`M-x ispell-region' to check just the current region.  To check
spelling in an email message you are writing, use `M-x ispell-message';
that command checks the whole buffer, except for material that is
indented or appears to be cited from other messages.

   The `M-x ispell' command spell-checks the active region if the
Transient Mark mode is on (*note Transient Mark::), otherwise it
spell-checks the current buffer.

   Each time these commands encounter an incorrect word, they ask you
what to do.  They display a list of alternatives, usually including
several "near-misses"--words that are close to the word being checked.
Then you must type a single-character response.  Here are the valid
responses:

`<SPC>'
     Skip this word--continue to consider it incorrect, but don't
     change it here.

`r NEW <RET>'
     Replace the word (just this time) with NEW.  (The replacement
     string will be rescanned for more spelling errors.)

`R NEW <RET>'
     Replace the word with NEW, and do a `query-replace' so you can
     replace it elsewhere in the buffer if you wish.  (The replacements
     will be rescanned for more spelling errors.)

`DIGIT'
     Replace the word (just this time) with one of the displayed
     near-misses.  Each near-miss is listed with a digit; type that
     digit to select it.

`a'
     Accept the incorrect word--treat it as correct, but only in this
     editing session.

`A'
     Accept the incorrect word--treat it as correct, but only in this
     editing session and for this buffer.

`i'
     Insert this word in your private dictionary file so that Aspell or
     Ispell will consider it correct from now on, even in future
     sessions.

`u'
     Insert the lower-case version of this word in your private
     dictionary file.

`m'
     Like `i', but you can also specify dictionary completion
     information.

`l WORD <RET>'
     Look in the dictionary for words that match WORD.  These words
     become the new list of "near-misses"; you can select one of them as
     the replacement by typing a digit.  You can use `*' in WORD as a
     wildcard.

`C-g'
     Quit interactive spell checking, leaving point at the word that was
     being checked.  You can restart checking again afterward with `C-u
     M-$'.

`X'
     Same as `C-g'.

`x'
     Quit interactive spell checking and move point back to where it was
     when you started spell checking.

`q'
     Quit interactive spell checking and kill the Ispell subprocess.

`C-l'
     Refresh the screen.

`C-z'
     This key has its normal command meaning (suspend Emacs or iconify
     this frame).

`?'
     Show the list of options.

   The command `ispell-complete-word', which is bound to the key
`M-<TAB>' in Text mode and related modes, shows a list of completions
based on spelling correction.  Insert the beginning of a word, and then
type `M-<TAB>'; the command displays a completion list window.  (If
your window manager intercepts `M-<TAB>', type `<ESC> <TAB>' or
`C-M-i'.)  To choose one of the completions listed, click `Mouse-2' or
`Mouse-1' fast on it, or move the cursor there in the completions
window and type <RET>.  *Note Text Mode::.

   Once started, the Aspell or Ispell subprocess continues to run
(waiting for something to do), so that subsequent spell checking
commands complete more quickly.  If you want to get rid of the process,
use `M-x ispell-kill-ispell'.  This is not usually necessary, since the
process uses no time except when you do spelling correction.

   Ispell and Aspell use two dictionaries together for spell checking:
the standard dictionary and your private dictionary.  The variable
`ispell-dictionary' specifies the file name to use for the standard
dictionary; a value of `nil' selects the default dictionary.  The
command `M-x ispell-change-dictionary' sets this variable and then
restarts the subprocess, so that it will use a different standard
dictionary.

   Aspell and Ispell use a separate dictionary for word completion.
The variable `ispell-complete-word-dict' specifies the file name of
this dictionary.  The completion dictionary must be different because
it cannot use root and affix information.  For some languages there is
a spell checking dictionary but no word completion dictionary.


File: emacs,  Node: Keyboard Macros,  Next: Files,  Prev: Fixit,  Up: Top

22 Keyboard Macros
******************

In this chapter we describe how to record a sequence of editing
commands so you can repeat it conveniently later.

   A "keyboard macro" is a command defined by an Emacs user to stand for
another sequence of keys.  For example, if you discover that you are
about to type `C-n M-d C-d' forty times, you can speed your work by
defining a keyboard macro to do `C-n M-d C-d', and then executing it 39
more times.

   You define a keyboard macro by executing and recording the commands
which are its definition.  Put differently, as you define a keyboard
macro, the definition is being executed for the first time.  This way,
you can see the effects of your commands, so that you don't have to
figure them out in your head.  When you close the definition, the
keyboard macro is defined and also has been, in effect, executed once.
You can then do the whole thing over again by invoking the macro.

   Keyboard macros differ from ordinary Emacs commands in that they are
written in the Emacs command language rather than in Lisp.  This makes
it easier for the novice to write them, and makes them more convenient
as temporary hacks.  However, the Emacs command language is not powerful
enough as a programming language to be useful for writing anything
intelligent or general.  For such things, Lisp must be used.

* Menu:

* Basic Keyboard Macro::     Defining and running keyboard macros.
* Keyboard Macro Ring::      Where previous keyboard macros are saved.
* Keyboard Macro Counter::   Inserting incrementing numbers in macros.
* Keyboard Macro Query::     Making keyboard macros do different things each time.
* Save Keyboard Macro::      Giving keyboard macros names; saving them in files.
* Edit Keyboard Macro::      Editing keyboard macros.
* Keyboard Macro Step-Edit:: Interactively executing and editing a keyboard
                               macro.


File: emacs,  Node: Basic Keyboard Macro,  Next: Keyboard Macro Ring,  Up: Keyboard Macros

22.1 Basic Use
==============

`<F3>'
`C-x ('
     Start defining a keyboard macro (`kmacro-start-macro').

`<F4>'
     If a keyboard macro is being defined, end the definition;
     otherwise, execute the most recent keyboard macro
     (`kmacro-end-or-call-macro').

`C-x )'
     End the definition of a keyboard macro (`kmacro-end-macro').

`C-x e'
     Execute the most recent keyboard macro
     (`kmacro-end-and-call-macro').  First end the definition of the
     keyboard macro, if currently defining it.  To immediately execute
     the keyboard macro again, just repeat the `e'.

`C-u C-x ('
     Re-execute last keyboard macro, then add more keys to its
     definition.

`C-u C-u C-x ('
     Add more keys to the last keyboard macro without re-executing it.

`C-x C-k r'
     Run the last keyboard macro on each line that begins in the region
     (`apply-macro-to-region-lines').

   To start defining a keyboard macro, type the `F3' or `C-x (' command
(`kmacro-start-macro').  From then on, your keys continue to be
executed, but also become part of the definition of the macro.  `Def'
appears in the mode line to remind you of what is going on.  When you
are finished, the `F4' or `C-x )' command (`kmacro-end-macro')
terminates the definition (without becoming part of it!).  For example,

     C-x ( M-f foo C-x )

defines a macro to move forward a word and then insert `foo'.

   The macro thus defined can be invoked again with the `C-x e' command
(`kmacro-end-and-call-macro'), which may be given a repeat count as a
numeric argument to execute the macro many times.  If you enter `C-x e'
while defining a macro, the macro is terminated and executed
immediately.

   After executing the macro with `C-x e', you can use `e' repeatedly
to immediately repeat the macro one or more times.  For example,

     C-x ( xyz C-x e e e

inserts `xyzxyzxyzxyz' in the current buffer.

   `C-x )' can also be given a repeat count as an argument, in which
case it repeats the macro that many times right after defining it, but
defining the macro counts as the first repetition (since it is executed
as you define it).  Therefore, giving `C-x )' an argument of 4 executes
the macro immediately 3 additional times.  An argument of zero to `C-x
e' or `C-x )' means repeat the macro indefinitely (until it gets an
error or you type `C-g' or, on MS-DOS, `C-<BREAK>').

   The key <F4> is like a combination of `C-x )' and `C-x e'.  If
you're defining a macro, <F4> ends the definition.  Otherwise it
executes the last macro.  For example,

     F3 xyz F4 F4 F4

inserts `xyzxyzxyz' in the current buffer.

   If you wish to repeat an operation at regularly spaced places in the
text, define a macro and include as part of the macro the commands to
move to the next place you want to use it.  For example, if you want to
change each line, you should position point at the start of a line, and
define a macro to change that line and leave point at the start of the
next line.  Then repeating the macro will operate on successive lines.

   When a command reads an argument with the minibuffer, your
minibuffer input becomes part of the macro along with the command.  So
when you replay the macro, the command gets the same argument as when
you entered the macro.  For example,

     C-x ( C-a C-<SPC> C-n M-w C-x b f o o <RET> C-y C-x b <RET> C-x )

defines a macro that copies the current line into the buffer `foo',
then returns to the original buffer.

   You can use function keys in a keyboard macro, just like keyboard
keys.  You can even use mouse events, but be careful about that: when
the macro replays the mouse event, it uses the original mouse position
of that event, the position that the mouse had while you were defining
the macro.  The effect of this may be hard to predict.  (Using the
current mouse position would be even less predictable.)

   One thing that sometimes works badly in a keyboard macro is the
command `C-M-c' (`exit-recursive-edit').  When this command exits a
recursive edit that started within the macro, it works as you'd expect.
But if it exits a recursive edit that started before you invoked the
keyboard macro, it also necessarily exits the keyboard macro as part of
the process.

   After you have terminated the definition of a keyboard macro, you
can add to the end of its definition by typing `C-u F3' or `C-u C-x ('.
This is equivalent to plain `C-x (' followed by retyping the whole
definition so far.  As a consequence it re-executes the macro as
previously defined.

   You can also add to the end of the definition of the last keyboard
macro without re-executing it by typing `C-u C-u C-x ('.

   The variable `kmacro-execute-before-append' specifies whether a
single `C-u' prefix causes the existing macro to be re-executed before
appending to it.

   The command `C-x C-k r' (`apply-macro-to-region-lines') repeats the
last defined keyboard macro on each line that begins in the region.  It
does this line by line, by moving point to the beginning of the line
and then executing the macro.


File: emacs,  Node: Keyboard Macro Ring,  Next: Keyboard Macro Counter,  Prev: Basic Keyboard Macro,  Up: Keyboard Macros

22.2 The Keyboard Macro Ring
============================

All defined keyboard macros are recorded in the "keyboard macro ring,"
a list of sequences of keys.  There is only one keyboard macro ring,
shared by all buffers.

`C-x C-k C-k'
     Execute the keyboard macro at the head of the ring
     (`kmacro-end-or-call-macro-repeat').

`C-x C-k C-n'
     Rotate the keyboard macro ring to the next macro (defined earlier)
     (`kmacro-cycle-ring-next').

`C-x C-k C-p'
     Rotate the keyboard macro ring to the previous macro (defined
     later) (`kmacro-cycle-ring-previous').

   All commands which operate on the keyboard macro ring use the same
`C-x C-k' prefix.  Most of these commands can be executed and repeated
immediately after each other without repeating the `C-x C-k' prefix.
For example,

     C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

will rotate the keyboard macro ring to the "second previous" macro,
execute the resulting head macro three times, rotate back to the
original head macro, execute that once, rotate to the "previous" macro,
execute that, and finally delete it from the macro ring.

   The command `C-x C-k C-k' (`kmacro-end-or-call-macro-repeat')
executes the keyboard macro at the head of the macro ring.  You can
repeat the macro immediately by typing another `C-k', or you can rotate
the macro ring immediately by typing `C-n' or `C-p'.

   When a keyboard macro is being defined, `C-x C-k C-k' behaves like
`C-x )' except that, immediately afterward, you can use most key
bindings of this section without the `C-x C-k' prefix.  For instance,
another `C-k' will re-execute the macro.

   The commands `C-x C-k C-n' (`kmacro-cycle-ring-next') and `C-x C-k
C-p' (`kmacro-cycle-ring-previous') rotate the macro ring, bringing the
next or previous keyboard macro to the head of the macro ring.  The
definition of the new head macro is displayed in the echo area.  You
can continue to rotate the macro ring immediately by repeating just
`C-n' and `C-p' until the desired macro is at the head of the ring.  To
execute the new macro ring head immediately, just type `C-k'.

   Note that Emacs treats the head of the macro ring as the "last
defined keyboard macro."  For instance, `C-x e' will execute that
macro, and `C-x C-k n' will give it a name.

   The maximum number of macros stored in the keyboard macro ring is
determined by the customizable variable `kmacro-ring-max'.


File: emacs,  Node: Keyboard Macro Counter,  Next: Keyboard Macro Query,  Prev: Keyboard Macro Ring,  Up: Keyboard Macros

22.3 The Keyboard Macro Counter
===============================

`C-x C-k C-i'
     Insert the keyboard macro counter value in the buffer
     (`kmacro-insert-counter').

`C-x C-k C-c'
     Set the keyboard macro counter (`kmacro-set-counter').

`C-x C-k C-a'
     Add the prefix arg to the keyboard macro counter
     (`kmacro-add-counter').

`C-x C-k C-f'
     Specify the format for inserting the keyboard macro counter
     (`kmacro-set-format').

   Each keyboard macro has an associated counter.  Normally, the macro
counter is initialized to 0 when you start defining the macro, and
incremented by 1 after each insertion of the counter value; that is, if
you insert the macro counter twice while defining the macro, the
counter will increase by 2 on each repetition of the macro.

   The command `C-x C-k C-i' (`kmacro-insert-counter') inserts the
current value of the current keyboard macro's counter, and increments
the counter by 1.  You can use a numeric prefix argument to specify a
different increment.  If you just specify a `C-u' prefix, then the
increment is zero, so it repeats the last inserted counter value.  For
example, if you enter the following sequence while defining a macro

     C-x C-k C-i C-x C-k C-i C-u C-x C-k C-i C-x C-k C-i

it inserts `0112' in the buffer.  The next two iterations of the macro
will insert `3445' and `6778'.

   This command usually only makes sense while defining a keyboard
macro.  But its behavior when no keyboard macro is being defined or
executed is predictable: it inserts and increments the counter of the
macro at the head of the keyboard macro ring.

   The command `C-x C-k C-c' (`kmacro-set-counter') sets the current
macro counter to the value of the numeric argument.  If you use it
inside the macro, it operates on each repetition of the macro.  If you
specify just `C-u' as the prefix, while executing the macro, that
resets the counter to the value it had at the beginning of the current
repetition of the macro (undoing any increments so far in this
repetition).

   The command `C-x C-k C-a' (`kmacro-add-counter') adds the prefix
argument to the current macro counter.  With just `C-u' as argument, it
resets the counter to the last value inserted by any keyboard macro.
(Normally, when you use this, the last insertion will be in the same
macro and it will be the same counter.)

   The command `C-x C-k C-f' (`kmacro-set-format') prompts for the
format to use when inserting the macro counter.  The default format is
`%d', which means to insert the number in decimal without any padding.
You can exit with empty minibuffer to reset the format to this default.
You can specify any format string that the `format' function accepts
and that makes sense with a single integer extra argument (*note
Formatting Strings: (elisp)Formatting Strings.).  Do not put the format
string inside double quotes when you insert it in the minibuffer.

   If you use this command while no keyboard macro is being defined or
executed, the new format affects all subsequent macro definitions.
Existing macros continue to use the format in effect when they were
defined.  If you set the format while defining a keyboard macro, this
affects the macro being defined from that point on, but it does not
affect subsequent macros.  Execution of the macro will, at each step,
use the format in effect at that step during its definition.  Changes
to the macro format during execution of a macro, like the corresponding
changes during its definition, have no effect on subsequent macros.

   The format set by `C-x C-k C-f' does not affect insertion of numbers
stored in registers.


File: emacs,  Node: Keyboard Macro Query,  Next: Save Keyboard Macro,  Prev: Keyboard Macro Counter,  Up: Keyboard Macros

22.4 Executing Macros with Variations
=====================================

`C-x q'
     When this point is reached during macro execution, ask for
     confirmation (`kbd-macro-query').

   Using `C-x q' (`kbd-macro-query'), you can get an effect similar to
that of `query-replace', where the macro asks you each time around
whether to make a change.  While defining the macro, type `C-x q' at
the point where you want the query to occur.  During macro definition,
the `C-x q' does nothing, but when you run the macro later, `C-x q'
asks you interactively whether to continue.

   The valid responses when `C-x q' asks are <SPC> (or `y'), <DEL> (or
`n'), <RET> (or `q'), `C-l' and `C-r'.  The answers are the same as in
`query-replace', though not all of the `query-replace' options are
meaningful.

   These responses include <SPC> to continue, and <DEL> to skip the
remainder of this repetition of the macro and start right away with the
next repetition.  <RET> means to skip the remainder of this repetition
and cancel further repetitions.  `C-l' redraws the screen and asks you
again for a character to say what to do.

   `C-r' enters a recursive editing level, in which you can perform
editing which is not part of the macro.  When you exit the recursive
edit using `C-M-c', you are asked again how to continue with the
keyboard macro.  If you type a <SPC> at this time, the rest of the
macro definition is executed.  It is up to you to leave point and the
text in a state such that the rest of the macro will do what you want.

   `C-u C-x q', which is `C-x q' with a numeric argument, performs a
completely different function.  It enters a recursive edit reading
input from the keyboard, both when you type it during the definition of
the macro, and when it is executed from the macro.  During definition,
the editing you do inside the recursive edit does not become part of
the macro.  During macro execution, the recursive edit gives you a
chance to do some particularized editing on each repetition.  *Note
Recursive Edit::.

   Another way to vary the behavior of a keyboard macro is to use a
register as a counter, incrementing it on each repetition of the macro.
*Note RegNumbers::.


File: emacs,  Node: Save Keyboard Macro,  Next: Edit Keyboard Macro,  Prev: Keyboard Macro Query,  Up: Keyboard Macros

22.5 Naming and Saving Keyboard Macros
======================================

`C-x C-k n'
     Give a command name (for the duration of the Emacs session) to the
     most recently defined keyboard macro (`kmacro-name-last-macro').

`C-x C-k b'
     Bind the most recently defined keyboard macro to a key sequence
     (for the duration of the session) (`kmacro-bind-to-key').

`M-x insert-kbd-macro'
     Insert in the buffer a keyboard macro's definition, as Lisp code.

   If you wish to save a keyboard macro for later use, you can give it
a name using `C-x C-k n' (`kmacro-name-last-macro').  This reads a name
as an argument using the minibuffer and defines that name to execute
the last keyboard macro, in its current form.  (If you later add to the
definition of this macro, that does not alter the name's definition as
a macro.)  The macro name is a Lisp symbol, and defining it in this way
makes it a valid command name for calling with `M-x' or for binding a
key to with `global-set-key' (*note Keymaps::).  If you specify a name
that has a prior definition other than a keyboard macro, an error
message is shown and nothing is changed.

   You can also bind the last keyboard macro (in its current form) to a
key, using `C-x C-k b' (`kmacro-bind-to-key') followed by the key
sequence you want to bind.  You can bind to any key sequence in the
global keymap, but since most key sequences already have other
bindings, you should select the key sequence carefully.  If you try to
bind to a key sequence with an existing binding (in any keymap), this
command asks you for confirmation before replacing the existing binding.

   To avoid problems caused by overriding existing bindings, the key
sequences `C-x C-k 0' through `C-x C-k 9' and `C-x C-k A' through `C-x
C-k Z' are reserved for your own keyboard macro bindings.  In fact, to
bind to one of these key sequences, you only need to type the digit or
letter rather than the whole key sequences.  For example,

     C-x C-k b 4

will bind the last keyboard macro to the key sequence `C-x C-k 4'.

   Once a macro has a command name, you can save its definition in a
file.  Then it can be used in another editing session.  First, visit
the file you want to save the definition in.  Then use this command:

     M-x insert-kbd-macro <RET> MACRONAME <RET>

This inserts some Lisp code that, when executed later, will define the
same macro with the same definition it has now.  (You need not
understand Lisp code to do this, because `insert-kbd-macro' writes the
Lisp code for you.)  Then save the file.  You can load the file later
with `load-file' (*note Lisp Libraries::).  If the file you save in is
your init file `~/.emacs' (*note Init File::) then the macro will be
defined each time you run Emacs.

   If you give `insert-kbd-macro' a numeric argument, it makes
additional Lisp code to record the keys (if any) that you have bound to
MACRONAME, so that the macro will be reassigned the same keys when you
load the file.


File: emacs,  Node: Edit Keyboard Macro,  Next: Keyboard Macro Step-Edit,  Prev: Save Keyboard Macro,  Up: Keyboard Macros

22.6 Editing a Keyboard Macro
=============================

`C-x C-k C-e'
     Edit the last defined keyboard macro (`kmacro-edit-macro').

`C-x C-k e NAME <RET>'
     Edit a previously defined keyboard macro NAME (`edit-kbd-macro').

`C-x C-k l'
     Edit the last 100 keystrokes as a keyboard macro
     (`kmacro-edit-lossage').

   You can edit the last keyboard macro by typing `C-x C-k C-e' or `C-x
C-k RET' (`kmacro-edit-macro').  This formats the macro definition in a
buffer and enters a specialized major mode for editing it.  Type `C-h
m' once in that buffer to display details of how to edit the macro.
When you are finished editing, type `C-c C-c'.

   You can edit a named keyboard macro or a macro bound to a key by
typing `C-x C-k e' (`edit-kbd-macro').  Follow that with the keyboard
input that you would use to invoke the macro--`C-x e' or `M-x NAME' or
some other key sequence.

   You can edit the last 100 keystrokes as a macro by typing `C-x C-k
l' (`kmacro-edit-lossage').


File: emacs,  Node: Keyboard Macro Step-Edit,  Prev: Edit Keyboard Macro,  Up: Keyboard Macros

22.7 Stepwise Editing a Keyboard Macro
======================================

You can interactively replay and edit the last keyboard macro, one
command at a time, by typing `C-x C-k SPC' (`kmacro-step-edit-macro').
Unless you quit the macro using `q' or `C-g', the edited macro replaces
the last macro on the macro ring.

   This macro editing feature shows the last macro in the minibuffer
together with the first (or next) command to be executed, and prompts
you for an action.  You can enter `?' to get a summary of your options.
These actions are available:

   * `SPC' and `y' execute the current command, and advance to the next
     command in the keyboard macro.

   * `n', `d', and `DEL' skip and delete the current command.

   * `f' skips the current command in this execution of the keyboard
     macro, but doesn't delete it from the macro.

   * `<TAB>' executes the current command, as well as all similar
     commands immediately following the current command; for example,
     <TAB> may be used to insert a sequence of characters
     (corresponding to a sequence of `self-insert-command' commands).

   * `c' continues execution (without further editing) until the end of
     the keyboard macro.  If execution terminates normally, the edited
     macro replaces the original keyboard macro.

   * `C-k' skips and deletes the rest of the keyboard macro, terminates
     step-editing, and replaces the original keyboard macro with the
     edited macro.

   * `q' and `C-g' cancels the step-editing of the keyboard macro;
     discarding any changes made to the keyboard macro.

   * `i KEY... C-j' reads and executes a series of key sequences (not
     including the final `C-j'), and inserts them before the current
     command in the keyboard macro, without advancing over the current
     command.

   * `I KEY...' reads one key sequence, executes it, and inserts it
     before the current command in the keyboard macro, without advancing
     over the current command.

   * `r KEY... C-j' reads and executes a series of key sequences (not
     including the final `C-j'), and replaces the current command in
     the keyboard macro with them, advancing over the inserted key
     sequences.

   * `R KEY...' reads one key sequence, executes it, and replaces the
     current command in the keyboard macro with that key sequence,
     advancing over the inserted key sequence.

   * `a KEY... C-j' executes the current command, then reads and
     executes a series of key sequences (not including the final
     `C-j'), and inserts them after the current command in the keyboard
     macro; it then advances over the current command and the inserted
     key sequences.

   * `A KEY... C-j' executes the rest of the commands in the keyboard
     macro, then reads and executes a series of key sequences (not
     including the final `C-j'), and appends them at the end of the
     keyboard macro; it then terminates the step-editing and replaces
     the original keyboard macro with the edited macro.


File: emacs,  Node: Files,  Next: Buffers,  Prev: Keyboard Macros,  Up: Top

23 File Handling
****************

The operating system stores data permanently in named "files", so most
of the text you edit with Emacs comes from a file and is ultimately
stored in a file.

   To edit a file, you must tell Emacs to read the file and prepare a
buffer containing a copy of the file's text.  This is called "visiting"
the file.  Editing commands apply directly to text in the buffer; that
is, to the copy inside Emacs.  Your changes appear in the file itself
only when you "save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, keep multiple versions of them, and operate
on file directories.

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.

* Autorevert::          Auto Reverting non-file buffers.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Diff Mode::           Mode for editing file differences.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* File Archives::       Operating on tar, zip, jar etc. archive files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.
* File Name Cache::     Completion against a list of files you often use.
* File Conveniences::   Convenience Features for Finding Files.
* Filesets::            Handling sets of files.


File: emacs,  Node: File Names,  Next: Visiting,  Up: Files

23.1 File Names
===============

Most Emacs commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows which
file name to use for them.)  You enter the file name using the
minibuffer (*note Minibuffer::).  "Completion" is available (*note
Completion::) to make it easier to specify long file names.  When
completing file names, Emacs ignores those whose file-name extensions
appear in the variable `completion-ignored-extensions'; see *note
Completion Options::.

   For most operations, there is a "default file name" which is used if
you type just <RET> to enter an empty argument.  Normally the default
file name is the name of the file visited in the current buffer; this
makes it easy to operate on that file with any of the Emacs file
commands.

   Each buffer has a default directory which is normally the same as the
directory of the file visited in that buffer.  When you enter a file
name without a directory, the default directory is used.  If you specify
a directory in a relative fashion, with a name that does not start with
a slash, it is interpreted with respect to the default directory.  The
default directory is kept in the variable `default-directory', which
has a separate value in every buffer.

   The command `M-x pwd' displays the current buffer's default
directory, and the command `M-x cd' sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the `cd'
command is used.  A file-visiting buffer's default directory is
initialized to the directory of the file it visits.  If you create a
buffer with `C-x b', its default directory is copied from that of the
buffer that was current at the time.

   For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is normally `/u/rms/gnu/'.  If you type just
`foo', which does not specify a directory, it is short for
`/u/rms/gnu/foo'.  `../.login' would stand for `/u/rms/.login'.
`new/foo' would stand for the file name `/u/rms/gnu/new/foo'.

   The default directory actually appears in the minibuffer when the
minibuffer becomes active to read a file name.  This serves two
purposes: it _shows_ you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to _edit_ the default to specify a different directory.
This insertion of the default directory is inhibited if the variable
`insert-default-directory' is set to `nil'.

   Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name as part of the text.  The final minibuffer contents may look
invalid, but that is not so.  For example, if the minibuffer starts out
with `/usr/tmp/' and you add `/x1/rms/foo', you get
`/usr/tmp//x1/rms/foo'; but Emacs ignores everything through the first
slash in the double slash; the result is `/x1/rms/foo'.  *Note
Minibuffer File::.

   You can use `~/' in a file name to mean your home directory, or
`~USER-ID/' to mean the home directory of a user whose login name is
`user-id'(1).

   `$' in a file name is used to substitute an environment variable.
The environment variable name consists of all the alphanumeric
characters after the `$'; alternatively, it can be enclosed in braces
after the `$'.  For example, if you have used the shell command `export
FOO=rms/hacks' to set up an environment variable named `FOO', then you
can use `/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  If the environment variable is not defined, no
substitution occurs: `/u/$notdefined' stands for itself (assuming the
environment variable `notdefined' is not defined).

   Note that shell commands to set environment variables affect Emacs
only when done before Emacs is started.

   To access a file with `$' in its name, if the `$' causes expansion,
type `$$'.  This pair is converted to a single `$' at the same time as
variable substitution is performed for a single `$'.  Alternatively,
quote the whole file name with `/:' (*note Quoted File Names::).  File
names which begin with a literal `~' should also be quoted with `/:'.

   The Lisp function that performs the `$'-substitution is called
`substitute-in-file-name'.  The substitution is performed only on file
names read as such using the minibuffer.

   You can include non-ASCII characters in file names if you set the
variable `file-name-coding-system' to a non-`nil' value.  *Note File
Name Coding::.

   ---------- Footnotes ----------

   (1) On MS-Windows and MS-DOS systems, where a user doesn't have a
home directory, Emacs replaces `~/' with the value of the environment
variable `HOME'; see *note General Variables::.  On these systems, the
`~USER-ID/' construct is supported only for the current user, i.e.,
only if USER-ID is the current user's login name.


File: emacs,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

23.2 Visiting Files
===================

`C-x C-f'
     Visit a file (`find-file').

`C-x C-r'
     Visit a file for viewing, without allowing changes to it
     (`find-file-read-only').

`C-x C-v'
     Visit a different file instead of the one visited last
     (`find-alternate-file').

`C-x 4 f'
     Visit a file, in another window (`find-file-other-window').  Don't
     alter what is displayed in the selected window.

`C-x 5 f'
     Visit a file, in a new frame (`find-file-other-frame').  Don't
     alter what is displayed in the selected frame.

`M-x find-file-literally'
     Visit a file with no conversion of the contents.

   "Visiting" a file means reading its contents into an Emacs buffer so
you can edit them.  Emacs makes a new buffer for each file that you
visit.  We often say that this buffer "is visiting" that file, or that
the buffer's "visited file" is that file.  Emacs constructs the buffer
name from the file name by throwing away the directory, keeping just
the name proper.  For example, a file named `/usr/rms/emacs.tex' would
get a buffer named `emacs.tex'.  If there is already a buffer with that
name, Emacs constructs a unique name--the normal method is to append
`<2>', `<3>', and so on, but you can select other methods (*note
Uniquify::).

   Each window's mode line shows the name of the buffer that is being
displayed in that window, so you can always tell what buffer you are
editing.

   The changes you make with editing commands are made in the Emacs
buffer.  They do not take effect in the file that you visited, or any
permanent place, until you "save" the buffer.  Saving the buffer means
that Emacs writes the current contents of the buffer into its visited
file.  *Note Saving::.

   If a buffer contains changes that have not been saved, we say the
buffer is "modified".  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line
displays two stars near the left margin to indicate that the buffer is
modified.

   To visit a file, use the command `C-x C-f' (`find-file').  Follow
the command with the name of the file you wish to visit, terminated by a
<RET>.

   The file name is read using the minibuffer (*note Minibuffer::), with
defaulting and completion in the standard manner (*note File Names::).
While in the minibuffer, you can abort `C-x C-f' by typing `C-g'.
File-name completion ignores certain file names; for more about this,
see *note Completion Options::.

   Your confirmation that `C-x C-f' has completed successfully is the
appearance of new text on the screen and a new buffer name in the mode
line.  If the specified file does not exist and you could not create
it, or exists but you can't read it, then you get an error, with an
error message displayed in the echo area.

   If you visit a file that is already in Emacs, `C-x C-f' does not make
another copy.  It selects the existing buffer containing that file.
However, before doing so, it checks whether the file itself has changed
since you visited or saved it last.  If the file has changed, Emacs
offers to reread it.

   If you try to visit a file larger than
`large-file-warning-threshold' (the default is 10000000, which is about
10 megabytes), Emacs will ask you for confirmation first.  You can
answer `y' to proceed with visiting the file.  Note, however, that
Emacs cannot visit files that are larger than the maximum Emacs buffer
size, which is around 256 megabytes on 32-bit machines (*note
Buffers::).  If you try, Emacs will display an error message saying
that the maximum buffer size has been exceeded.

   On graphical displays there are two additional methods for visiting
files.  Firstly, when Emacs is built with a suitable GUI toolkit,
commands invoked with the mouse (by clicking on the menu bar or tool
bar) use the toolkit's standard File Selection dialog instead of
prompting for the file name in the minibuffer.  On Unix and GNU/Linux
platforms, Emacs does that when built with GTK, LessTif, and Motif
toolkits; on MS-Windows and Mac, the GUI version does that by default.
For information on how to customize this, see *note Dialog Boxes::.

   Secondly, Emacs supports "drag and drop"; dropping a file into an
ordinary Emacs window visits the file using that window.  However,
dropping a file into a window displaying a Dired buffer moves or copies
the file into the displayed directory.  For details, see *note Drag and
Drop::, and *note Misc Dired Features::.

   What if you want to create a new file?  Just visit it.  Emacs
displays `(New file)' in the echo area, but in other respects behaves
as if you had visited an existing empty file.  If you make any changes
and save them, the file is created.

   Emacs recognizes from the contents of a file which end-of-line
convention it uses to separate lines--newline (used on GNU/Linux and on
Unix), carriage-return linefeed (used on Microsoft systems), or just
carriage-return (used on the Macintosh)--and automatically converts the
contents to the normal Emacs convention, which is that the newline
character separates lines.  This is a part of the general feature of
coding system conversion (*note Coding Systems::), and makes it
possible to edit files imported from different operating systems with
equal convenience.  If you change the text and save the file, Emacs
performs the inverse conversion, changing newlines back into
carriage-return linefeed or just carriage-return if appropriate.

   If the file you specify is actually a directory, `C-x C-f' invokes
Dired, the Emacs directory browser, so that you can "edit" the contents
of the directory (*note Dired::).  Dired is a convenient way to view,
delete, or operate on the files in the directory.  However, if the
variable `find-file-run-dired' is `nil', then it is an error to try to
visit a directory.

   Files which are actually collections of other files, or "file
archives", are visited in special modes which invoke a Dired-like
environment to allow operations on archive members.  *Note File
Archives::, for more about these features.

   If the file name you specify contains shell-style wildcard
characters, Emacs visits all the files that match it.  (On
case-insensitive filesystems, Emacs matches the wildcards disregarding
the letter case.)  Wildcards include `?', `*', and `[...]' sequences.
To enter the wild card `?' in a file name in the minibuffer, you need
to type `C-q ?'.  *Note Quoted File Names::, for information on how to
visit a file whose name actually contains wildcard characters.  You can
disable the wildcard feature by customizing `find-file-wildcards'.

   If you visit a file that the operating system won't let you modify,
or that is marked read-only, Emacs makes the buffer read-only too, so
that you won't go ahead and make changes that you'll have trouble
saving afterward.  You can make the buffer writable with `C-x C-q'
(`toggle-read-only').  *Note Misc Buffer::.

   If you want to visit a file as read-only in order to protect
yourself from entering changes accidentally, visit it with the command
`C-x C-r' (`find-file-read-only') instead of `C-x C-f'.

   If you visit a nonexistent file unintentionally (because you typed
the wrong file name), use the `C-x C-v' command (`find-alternate-file')
to visit the file you really wanted.  `C-x C-v' is similar to `C-x
C-f', but it kills the current buffer (after first offering to save it
if it is modified).  When `C-x C-v' reads the file name to visit, it
inserts the entire default file name in the buffer, with point just
after the directory part; this is convenient if you made a slight error
in typing the name.

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If this command is used when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.

   `C-x 5 f' (`find-file-other-frame') is similar, but opens a new
frame, or makes visible any existing frame showing the file you seek.
This feature is available only when you are using a window system.
*Note Frames::.

   If you wish to edit a file as a sequence of ASCII characters with no
special encoding or conversion, use the `M-x find-file-literally'
command.  It visits a file, like `C-x C-f', but does not do format
conversion (*note Formatted Text::), character code conversion (*note
Coding Systems::), or automatic uncompression (*note Compressed
Files::), and does not add a final newline because of
`require-final-newline'.  If you already have visited the same file in
the usual (non-literal) manner, this command asks you whether to visit
it literally instead.

   Two special hook variables allow extensions to modify the operation
of visiting files.  Visiting a file that does not exist runs the
functions in the list `find-file-not-found-functions'; this variable
holds a list of functions, and the functions are called one by one
(with no arguments) until one of them returns non-`nil'.  This is not a
normal hook, and the name ends in `-functions' rather than `-hook' to
indicate that fact.

   Successful visiting of any file, whether existing or not, calls the
functions in the list `find-file-hook', with no arguments.  This
variable is a normal hook.  In the case of a nonexistent file, the
`find-file-not-found-functions' are run first.  *Note Hooks::.

   There are several ways to specify automatically the major mode for
editing the file (*note Choosing Modes::), and to specify local
variables defined for that file (*note File Variables::).


File: emacs,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

23.3 Saving Files
=================

"Saving" a buffer in Emacs means writing its contents back into the file
that was visited in the buffer.

* Menu:

* Save Commands::       Commands for saving files.
* Backup::              How Emacs saves the old version of your file.
* Customize Save::      Customizing the saving of files.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.
* Shadowing: File Shadowing.  Copying files to "shadows" automatically.
* Time Stamps::         Emacs can update time stamps on saved files.


File: emacs,  Node: Save Commands,  Next: Backup,  Up: Saving

23.3.1 Commands for Saving Files
--------------------------------

These are the commands that relate to saving and writing files.

`C-x C-s'
     Save the current buffer in its visited file on disk
     (`save-buffer').

`C-x s'
     Save any or all buffers in their visited files
     (`save-some-buffers').

`M-~'
     Forget that the current buffer has been changed (`not-modified').
     With prefix argument (`C-u'), mark the current buffer as changed.

`C-x C-w'
     Save the current buffer with a specified file name (`write-file').

`M-x set-visited-file-name'
     Change the file name under which the current buffer will be saved.

   When you wish to save the file and make your changes permanent, type
`C-x C-s' (`save-buffer').  After saving is finished, `C-x C-s'
displays a message like this:

     Wrote /u/rms/gnu/gnu.tasks

If the selected buffer is not modified (no changes have been made in it
since the buffer was created or last saved), saving is not really done,
because it would have no effect.  Instead, `C-x C-s' displays a message
like this in the echo area:

     (No changes need to be saved)

   The command `C-x s' (`save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  The
possible responses are analogous to those of `query-replace':

`y'
     Save this buffer and ask about the rest of the buffers.

`n'
     Don't save this buffer, but ask about the rest of the buffers.

`!'
     Save this buffer and all the rest with no more questions.

`<RET>'
     Terminate `save-some-buffers' without any more saving.

`.'
     Save this buffer, then exit `save-some-buffers' without even asking
     about other buffers.

`C-r'
     View the buffer that you are currently being asked about.  When
     you exit View mode, you get back to `save-some-buffers', which
     asks the question again.

`d'
     Diff the buffer against its corresponding file, so you can see
     what changes you would be saving.

`C-h'
     Display a help message about these options.

   `C-x C-c', the key sequence to exit Emacs, invokes
`save-some-buffers' and therefore asks the same questions.

   If you have changed a buffer but you do not want to save the changes,
you should take some action to prevent it.  Otherwise, each time you use
`C-x s' or `C-x C-c', you are liable to save this buffer by mistake.
One thing you can do is type `M-~' (`not-modified'), which clears out
the indication that the buffer is modified.  If you do this, none of
the save commands will believe that the buffer needs to be saved.  (`~'
is often used as a mathematical symbol for `not'; thus `M-~' is `not',
metafied.)  You could also use `set-visited-file-name' (see below) to
mark the buffer as visiting a different file name, one which is not in
use for anything important.  Alternatively, you can cancel all the
changes made since the file was visited or saved, by reading the text
from the file again.  This is called "reverting".  *Note Reverting::.
(You could also undo all the changes by repeating the undo command `C-x
u' until you have undone all the changes; but reverting is easier.)
You can also kill the buffer.

   `M-x set-visited-file-name' alters the name of the file that the
current buffer is visiting.  It reads the new file name using the
minibuffer.  Then it marks the buffer as visiting that file name, and
changes the buffer name correspondingly.  `set-visited-file-name' does
not save the buffer in the newly visited file; it just alters the
records inside Emacs in case you do save later.  It also marks the
buffer as "modified" so that `C-x C-s' in that buffer _will_ save.

   If you wish to mark the buffer as visiting a different file and save
it right away, use `C-x C-w' (`write-file').  It is equivalent to
`set-visited-file-name' followed by `C-x C-s' (except that `C-x C-w'
asks for confirmation if the file exists).  `C-x C-s' used on a buffer
that is not visiting a file has the same effect as `C-x C-w'; that is,
it reads a file name, marks the buffer as visiting that file, and saves
it there.  The default file name in a buffer that is not visiting a
file is made by combining the buffer name with the buffer's default
directory (*note File Names::).

   If the new file name implies a major mode, then `C-x C-w' switches
to that major mode, in most cases.  The command `set-visited-file-name'
also does this.  *Note Choosing Modes::.

   If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem
caused by simultaneous editing and requires your immediate attention.
*Note Simultaneous Editing: Interlocking.


File: emacs,  Node: Backup,  Next: Customize Save,  Prev: Save Commands,  Up: Saving

23.3.2 Backup Files
-------------------

On most operating systems, rewriting a file automatically destroys all
record of what the file used to contain.  Thus, saving a file from Emacs
throws away the old contents of the file--or it would, except that
Emacs carefully copies the old contents to another file, called the
"backup" file, before actually saving.

   For most files, the variable `make-backup-files' determines whether
to make backup files.  On most operating systems, its default value is
`t', so that Emacs does write backup files.

   For files managed by a version control system (*note Version
Control::), the variable `vc-make-backup-files' determines whether to
make backup files.  By default it is `nil', since backup files are
redundant when you store all the previous versions in a version control
system.  *Note General VC Options::.

   At your option, Emacs can keep either a single backup for each file,
or make a series of numbered backup files for each file that you edit.

   The default value of the `backup-enable-predicate' variable prevents
backup files being written for files in the directories used for
temporary files, specified by `temporary-file-directory' or
`small-temporary-file-directory'.

   Emacs makes a backup for a file only the first time the file is saved
from one buffer.  No matter how many times you save a file, its backup
file continues to contain the contents from before the file was visited.
Normally this means that the backup file contains the contents from
before the current editing session; however, if you kill the buffer and
then visit the file again, a new backup file will be made by the next
save.

   You can also explicitly request making another backup file from a
buffer even though it has already been saved at least once.  If you save
the buffer with `C-u C-x C-s', the version thus saved will be made into
a backup file if you save the buffer again.  `C-u C-u C-x C-s' saves
the buffer, but first makes the previous file contents into a new
backup file.  `C-u C-u C-u C-x C-s' does both things: it makes a backup
from the previous contents, and arranges to make another from the newly
saved contents if you save again.

* Menu:

* One or Many: Numbered Backups. Whether to make one backup file or many.
* Names: Backup Names.		How backup files are named.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.


File: emacs,  Node: Numbered Backups,  Next: Backup Names,  Up: Backup

23.3.2.1 Numbered Backups
.........................

The choice of single backup file or multiple numbered backup files is
controlled by the variable `version-control'.  Its possible values are:

`t'
     Make numbered backups.

`nil'
     Make numbered backups for files that have numbered backups already.
     Otherwise, make single backups.

`never'
     Never make numbered backups; always make single backups.

The usual way to set this variable is globally, through your `.emacs'
file or the customization buffer.  However, you can set
`version-control' locally in an individual buffer to control the making
of backups for that buffer's file.  For example, Rmail mode locally
sets `version-control' to `never' to make sure that there is only one
backup for an Rmail file.  *Note Locals::.

   If you set the environment variable `VERSION_CONTROL', to tell
various GNU utilities what to do with backup files, Emacs also obeys the
environment variable by setting the Lisp variable `version-control'
accordingly at startup.  If the environment variable's value is `t' or
`numbered', then `version-control' becomes `t'; if the value is `nil'
or `existing', then `version-control' becomes `nil'; if it is `never'
or `simple', then `version-control' becomes `never'.


File: emacs,  Node: Backup Names,  Next: Backup Deletion,  Prev: Numbered Backups,  Up: Backup

23.3.2.2 Single or Numbered Backups
...................................

When Emacs makes a single backup file, its name is normally constructed
by appending `~' to the file name being edited; thus, the backup file
for `eval.c' would be `eval.c~'.

   You can change this behavior by defining the variable
`make-backup-file-name-function' to a suitable function.  Alternatively
you can customize the variable `backup-directory-alist' to specify that
files matching certain patterns should be backed up in specific
directories.

   A typical use is to add an element `("." . DIR)' to make all backups
in the directory with absolute name DIR; Emacs modifies the backup file
names to avoid clashes between files with the same names originating in
different directories.  Alternatively, adding, say, `("." . ".~")'
would make backups in the invisible subdirectory `.~' of the original
file's directory.  Emacs creates the directory, if necessary, to make
the backup.

   If access control stops Emacs from writing backup files under the
usual names, it writes the backup file as `%backup%~' in your home
directory.  Only one such file can exist, so only the most recently
made such backup is available.

   If you choose to have a series of numbered backup files, backup file
names contain `.~', the number, and another `~' after the original file
name.  Thus, the backup files of `eval.c' would be called `eval.c.~1~',
`eval.c.~2~', and so on, all the way through names like `eval.c.~259~'
and beyond.  The variable `backup-directory-alist' applies to numbered
backups just as usual.


File: emacs,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

23.3.2.3 Automatic Deletion of Backups
......................................

To prevent excessive consumption of disk space, Emacs can delete
numbered backup versions automatically.  Generally Emacs keeps the
first few backups and the latest few backups, deleting any in between.
This happens every time a new backup is made.

   The two variables `kept-old-versions' and `kept-new-versions'
control this deletion.  Their values are, respectively, the number of
oldest (lowest-numbered) backups to keep and the number of newest
(highest-numbered) ones to keep, each time a new backup is made.  The
backups in the middle (excluding those oldest and newest) are the
excess middle versions--those backups are deleted.  These variables'
values are used when it is time to delete excess versions, just after a
new backup version is made; the newly made backup is included in the
count in `kept-new-versions'.  By default, both variables are 2.

   If `delete-old-versions' is `t', Emacs deletes the excess backup
files silently.  If it is `nil', the default, Emacs asks you whether it
should delete the excess backup versions.  If it has any other value,
then Emacs never automatically deletes backups.

   Dired's `.' (Period) command can also be used to delete old versions.
*Note Dired Deletion::.


File: emacs,  Node: Backup Copying,  Prev: Backup Deletion,  Up: Backup

23.3.2.4 Copying vs. Renaming
.............................

Backup files can be made by copying the old file or by renaming it.
This makes a difference when the old file has multiple names (hard
links).  If the old file is renamed into the backup file, then the
alternate names become names for the backup file.  If the old file is
copied instead, then the alternate names remain names for the file that
you are editing, and the contents accessed by those names will be the
new contents.

   The method of making a backup file may also affect the file's owner
and group.  If copying is used, these do not change.  If renaming is
used, you become the file's owner, and the file's group becomes the
default (different operating systems have different defaults for the
group).

   Having the owner change is usually a good idea, because then the
owner always shows who last edited the file.  Also, the owners of the
backups show who produced those versions.  Occasionally there is a file
whose owner should not change; it is a good idea for such files to
contain local variable lists to set `backup-by-copying-when-mismatch'
locally (*note File Variables::).

   The choice of renaming or copying is controlled by four variables.
Renaming is the default choice.  If the variable `backup-by-copying' is
non-`nil', copying is used.  Otherwise, if the variable
`backup-by-copying-when-linked' is non-`nil', then copying is used for
files that have multiple names, but renaming may still be used when the
file being edited has only one name.  If the variable
`backup-by-copying-when-mismatch' is non-`nil', then copying is used if
renaming would cause the file's owner or group to change.
`backup-by-copying-when-mismatch' is `t' by default if you start Emacs
as the superuser.  The fourth variable,
`backup-by-copying-when-privileged-mismatch', gives the highest numeric
user-id for which `backup-by-copying-when-mismatch' will be forced on.
This is useful when low-numbered user-ids are assigned to special
system users, such as `root', `bin', `daemon', etc., which must
maintain ownership of files.

   When a file is managed with a version control system (*note Version
Control::), Emacs does not normally make backups in the usual way for
that file.  But check-in and check-out are similar in some ways to
making backups.  One unfortunate similarity is that these operations
typically break hard links, disconnecting the file name you visited from
any alternate names for the same file.  This has nothing to do with
Emacs--the version control system does it.


File: emacs,  Node: Customize Save,  Next: Interlocking,  Prev: Backup,  Up: Saving

23.3.3 Customizing Saving of Files
----------------------------------

If the value of the variable `require-final-newline' is `t', saving or
writing a file silently puts a newline at the end if there isn't
already one there.  If the value is `visit', Emacs adds a newline at
the end of any file that doesn't have one, just after it visits the
file.  (This marks the buffer as modified, and you can undo it.)  If
the value is `visit-save', that means to add newlines both on visiting
and on saving.  If the value is `nil', Emacs leaves the end of the file
unchanged; if it's neither `nil' nor `t', Emacs asks you whether to add
a newline.  The default is `nil'.

   Many major modes are designed for specific kinds of files that are
always supposed to end in newlines.  These major modes set the variable
`require-final-newline' according to `mode-require-final-newline'.  By
setting the latter variable, you can control how these modes handle
final newlines.

   When Emacs saves a file, it invokes the `fsync' system call to force
the data immediately out to disk.  This is important for safety if the
system crashes or in case of power outage.  However, it can be
disruptive on laptops using power saving, because it requires the disk
to spin up each time you save a file.  Setting
`write-region-inhibit-fsync' to a non-`nil' value disables this
synchronization.  Be careful--this means increased risk of data loss.


File: emacs,  Node: Interlocking,  Next: File Shadowing,  Prev: Customize Save,  Up: Saving

23.3.4 Protection against Simultaneous Editing
----------------------------------------------

Simultaneous editing occurs when two users visit the same file, both
make changes, and then both save them.  If nobody were informed that
this was happening, whichever user saved first would later find that his
changes were lost.

   On some systems, Emacs notices immediately when the second user
starts to change the file, and issues an immediate warning.  On all
systems, Emacs checks when you save the file, and warns if you are
about to overwrite another user's changes.  You can prevent loss of the
other user's work by taking the proper corrective action instead of
saving the file.

   When you make the first modification in an Emacs buffer that is
visiting a file, Emacs records that the file is "locked" by you.  (It
does this by creating a symbolic link in the same directory with a
different name.)  Emacs removes the lock when you save the changes.  The
idea is that the file is locked whenever an Emacs buffer visiting it has
unsaved changes.

   If you begin to modify the buffer while the visited file is locked by
someone else, this constitutes a "collision".  When Emacs detects a
collision, it asks you what to do, by calling the Lisp function
`ask-user-about-lock'.  You can redefine this function for the sake of
customization.  The standard definition of this function asks you a
question and accepts three possible answers:

`s'
     Steal the lock.  Whoever was already changing the file loses the
     lock, and you gain the lock.

`p'
     Proceed.  Go ahead and edit the file despite its being locked by
     someone else.

`q'
     Quit.  This causes an error (`file-locked'), and the buffer
     contents remain unchanged--the modification you were trying to make
     does not actually take place.

   Note that locking works on the basis of a file name; if a file has
multiple names, Emacs does not realize that the two names are the same
file and cannot prevent two users from editing it simultaneously under
different names.  However, basing locking on names means that Emacs can
interlock the editing of new files that will not really exist until
they are saved.

   Some systems are not configured to allow Emacs to make locks, and
there are cases where lock files cannot be written.  In these cases,
Emacs cannot detect trouble in advance, but it still can detect the
collision when you try to save a file and overwrite someone else's
changes.

   If Emacs or the operating system crashes, this may leave behind lock
files which are stale, so you may occasionally get warnings about
spurious collisions.  When you determine that the collision is spurious,
just use `p' to tell Emacs to go ahead anyway.

   Every time Emacs saves a buffer, it first checks the
last-modification date of the existing file on disk to verify that it
has not changed since the file was last visited or saved.  If the date
does not match, it implies that changes were made in the file in some
other way, and these changes are about to be lost if Emacs actually
does save.  To prevent this, Emacs displays a warning message and asks
for confirmation before saving.  Occasionally you will know why the
file was changed and know that it does not matter; then you can answer
`yes' and proceed.  Otherwise, you should cancel the save with `C-g'
and investigate the situation.

   The first thing you should do when notified that simultaneous editing
has already taken place is to list the directory with `C-u C-x C-d'
(*note Directories::).  This shows the file's current author.  You
should attempt to contact him to warn him not to continue editing.
Often the next step is to save the contents of your Emacs buffer under a
different name, and use `diff' to compare the two files.


File: emacs,  Node: File Shadowing,  Next: Time Stamps,  Prev: Interlocking,  Up: Saving

23.3.5 Shadowing Files
----------------------

`M-x shadow-initialize'
     Set up file shadowing.

`M-x shadow-define-literal-group'
     Declare a single file to be shared between sites.

`M-x shadow-define-regexp-group'
     Make all files that match each of a group of files be shared
     between hosts.

`M-x shadow-define-cluster <RET> NAME <RET>'
     Define a shadow file cluster NAME.

`M-x shadow-copy-files'
     Copy all pending shadow files.

`M-x shadow-cancel'
     Cancel the instruction to shadow some files.

   You can arrange to keep identical "shadow" copies of certain files
in more than one place--possibly on different machines.  To do this,
first you must set up a "shadow file group", which is a set of
identically-named files shared between a list of sites.  The file group
is permanent and applies to further Emacs sessions as well as the
current one.  Once the group is set up, every time you exit Emacs, it
will copy the file you edited to the other files in its group.  You can
also do the copying without exiting Emacs, by typing `M-x
shadow-copy-files'.

   To set up a shadow file group, use `M-x shadow-define-literal-group'
or `M-x shadow-define-regexp-group'.  See their documentation strings
for further information.

   Before copying a file to its shadows, Emacs asks for confirmation.
You can answer "no" to bypass copying of this file, this time.  If you
want to cancel the shadowing permanently for a certain file, use `M-x
shadow-cancel' to eliminate or change the shadow file group.

   A "shadow cluster" is a group of hosts that share directories, so
that copying to or from one of them is sufficient to update the file on
all of them.  Each shadow cluster has a name, and specifies the network
address of a primary host (the one we copy files to), and a regular
expression that matches the host names of all the other hosts in the
cluster.  You can define a shadow cluster with `M-x
shadow-define-cluster'.


File: emacs,  Node: Time Stamps,  Prev: File Shadowing,  Up: Saving

23.3.6 Updating Time Stamps Automatically
-----------------------------------------

You can arrange to put a time stamp in a file, so that it will be
updated automatically each time you edit and save the file.  The time
stamp has to be in the first eight lines of the file, and you should
insert it like this:

     Time-stamp: <>

or like this:

     Time-stamp: " "

   Then add the hook function `time-stamp' to the hook
`before-save-hook'; that hook function will automatically update the
time stamp, inserting the current date and time when you save the file.
You can also use the command `M-x time-stamp' to update the time stamp
manually.  For other customizations, see the Custom group `time-stamp'.
Note that non-numeric fields in the time stamp are formatted according
to your locale setting (*note Environment::).


File: emacs,  Node: Reverting,  Next: Autorevert,  Prev: Saving,  Up: Files

23.4 Reverting a Buffer
=======================

If you have made extensive changes to a file and then change your mind
about them, you can get rid of them by reading in the previous version
of the file.  To do this, use `M-x revert-buffer', which operates on
the current buffer.  Since reverting a buffer unintentionally could lose
a lot of work, you must confirm this command with `yes'.

   `revert-buffer' tries to position point in such a way that, if the
file was edited only slightly, you will be at approximately the same
piece of text after reverting as before.  However, if you have made
drastic changes, point may wind up in a totally different piece of text.

   Reverting marks the buffer as "not modified" until another change is
made.

   Some kinds of buffers whose contents reflect data bases other than
files, such as Dired buffers, can also be reverted.  For them,
reverting means recalculating their contents from the appropriate data
base.  Buffers created explicitly with `C-x b' cannot be reverted;
`revert-buffer' reports an error when asked to do so.

   When you edit a file that changes automatically and frequently--for
example, a log of output from a process that continues to run--it may be
useful for Emacs to revert the file without querying you, whenever you
visit the file again with `C-x C-f'.

   To request this behavior, set the variable `revert-without-query' to
a list of regular expressions.  When a file name matches one of these
regular expressions, `find-file' and `revert-buffer' will revert it
automatically if it has changed--provided the buffer itself is not
modified.  (If you have edited the text, it would be wrong to discard
your changes.)

   You may find it useful to have Emacs revert files automatically when
they change.  Three minor modes are available to do this.

   `M-x global-auto-revert-mode' enables Global Auto-Revert mode, which
periodically checks all file buffers and reverts when the corresponding
file has changed.  `M-x auto-revert-mode' enables a local version,
Auto-Revert mode, which applies only to the current buffer.

   You can use Auto-Revert mode to "tail" a file such as a system log,
so that changes made to that file by other programs are continuously
displayed.  To do this, just move the point to the end of the buffer,
and it will stay there as the file contents change.  However, if you
are sure that the file will only change by growing at the end, use
Auto-Revert Tail mode instead (`auto-revert-tail-mode').  It is more
efficient for this.

   The variable `auto-revert-interval' controls how often to check for
a changed file.  Since checking a remote file is too slow, these modes
do not check or revert remote files.

   *Note VC Mode Line::, for Auto Revert peculiarities in buffers that
visit files under version control.


File: emacs,  Node: Autorevert,  Next: Auto Save,  Prev: Reverting,  Up: Files

23.5 Auto Reverting non-file Buffers
====================================

Normally Global Auto Revert Mode only reverts file buffers.  There are
two ways to auto-revert certain non-file buffers: enabling Auto Revert
Mode in those buffers (using `M-x auto-revert-mode') and setting
`global-auto-revert-non-file-buffers' to `t'.  The latter enables Auto
Reverting for all types of buffers for which it is implemented, that
is, for the types of buffers listed in the menu below.

   Like file buffers, non-file buffers should normally not revert while
you are working on them, or while they contain information that might
get lost after reverting.  Therefore, they do not revert if they are
"modified".  This can get tricky, because deciding when a non-file
buffer should be marked modified is usually more difficult than for
file buffers.

   Another tricky detail is that, for efficiency reasons, Auto Revert
often does not try to detect all possible changes in the buffer, only
changes that are "major" or easy to detect.  Hence, enabling
auto-reverting for a non-file buffer does not always guarantee that all
information in the buffer is up to date and does not necessarily make
manual reverts useless.

   At the other extreme, certain buffers automatically auto-revert every
`auto-revert-interval' seconds.  (This currently only applies to the
Buffer Menu.)  In this case, Auto Revert does not print any messages
while reverting, even when `auto-revert-verbose' is non-`nil'.

   The details depend on the particular types of buffers and are
explained in the corresponding sections.

* Menu:

* Auto Reverting the Buffer Menu::
* Auto Reverting Dired::
* Supporting additional buffers::


File: emacs,  Node: Auto Reverting the Buffer Menu,  Next: Auto Reverting Dired,  Up: Autorevert

23.5.1 Auto Reverting the Buffer Menu
-------------------------------------

If auto-reverting of non-file buffers is enabled, the Buffer Menu
automatically reverts every `auto-revert-interval' seconds, whether
there is a need for it or not.  (It would probably take longer to check
whether there is a need than to actually revert.)

   If the Buffer Menu inappropriately gets marked modified, just revert
it manually using `g' and auto-reverting will resume.  However, if you
marked certain buffers to get deleted or to be displayed, you have to
be careful, because reverting erases all marks.  The fact that adding
marks sets the buffer's modified flag prevents Auto Revert from
automatically erasing the marks.


File: emacs,  Node: Auto Reverting Dired,  Next: Supporting additional buffers,  Prev: Auto Reverting the Buffer Menu,  Up: Autorevert

23.5.2 Auto Reverting Dired buffers
-----------------------------------

Auto-reverting Dired buffers currently works on GNU or Unix style
operating systems.  It may not work satisfactorily on some other
systems.

   Dired buffers only auto-revert when the file list of the buffer's
main directory changes.  They do not auto-revert when information about
a particular file changes or when inserted subdirectories change.  To be
sure that _all_ listed information is up to date, you have to manually
revert using `g', _even_ if auto-reverting is enabled in the Dired
buffer.  Sometimes, you might get the impression that modifying or
saving files listed in the main directory actually does cause
auto-reverting.  This is because making changes to a file, or saving
it, very often causes changes in the directory itself, for instance,
through backup files or auto-save files.  However, this is not
guaranteed.

   If the Dired buffer is marked modified and there are no changes you
want to protect, then most of the time you can make auto-reverting
resume by manually reverting the buffer using `g'.  There is one
exception.  If you flag or mark files, you can safely revert the
buffer.  This will not erase the flags or marks (unless the marked file
has been deleted, of course).  However, the buffer will stay modified,
even after reverting, and auto-reverting will not resume.  This is
because, if you flag or mark files, you may be working on the buffer
and you might not want the buffer to change without warning.  If you
want auto-reverting to resume in the presence of marks and flags, mark
the buffer non-modified using `M-~'.  However, adding, deleting or
changing marks or flags will mark it modified again.

   Remote Dired buffers are not auto-reverted.  Neither are Dired
buffers for which you used shell wildcards or file arguments to list
only some of the files.  `*Find*' and `*Locate*' buffers do not
auto-revert either.


File: emacs,  Node: Supporting additional buffers,  Prev: Auto Reverting Dired,  Up: Autorevert

23.5.3 Adding Support for Auto-Reverting additional Buffers.
------------------------------------------------------------

This section is intended for Elisp programmers who would like to add
support for auto-reverting new types of buffers.

   To support auto-reverting the buffer must first of all have a
`revert-buffer-function'.  *Note Reverting: (elisp)Definition of
revert-buffer-function.

   In addition, it _must_ have a `buffer-stale-function'.

 -- Variable: buffer-stale-function
     The value of this variable is a function to check whether a
     non-file buffer needs reverting.  This should be a function with
     one optional argument NOCONFIRM.  The function should return
     non-`nil' if the buffer should be reverted.  The buffer is current
     when this function is called.

     While this function is mainly intended for use in auto-reverting,
     it could be used for other purposes as well.  For instance, if
     auto-reverting is not enabled, it could be used to warn the user
     that the buffer needs reverting.  The idea behind the NOCONFIRM
     argument is that it should be `t' if the buffer is going to be
     reverted without asking the user and `nil' if the function is just
     going to be used to warn the user that the buffer is out of date.
     In particular, for use in auto-reverting, NOCONFIRM is `t'.  If
     the function is only going to be used for auto-reverting, you can
     ignore the NOCONFIRM argument.

     If you just want to automatically auto-revert every
     `auto-revert-interval' seconds, use:

          (set (make-local-variable 'buffer-stale-function)
               #'(lambda (&optional noconfirm) 'fast))

     in the buffer's mode function.

     The special return value `fast' tells the caller that the need for
     reverting was not checked, but that reverting the buffer is fast.
     It also tells Auto Revert not to print any revert messages, even if
     `auto-revert-verbose' is non-`nil'.  This is important, as getting
     revert messages every `auto-revert-interval' seconds can be very
     annoying.  The information provided by this return value could
     also be useful if the function is consulted for purposes other than
     auto-reverting.

   Once the buffer has a `revert-buffer-function' and a
`buffer-stale-function', several problems usually remain.

   The buffer will only auto-revert if it is marked unmodified.  Hence,
you will have to make sure that various functions mark the buffer
modified if and only if either the buffer contains information that
might be lost by reverting or there is reason to believe that the user
might be inconvenienced by auto-reverting, because he is actively
working on the buffer.  The user can always override this by manually
adjusting the modified status of the buffer.  To support this, calling
the `revert-buffer-function' on a buffer that is marked unmodified
should always keep the buffer marked unmodified.

   It is important to assure that point does not continuously jump
around as a consequence of auto-reverting.  Of course, moving point
might be inevitable if the buffer radically changes.

   You should make sure that the `revert-buffer-function' does not
print messages that unnecessarily duplicate Auto Revert's own messages
if `auto-revert-verbose' is `t' and effectively override a `nil' value
for `auto-revert-verbose'.  Hence, adapting a mode for auto-reverting
often involves getting rid of such messages.  This is especially
important for buffers that automatically auto-revert every
`auto-revert-interval' seconds.

   Also, you may want to update the documentation string of
`global-auto-revert-non-file-buffers'.

   Finally, you should add a node to this chapter's menu.  This node
should at the very least make clear whether enabling auto-reverting for
the buffer reliably assures that all information in the buffer is
completely up to date (or will be after `auto-revert-interval' seconds).


File: emacs,  Node: Auto Save,  Next: File Aliases,  Prev: Autorevert,  Up: Files

23.6 Auto-Saving: Protection Against Disasters
==============================================

Emacs saves all the visited files from time to time (based on counting
your keystrokes) without being asked, in separate files so as not to
alter the files you actually use.  This is called "auto-saving".  It
prevents you from losing more than a limited amount of work if the
system crashes.

   When Emacs determines that it is time for auto-saving, it considers
each buffer, and each is auto-saved if auto-saving is enabled for it
and it has been changed since the last time it was auto-saved.  The
message `Auto-saving...' is displayed in the echo area during
auto-saving, if any files are actually auto-saved.  Errors occurring
during auto-saving are caught so that they do not interfere with the
execution of commands you have been typing.

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.


File: emacs,  Node: Auto Save Files,  Next: Auto Save Control,  Up: Auto Save

23.6.1 Auto-Save Files
----------------------

Auto-saving does not normally save in the files that you visited,
because it can be very undesirable to save a program that is in an
inconsistent state when you have made half of a planned change.
Instead, auto-saving is done in a different file called the "auto-save
file", and the visited file is changed only when you request saving
explicitly (such as with `C-x C-s').

   Normally, the auto-save file name is made by appending `#' to the
front and rear of the visited file name.  Thus, a buffer visiting file
`foo.c' is auto-saved in a file `#foo.c#'.  Most buffers that are not
visiting files are auto-saved only if you request it explicitly; when
they are auto-saved, the auto-save file name is made by appending `#'
to the front and rear of buffer name, then adding digits and letters at
the end for uniqueness.  For example, the `*mail*' buffer in which you
compose messages to be sent might be auto-saved in a file named
`#*mail*#704juu'.  Auto-save file names are made this way unless you
reprogram parts of Emacs to do something different (the functions
`make-auto-save-file-name' and `auto-save-file-name-p').  The file name
to be used for auto-saving in a buffer is calculated when auto-saving
is turned on in that buffer.

   The variable `auto-save-file-name-transforms' allows a degree of
control over the auto-save file name.  It lets you specify a series of
regular expressions and replacements to transform the auto save file
name.  The default value puts the auto-save files for remote files
(*note Remote Files::) into the temporary file directory on the local
machine.

   When you delete a substantial part of the text in a large buffer,
auto save turns off temporarily in that buffer.  This is because if you
deleted the text unintentionally, you might find the auto-save file more
useful if it contains the deleted text.  To reenable auto-saving after
this happens, save the buffer with `C-x C-s', or use `C-u 1 M-x
auto-save-mode'.

   If you want auto-saving to be done in the visited file rather than
in a separate auto-save file, set the variable
`auto-save-visited-file-name' to a non-`nil' value.  In this mode,
there is no real difference between auto-saving and explicit saving.

   A buffer's auto-save file is deleted when you save the buffer in its
visited file.  (You can inhibit this by setting the variable
`delete-auto-save-files' to `nil'.)  Changing the visited file name
with `C-x C-w' or `set-visited-file-name' renames any auto-save file to
go with the new visited name.


File: emacs,  Node: Auto Save Control,  Next: Recover,  Prev: Auto Save Files,  Up: Auto Save

23.6.2 Controlling Auto-Saving
------------------------------

Each time you visit a file, auto-saving is turned on for that file's
buffer if the variable `auto-save-default' is non-`nil' (but not in
batch mode; *note Entering Emacs::).  The default for this variable is
`t', so auto-saving is the usual practice for file-visiting buffers.
Auto-saving can be turned on or off for any existing buffer with the
command `M-x auto-save-mode'.  Like other minor mode commands, `M-x
auto-save-mode' turns auto-saving on with a positive argument, off with
a zero or negative argument; with no argument, it toggles.

   Emacs does auto-saving periodically based on counting how many
characters you have typed since the last time auto-saving was done.
The variable `auto-save-interval' specifies how many characters there
are between auto-saves.  By default, it is 300.  Emacs doesn't accept
values that are too small: if you customize `auto-save-interval' to a
value less than 20, Emacs will behave as if the value is 20.

   Auto-saving also takes place when you stop typing for a while.  The
variable `auto-save-timeout' says how many seconds Emacs should wait
before it does an auto save (and perhaps also a garbage collection).
(The actual time period is longer if the current buffer is long; this
is a heuristic which aims to keep out of your way when you are editing
long buffers, in which auto-save takes an appreciable amount of time.)
Auto-saving during idle periods accomplishes two things: first, it
makes sure all your work is saved if you go away from the terminal for
a while; second, it may avoid some auto-saving while you are actually
typing.

   Emacs also does auto-saving whenever it gets a fatal error.  This
includes killing the Emacs job with a shell command such as `kill
%emacs', or disconnecting a phone line or network connection.

   You can request an auto-save explicitly with the command `M-x
do-auto-save'.


File: emacs,  Node: Recover,  Prev: Auto Save Control,  Up: Auto Save

23.6.3 Recovering Data from Auto-Saves
--------------------------------------

You can use the contents of an auto-save file to recover from a loss of
data with the command `M-x recover-file <RET> FILE <RET>'.  This visits
FILE and then (after your confirmation) restores the contents from its
auto-save file `#FILE#'.  You can then save with `C-x C-s' to put the
recovered text into FILE itself.  For example, to recover file `foo.c'
from its auto-save file `#foo.c#', do:

     M-x recover-file <RET> foo.c <RET>
     yes <RET>
     C-x C-s

   Before asking for confirmation, `M-x recover-file' displays a
directory listing describing the specified file and the auto-save file,
so you can compare their sizes and dates.  If the auto-save file is
older, `M-x recover-file' does not offer to read it.

   If Emacs or the computer crashes, you can recover all the files you
were editing from their auto save files with the command `M-x
recover-session'.  This first shows you a list of recorded interrupted
sessions.  Move point to the one you choose, and type `C-c C-c'.

   Then `recover-session' asks about each of the files that were being
edited during that session, asking whether to recover that file.  If
you answer `y', it calls `recover-file', which works in its normal
fashion.  It shows the dates of the original file and its auto-save
file, and asks once again whether to recover that file.

   When `recover-session' is done, the files you've chosen to recover
are present in Emacs buffers.  You should then save them.  Only
this--saving them--updates the files themselves.

   Emacs records information about interrupted sessions for later
recovery in files named
`~/.emacs.d/auto-save-list/.saves-PID-HOSTNAME'.  All of this name
except the `PID-HOSTNAME' part comes from the value of
`auto-save-list-file-prefix'.  You can record sessions in a different
place by customizing that variable.  If you set
`auto-save-list-file-prefix' to `nil' in your `.emacs' file, sessions
are not recorded for recovery.


File: emacs,  Node: File Aliases,  Next: Version Control,  Prev: Auto Save,  Up: Files

23.7 File Name Aliases
======================

Symbolic links and hard links both make it possible for several file
names to refer to the same file.  Hard links are alternate names that
refer directly to the file; all the names are equally valid, and no one
of them is preferred.  By contrast, a symbolic link is a kind of defined
alias: when `foo' is a symbolic link to `bar', you can use either name
to refer to the file, but `bar' is the real name, while `foo' is just
an alias.  More complex cases occur when symbolic links point to
directories.

   Normally, if you visit a file which Emacs is already visiting under
a different name, Emacs displays a message in the echo area and uses
the existing buffer visiting that file.  This can happen on systems
that support hard or symbolic links, or if you use a long file name on
a system that truncates long file names, or on a case-insensitive file
system.  You can suppress the message by setting the variable
`find-file-suppress-same-file-warnings' to a non-`nil' value.  You can
disable this feature entirely by setting the variable
`find-file-existing-other-name' to `nil': then if you visit the same
file under two different names, you get a separate buffer for each file
name.

   If the variable `find-file-visit-truename' is non-`nil', then the
file name recorded for a buffer is the file's "truename" (made by
replacing all symbolic links with their target names), rather than the
name you specify.  Setting `find-file-visit-truename' also implies the
effect of `find-file-existing-other-name'.


File: emacs,  Node: Version Control,  Next: Directories,  Prev: File Aliases,  Up: Files

23.8 Version Control
====================

"Version control systems" are packages that can record multiple
versions of a source file, usually storing the unchanged parts of the
file just once.  Version control systems also record history information
such as the creation time of each version, who created it, and a
description of what was changed in that version.

   The Emacs version control interface is called VC.  Its commands work
with different version control systems--currently, it supports CVS, GNU
Arch, RCS, Meta-CVS, Subversion, and SCCS.  Of these, the GNU project
distributes CVS, GNU Arch, and RCS; we recommend that you use either
CVS or GNU Arch for your projects, and RCS for individual files.  We
also have free software to replace SCCS, known as CSSC; if you are
using SCCS and don't want to make the incompatible change to RCS or
CVS, you can switch to CSSC.

   VC is enabled by default in Emacs.  To disable it, set the
customizable variable `vc-handled-backends' to `nil' (*note Customizing
VC::).

* Menu:

* Introduction to VC::  How version control works in general.
* VC Mode Line::        How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands::    The commands used a little less frequently.
* Branches::            Multiple lines of development.

* Remote Repositories:: Efficient access to remote CVS servers.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.


File: emacs,  Node: Introduction to VC,  Next: VC Mode Line,  Up: Version Control

23.8.1 Introduction to Version Control
--------------------------------------

VC allows you to use a version control system from within Emacs,
integrating the version control operations smoothly with editing.  VC
provides a uniform interface to version control, so that regardless of
which version control system is in use, you can use it the same way.

   This section provides a general overview of version control, and
describes the version control systems that VC supports.  You can skip
this section if you are already familiar with the version control system
you want to use.

* Menu:

* Version Systems::  Supported version control back-end systems.
* VC Concepts::      Words and concepts related to version control.
* Types of Log File::    The per-file VC log in contrast to the ChangeLog.


File: emacs,  Node: Version Systems,  Next: VC Concepts,  Up: Introduction to VC

23.8.1.1 Supported Version Control Systems
..........................................

VC currently works with six different version control systems or "back
ends": CVS, GNU Arch, RCS, Meta-CVS, Subversion, and SCCS.

   CVS is a free version control system that is used for the majority
of free software projects today.  It allows concurrent multi-user
development either locally or over the network.  Some of its
shortcomings, corrected by newer systems such as GNU Arch, are that it
lacks atomic commits or support for renaming files.  VC supports all
basic editing operations under CVS, but for some less common tasks you
still need to call CVS from the command line.  Note also that before
using CVS you must set up a repository, which is a subject too complex
to treat here.

   GNU Arch is a new version control system that is designed for
distributed work.  It differs in many ways from old well-known systems,
such as CVS and RCS.  It supports different transports for
interoperating between users, offline operations, and it has good
branching and merging features.  It also supports atomic commits, and
history of file renaming and moving.  VC does not support all
operations provided by GNU Arch, so you must sometimes invoke it from
the command line, or use a specialized module.

   RCS is the free version control system around which VC was initially
built.  The VC commands are therefore conceptually closest to RCS.
Almost everything you can do with RCS can be done through VC.  You
cannot use RCS over the network though, and it only works at the level
of individual files, rather than projects.  You should use it if you
want a simple, yet reliable tool for handling individual files.

   Subversion is a free version control system designed to be similar
to CVS but without CVS's problems.  Subversion supports atomic commits,
and versions directories, symbolic links, meta-data, renames, copies,
and deletes.  It can be used via http or via its own protocol.

   Meta-CVS is another attempt to solve problems arising in CVS.  It
supports directory structure versioning, improved branching and
merging, and use of symbolic links and meta-data in repositories.

   SCCS is a proprietary but widely used version control system.  In
terms of capabilities, it is the weakest of the six that VC supports.
VC compensates for certain features missing in SCCS (snapshots, for
example) by implementing them itself, but some other VC features, such
as multiple branches, are not available with SCCS.  Since SCCS is
non-free, not respecting its users freedom, you should not use it; use
its free replacement CSSC instead.  But you should use CSSC only if for
some reason you cannot use RCS, or one of the higher-level systems such
as CVS or GNU Arch.

   In the following, we discuss mainly RCS, SCCS and CVS.  Nearly
everything said about CVS applies to GNU Arch, Subversion and Meta-CVS
as well.


File: emacs,  Node: VC Concepts,  Next: Types of Log File,  Prev: Version Systems,  Up: Introduction to VC

23.8.1.2 Concepts of Version Control
....................................

When a file is under version control, we also say that it is
"registered" in the version control system.  Each registered file has a
corresponding "master file" which represents the file's present state
plus its change history--enough to reconstruct the current version or
any earlier version.  Usually the master file also records a "log
entry" for each version, describing in words what was changed in that
version.

   The file that is maintained under version control is sometimes called
the "work file" corresponding to its master file.  You edit the work
file and make changes in it, as you would with an ordinary file.  (With
SCCS and RCS, you must "lock" the file before you start to edit it.)
After you are done with a set of changes, you "check the file in",
which records the changes in the master file, along with a log entry for
them.

   With CVS, there are usually multiple work files corresponding to a
single master file--often each user has his own copy.  It is also
possible to use RCS in this way, but this is not the usual way to use
RCS.

   A version control system typically has some mechanism to coordinate
between users who want to change the same file.  One method is
"locking" (analogous to the locking that Emacs uses to detect
simultaneous editing of a file, but distinct from it).  The other method
is to merge your changes with other people's changes when you check them
in.

   With version control locking, work files are normally read-only so
that you cannot change them.  You ask the version control system to make
a work file writable for you by locking it; only one user can do this
at any given time.  When you check in your changes, that unlocks the
file, making the work file read-only again.  This allows other users to
lock the file to make further changes.  SCCS always uses locking, and
RCS normally does.

   The other alternative for RCS is to let each user modify the work
file at any time.  In this mode, locking is not required, but it is
permitted; check-in is still the way to record a new version.

   CVS normally allows each user to modify his own copy of the work file
at any time, but requires merging with changes from other users at
check-in time.  However, CVS can also be set up to require locking.
(*note CVS Options::).


File: emacs,  Node: Types of Log File,  Prev: VC Concepts,  Up: Introduction to VC

23.8.1.3 Types of Log File
..........................

Projects that use a revision control system can have _two_ types of log
for changes.  One is the per-file log maintained by the revision
control system: each time you check in a change, you must fill out a
"log entry" for the change (*note Log Buffer::).  This kind of log is
called the "version control log", also the "revision control log", "RCS
log", or "CVS log".

   The other kind of log is the file `ChangeLog' (*note Change Log::).
It provides a chronological record of all changes to a large portion of
a program--typically one directory and its subdirectories.  A small
program would use one `ChangeLog' file; a large program may well merit
a `ChangeLog' file in each major directory.  *Note Change Log::.

   A project maintained with version control can use just the per-file
log, or it can use both kinds of logs.  It can handle some files one
way and some files the other way.  Each project has its policy, which
you should follow.

   When the policy is to use both, you typically want to write an entry
for each change just once, then put it into both logs.  You can write
the entry in `ChangeLog', then copy it to the log buffer when you check
in the change.  Or you can write the entry in the log buffer while
checking in the change, and later use the `C-x v a' command to copy it
to `ChangeLog' (*note Change Logs and VC::).


File: emacs,  Node: VC Mode Line,  Next: Basic VC Editing,  Prev: Introduction to VC,  Up: Version Control

23.8.2 Version Control and the Mode Line
----------------------------------------

When you visit a file that is under version control, Emacs indicates
this on the mode line.  For example, `RCS-1.3' says that RCS is used
for that file, and the current version is 1.3.

   The character between the back-end name and the version number
indicates the version control status of the file.  `-' means that the
work file is not locked (if locking is in use), or not modified (if
locking is not in use).  `:' indicates that the file is locked, or that
it is modified.  If the file is locked by some other user (for
instance, `jim'), that is displayed as `RCS:jim:1.3'.

   When Auto Revert mode (*note Reverting::) reverts a buffer that is
under version control, it updates the version control information in
the mode line.  However, Auto Revert mode may not properly update this
information if the version control status changes without changes to
the work file, from outside the current Emacs session.  If you set
`auto-revert-check-vc-info' to `t', Auto Revert mode updates the
version control status information every `auto-revert-interval'
seconds, even if the work file itself is unchanged.  The resulting CPU
usage depends on the version control system, but is usually not
excessive.


File: emacs,  Node: Basic VC Editing,  Next: Old Versions,  Prev: VC Mode Line,  Up: Version Control

23.8.3 Basic Editing under Version Control
------------------------------------------

The principal VC command is an all-purpose command that performs either
locking or check-in, depending on the situation.

`C-x v v'
     Perform the next logical version control operation on this file.

   The precise action of this command depends on the state of the file,
and whether the version control system uses locking or not.  SCCS and
RCS normally use locking; CVS normally does not use locking.

   As a special convenience that is particularly useful for files with
locking, you can let Emacs check a file in or out whenever you change
its read-only flag.  This means, for example, that you cannot
accidentally edit a file without properly checking it out first.  To
achieve this, bind the key `C-x C-q' to `vc-toggle-read-only' in your
`~/.emacs' file.  (*Note Init Rebinding::.)

* Menu:

* VC with Locking::     RCS in its default mode, SCCS, and optionally CVS.
* Without Locking::     Without locking: default mode for CVS.
* Advanced C-x v v::    Advanced features available with a prefix argument.
* Log Buffer::          Features available in log entry buffers.


File: emacs,  Node: VC with Locking,  Next: Without Locking,  Up: Basic VC Editing

23.8.3.1 Basic Version Control with Locking
...........................................

If locking is used for the file (as with SCCS, and RCS in its default
mode), `C-x v v' can either lock a file or check it in:

   * If the file is not locked, `C-x v v' locks it, and makes it
     writable so that you can change it.

   * If the file is locked by you, and contains changes, `C-x v v'
     checks in the changes.  In order to do this, it first reads the
     log entry for the new version.  *Note Log Buffer::.

   * If the file is locked by you, but you have not changed it since you
     locked it, `C-x v v' releases the lock and makes the file read-only
     again.

   * If the file is locked by some other user, `C-x v v' asks you
     whether you want to "steal the lock" from that user.  If you say
     yes, the file becomes locked by you, but a message is sent to the
     person who had formerly locked the file, to inform him of what has
     happened.

   These rules also apply when you use CVS in locking mode, except that
there is no such thing as stealing a lock.


File: emacs,  Node: Without Locking,  Next: Advanced C-x v v,  Prev: VC with Locking,  Up: Basic VC Editing

23.8.3.2 Basic Version Control without Locking
..............................................

When there is no locking--the default for CVS--work files are always
writable; you do not need to do anything before you begin to edit a
file.  The status indicator on the mode line is `-' if the file is
unmodified; it flips to `:' as soon as you save any changes in the work
file.

   Here is what `C-x v v' does when using CVS:

   * If some other user has checked in changes into the master file,
     Emacs asks you whether you want to merge those changes into your
     own work file.  You must do this before you can check in your own
     changes.  (To pick up any recent changes from the master file
     _without_ trying to commit your own changes, type `C-x v m <RET>'.)
     *Note Merging::.

   * If there are no new changes in the master file, but you have made
     modifications in your work file, `C-x v v' checks in your changes.
     In order to do this, it first reads the log entry for the new
     version.  *Note Log Buffer::.

   * If the file is not modified, the `C-x v v' does nothing.

   These rules also apply when you use RCS in the mode that does not
require locking, except that automatic merging of changes from the
master file is not implemented.  Unfortunately, this means that nothing
informs you if another user has checked in changes in the same file
since you began editing it, and when this happens, his changes will be
effectively removed when you check in your version (though they will
remain in the master file, so they will not be entirely lost).  You must
therefore verify that the current version is unchanged, before you
check in your changes.  We hope to eliminate this risk and provide
automatic merging with RCS in a future Emacs version.

   In addition, locking is possible with RCS even in this mode, although
it is not required; `C-x v v' with an unmodified file locks the file,
just as it does with RCS in its normal (locking) mode.


File: emacs,  Node: Advanced C-x v v,  Next: Log Buffer,  Prev: Without Locking,  Up: Basic VC Editing

23.8.3.3 Advanced Control in `C-x v v'
......................................

When you give a prefix argument to `vc-next-action' (`C-u C-x v v'), it
still performs the next logical version control operation, but accepts
additional arguments to specify precisely how to do the operation.

   * If the file is modified (or locked), you can specify the version
     number to use for the new version that you check in.  This is one
     way to create a new branch (*note Branches::).

   * If the file is not modified (and unlocked), you can specify the
     version to select; this lets you start working from an older
     version, or on another branch.  If you do not enter any version,
     that takes you to the highest version on the current branch;
     therefore `C-u C-x v v <RET>' is a convenient way to get the
     latest version of a file from the repository.

   * Instead of the version number, you can also specify the name of a
     version control system.  This is useful when one file is being
     managed with two version control systems at the same time (*note
     Local Version Control::).



File: emacs,  Node: Log Buffer,  Prev: Advanced C-x v v,  Up: Basic VC Editing

23.8.3.4 Features of the Log Entry Buffer
.........................................

When you check in changes, `C-x v v' first reads a log entry.  It pops
up a buffer called `*VC-Log*' for you to enter the log entry.

   Sometimes the `*VC-Log*' buffer contains default text when you enter
it, typically the last log message entered.  If it does, mark and point
are set around the entire contents of the buffer so that it is easy to
kill the contents of the buffer with `C-w'.

   If you work by writing entries in the `ChangeLog' (*note Change
Log::) and then commit the change under revision control, you can
generate the Log Edit text from the ChangeLog using `C-c C-a'
(`log-edit-insert-changelog').  This looks for entries for the file(s)
concerned in the top entry in the ChangeLog and uses those paragraphs
as the log text.  This text is only inserted if the top entry was made
under your user name on the current date.  *Note Change Logs and VC::,
for the opposite way of working--generating ChangeLog entries from the
revision control log.

   In the `*VC-Log*' buffer, `C-c C-f' (`M-x log-edit-show-files')
shows the list of files to be committed in case you need to check that.
(This can be a list of more than one file if you use VC Dired mode or
PCL-CVS.  *Note VC Dired Mode::, and *note About PCL-CVS: (pcl-cvs)Top.)

   When you have finished editing the log message, type `C-c C-c' to
exit the buffer and commit the change.

   To abort check-in, just *don't* type `C-c C-c' in that buffer.  You
can switch buffers and do other editing.  As long as you don't try to
check in another file, the entry you were editing remains in the
`*VC-Log*' buffer, and you can go back to that buffer at any time to
complete the check-in.

   If you change several source files for the same reason, it is often
convenient to specify the same log entry for many of the files.  To do
this, use the history of previous log entries.  The commands `M-n',
`M-p', `M-s' and `M-r' for doing this work just like the minibuffer
history commands (except that these versions are used outside the
minibuffer).

   Each time you check in a file, the log entry buffer is put into VC
Log mode, which involves running two hooks: `text-mode-hook' and
`vc-log-mode-hook'.  *Note Hooks::.


File: emacs,  Node: Old Versions,  Next: Secondary VC Commands,  Prev: Basic VC Editing,  Up: Version Control

23.8.4 Examining And Comparing Old Versions
-------------------------------------------

One of the convenient features of version control is the ability to
examine any version of a file, or compare two versions.

`C-x v ~ VERSION <RET>'
     Examine version VERSION of the visited file, in a buffer of its
     own.

`C-x v ='
     Compare the current buffer contents with the master version from
     which you started editing.

`C-u C-x v = FILE <RET> OLDVERS <RET> NEWVERS <RET>'
     Compare the specified two versions of FILE.

`C-x v g'
     Display the file with per-line version information and using
     colors.

   To examine an old version in its entirety, visit the file and then
type `C-x v ~ VERSION <RET>' (`vc-version-other-window').  This puts
the text of version VERSION in a file named `FILENAME.~VERSION~', and
visits it in its own buffer in a separate window.  (In RCS, you can
also select an old version and create a branch from it.  *Note
Branches::.)

   It is usually more convenient to compare two versions of the file,
with the command `C-x v =' (`vc-diff').  Plain `C-x v =' compares the
current buffer contents (saving them in the file if necessary) with the
master version from which you started editing the file (this is not
necessarily the latest version of the file).  `C-u C-x v =', with a
numeric argument, reads a file name and two version numbers, then
compares those versions of the specified file.  Both forms display the
output in a special buffer in another window.

   You can specify a checked-in version by its number; an empty input
specifies the current contents of the work file (which may be different
from all the checked-in versions).  You can also specify a snapshot name
(*note Snapshots::) instead of one or both version numbers.

   If you supply a directory name instead of the name of a registered
file, this command compares the two specified versions of all registered
files in that directory and its subdirectories.

   `C-x v =' works by running a variant of the `diff' utility designed
to work with the version control system in use.  When you invoke `diff'
this way, in addition to the options specified by `diff-switches'
(*note Comparing Files::), it receives those specified by
`vc-diff-switches', plus those specified for the specific back end by
`vc-BACKEND-diff-switches'.  For instance, when the version control
back end is RCS, `diff' uses the options in `vc-rcs-diff-switches'.  The
`vc...diff-switches' variables are `nil' by default.

   The buffer produced by `C-x v =' supports the commands of
Compilation mode (*note Compilation Mode::), such as `C-x `' and `C-c
C-c', in both the "old" and "new" text, and they always find the
corresponding locations in the current work file.  (Older versions are
not, in general, present as files on your disk.)

   For some back ends, you can display the file "annotated" with
per-line version information and using colors to enhance the visual
appearance, with the command `M-x vc-annotate'.  It creates a new
buffer (the "annotate buffer") displaying the file's text, with each
part colored to show how old it is.  Text colored red is new, blue means
old, and intermediate colors indicate intermediate ages.  By default,
the color is scaled over the full range of ages, such that the oldest
changes are blue, and the newest changes are red.

   When you give a prefix argument to this command, it uses the
minibuffer to read two arguments: which version number to display and
annotate (instead of the current file contents), and the time span in
days the color range should cover.

   From the annotate buffer, these and other color scaling options are
available from the `VC-Annotate' menu.  In this buffer, you can also
use the following keys to browse the annotations of past revisions,
view diffs, or view log entries:

`P'
     Annotate the previous revision, that is to say, the revision before
     the one currently annotated.  A numeric prefix argument is a repeat
     count, so `C-u 10 P' would take you back 10 revisions.

`N'
     Annotate the next revision--the one after the revision currently
     annotated.  A numeric prefix argument is a repeat count.

`J'
     Annotate the revision indicated by the current line.

`A'
     Annotate the revision before the one indicated by the current line.
     This is useful to see the state the file was in before the change
     on the current line was made.

`D'
     Display the diff between the current line's revision and the
     previous revision.  This is useful to see what the current line's
     revision actually changed in the file.

`L'
     Show the log of the current line's revision.  This is useful to see
     the author's description of the changes in the revision on the
     current line.

`W'
     Annotate the workfile version-the one you are editing.  If you used
     `P' and `N' to browse to other revisions, use this key to return
     to your current version.


File: emacs,  Node: Secondary VC Commands,  Next: Branches,  Prev: Old Versions,  Up: Version Control

23.8.5 The Secondary Commands of VC
-----------------------------------

This section explains the secondary commands of VC; those that you might
use once a day.

* Menu:

* Registering::         Putting a file under version control.
* VC Status::           Viewing the VC status of files.
* VC Undo::             Canceling changes before or after check-in.

* VC Dired Mode::       Listing files managed by version control.
* VC Dired Commands::   Commands to use in a VC Dired buffer.


File: emacs,  Node: Registering,  Next: VC Status,  Up: Secondary VC Commands

23.8.5.1 Registering a File for Version Control
...............................................

You can put any file under version control by simply visiting it, and
then typing `C-x v i' (`vc-register').

`C-x v i'
     Register the visited file for version control.

   To register the file, Emacs must choose which version control system
to use for it.  If the file's directory already contains files
registered in a version control system, Emacs uses that system.  If
there is more than one system in use for a directory, Emacs uses the
one that appears first in `vc-handled-backends' (*note Customizing
VC::).  On the other hand, if there are no files already registered,
Emacs uses the first system from `vc-handled-backends' that could
register the file (for example, you cannot register a file under CVS if
its directory is not already part of a CVS tree); with the default value
of `vc-handled-backends', this means that Emacs uses RCS in this
situation.

   If locking is in use, `C-x v i' leaves the file unlocked and
read-only.  Type `C-x v v' if you wish to start editing it.  After
registering a file with CVS, you must subsequently commit the initial
version by typing `C-x v v'.  Until you do that, the version appears as
`@@' in the mode line.

   The initial version number for a newly registered file is 1.1, by
default.  You can specify a different default by setting the variable
`vc-default-init-version', or you can give `C-x v i' a numeric
argument; then it reads the initial version number for this particular
file using the minibuffer.

   If `vc-initial-comment' is non-`nil', `C-x v i' reads an initial
comment to describe the purpose of this source file.  Reading the
initial comment works like reading a log entry (*note Log Buffer::).


File: emacs,  Node: VC Status,  Next: VC Undo,  Prev: Registering,  Up: Secondary VC Commands

23.8.5.2 VC Status Commands
...........................

`C-x v l'
     Display version control state and change history.

   To view the detailed version control status and history of a file,
type `C-x v l' (`vc-print-log').  It displays the history of changes to
the current file, including the text of the log entries.  The output
appears in a separate window.  The point is centered at the revision of
the file that is currently being visited.

   In the change log buffer, you can use the following keys to move
between the logs of revisions and of files, to view past revisions, and
to view diffs:

`p'
     Move to the previous revision-item in the buffer.  (Revision
     entries in the log buffer are usually in reverse-chronological
     order, so the previous revision-item usually corresponds to a
     newer revision.)  A numeric prefix argument is a repeat count.

`n'
     Move to the next revision-item (which most often corresponds to the
     previous revision of the file).  A numeric prefix argument is a
     repeat count.

`P'
     Move to the log of the previous file, when the logs of multiple
     files are in the log buffer (*note VC Dired Mode::).  Otherwise,
     just move to the beginning of the log.  A numeric prefix argument
     is a repeat count, so `C-u 10 P' would move backward 10 files.

`N'
     Move to the log of the next file, when the logs of multiple files
     are in the log buffer (*note VC Dired Mode::).  It also takes a
     numeric prefix argument as a repeat count.

`f'
     Visit the revision indicated at the current line, like typing `C-x
     v ~' and specifying this revision's number (*note Old Versions::).

`d'
     Display the diff (*note Comparing Files::) between the revision
     indicated at the current line and the next earlier revision.  This
     is useful to see what actually changed when the revision indicated
     on the current line was committed.


File: emacs,  Node: VC Undo,  Next: VC Dired Mode,  Prev: VC Status,  Up: Secondary VC Commands

23.8.5.3 Undoing Version Control Actions
........................................

`C-x v u'
     Revert the buffer and the file to the version from which you
     started editing the file.

`C-x v c'
     Remove the last-entered change from the master for the visited
     file.  This undoes your last check-in.

   If you want to discard your current set of changes and revert to the
version from which you started editing the file, use `C-x v u'
(`vc-revert-buffer').  This leaves the file unlocked; if locking is in
use, you must first lock the file again before you change it again.
`C-x v u' requires confirmation, unless it sees that you haven't made
any changes with respect to the master version.

   `C-x v u' is also the command to unlock a file if you lock it and
then decide not to change it.

   To cancel a change that you already checked in, use `C-x v c'
(`vc-cancel-version').  This command discards all record of the most
recent checked-in version, but only if your work file corresponds to
that version--you cannot use `C-x v c' to cancel a version that is not
the latest on its branch.  `C-x v c' also offers to revert your work
file and buffer to the previous version (the one that precedes the
version that is deleted).

   If you answer `no', VC keeps your changes in the buffer, and locks
the file.  The no-revert option is useful when you have checked in a
change and then discover a trivial error in it; you can cancel the
erroneous check-in, fix the error, and check the file in again.

   When `C-x v c' does not revert the buffer, it unexpands all version
control headers in the buffer instead (*note Version Headers::).  This
is because the buffer no longer corresponds to any existing version.
If you check it in again, the check-in process will expand the headers
properly for the new version number.

   However, it is impossible to unexpand the RCS `$Log$' header
automatically.  If you use that header feature, you have to unexpand it
by hand--by deleting the entry for the version that you just canceled.

   Be careful when invoking `C-x v c', as it is easy to lose a lot of
work with it.  To help you be careful, this command always requires
confirmation with `yes'.  Note also that this command is disabled under
CVS, because canceling versions is very dangerous and discouraged with
CVS.


File: emacs,  Node: VC Dired Mode,  Next: VC Dired Commands,  Prev: VC Undo,  Up: Secondary VC Commands

23.8.5.4 Dired under VC
.......................

The VC Dired Mode described here works with all the version control
systems that VC supports.  Another more powerful facility, designed
specifically for CVS, is called PCL-CVS.  *Note About PCL-CVS:
(pcl-cvs)Top.

   When you are working on a large program, it is often useful to find
out which files have changed within an entire directory tree, or to view
the status of all files under version control at once, and to perform
version control operations on collections of files.  You can use the
command `C-x v d' (`vc-directory') to make a directory listing that
includes only files relevant for version control.

   `C-x v d' creates a buffer which uses VC Dired Mode.  This looks
much like an ordinary Dired buffer (*note Dired::); however, normally
it shows only the noteworthy files (those locked or not up-to-date).
This is called "terse display".  If you set the variable
`vc-dired-terse-display' to `nil', then VC Dired shows all relevant
files--those managed under version control, plus all subdirectories
("full display").  The command `v t' in a VC Dired buffer toggles
between terse display and full display (*note VC Dired Commands::).

   By default, VC Dired produces a recursive listing of noteworthy or
relevant files at or below the given directory.  You can change this by
setting the variable `vc-dired-recurse' to `nil'; then VC Dired shows
only the files in the given directory.

   The line for an individual file shows the version control state in
the place of the hard link count, owner, group, and size of the file.
If the file is unmodified, in sync with the master file, the version
control state shown is blank.  Otherwise it consists of text in
parentheses.  Under RCS and SCCS, the name of the user locking the file
is shown; under CVS, an abbreviated version of the `cvs status' output
is used.  Here is an example using RCS:

       /home/jim/project:

       -rw-r--r-- (jim)      Apr  2 23:39 file1
       -r--r--r--            Apr  5 20:21 file2

The files `file1' and `file2' are under version control, `file1' is
locked by user jim, and `file2' is unlocked.

   Here is an example using CVS:

       /home/joe/develop:

       -rw-r--r-- (modified) Aug  2  1997 file1.c
       -rw-r--r--            Apr  4 20:09 file2.c
       -rw-r--r-- (merge)    Sep 13  1996 file3.c

   Here `file1.c' is modified with respect to the repository, and
`file2.c' is not.  `file3.c' is modified, but other changes have also
been checked in to the repository--you need to merge them with the work
file before you can check it in.

   In the above, if the repository were on a remote machine, VC would
only contact it when the variable `vc-stay-local' (or
`vc-cvs-stay-local') is nil (*note CVS Options::).  This is because
access to the repository may be slow, or you may be working offline and
not have access to the repository at all.  As a consequence, VC would
not be able to tell you that `file3.c' is in the "merge" state; you
would learn that only when you try to check-in your modified copy of
the file, or use a command such as `C-x v m'.

   In practice, this is not a problem because CVS handles this case
consistently whenever it arises.  In VC, you'll simply get prompted to
merge the remote changes into your work file first.  The benefits of
less network communication usually outweigh the disadvantage of not
seeing remote changes immediately.

   When VC Dired displays subdirectories (in the "full" display mode),
it omits some that should never contain any files under version control.
By default, this includes Version Control subdirectories such as `RCS'
and `CVS'; you can customize this by setting the variable
`vc-directory-exclusion-list'.

   You can fine-tune VC Dired's format by typing `C-u C-x v d'--as in
ordinary Dired, that allows you to specify additional switches for the
`ls' command.


File: emacs,  Node: VC Dired Commands,  Prev: VC Dired Mode,  Up: Secondary VC Commands

23.8.5.5 VC Dired Commands
..........................

All the usual Dired commands work normally in VC Dired mode, except for
`v', which is redefined as the version control prefix.  You can invoke
VC commands such as `vc-diff' and `vc-print-log' by typing `v =', or `v
l', and so on.  Most of these commands apply to the file name on the
current line.

   The command `v v' (`vc-next-action') operates on all the marked
files, so that you can lock or check in several files at once.  If it
operates on more than one file, it handles each file according to its
current state; thus, it might lock one file, but check in another file.
This could be confusing; it is up to you to avoid confusing behavior by
marking a set of files that are in a similar state.  If no files are
marked, `v v' operates on the file in the current line.

   If any files call for check-in, `v v' reads a single log entry, then
uses it for all the files being checked in.  This is convenient for
registering or checking in several files at once, as part of the same
change.

   You can toggle between terse display (only locked files, or files not
up-to-date) and full display at any time by typing `v t'
(`vc-dired-toggle-terse-mode').  There is also a special command `* l'
(`vc-dired-mark-locked'), which marks all files currently locked (or,
with CVS, all files not up-to-date).  Thus, typing `* l t k' is another
way to delete from the buffer all files except those currently locked.


File: emacs,  Node: Branches,  Next: Remote Repositories,  Prev: Secondary VC Commands,  Up: Version Control

23.8.6 Multiple Branches of a File
----------------------------------

One use of version control is to maintain multiple "current" versions
of a file.  For example, you might have different versions of a program
in which you are gradually adding various unfinished new features.
Each such independent line of development is called a "branch".  VC
allows you to create branches, switch between different branches, and
merge changes from one branch to another.  Please note, however, that
branches are not supported for SCCS.

   A file's main line of development is usually called the "trunk".
The versions on the trunk are normally numbered 1.1, 1.2, 1.3, etc.  At
any such version, you can start an independent branch.  A branch
starting at version 1.2 would have version number 1.2.1.1, and
consecutive versions on this branch would have numbers 1.2.1.2,
1.2.1.3, 1.2.1.4, and so on.  If there is a second branch also starting
at version 1.2, it would consist of versions 1.2.2.1, 1.2.2.2, 1.2.2.3,
etc.

   If you omit the final component of a version number, that is called a
"branch number".  It refers to the highest existing version on that
branch--the "head version" of that branch.  The branches in the example
above have branch numbers 1.2.1 and 1.2.2.

* Menu:

* Switching Branches::    How to get to another existing branch.
* Creating Branches::     How to start a new branch.
* Merging::               Transferring changes between branches.
* Multi-User Branching::  Multiple users working at multiple branches
                            in parallel.


File: emacs,  Node: Switching Branches,  Next: Creating Branches,  Up: Branches

23.8.6.1 Switching between Branches
...................................

To switch between branches, type `C-u C-x v v' and specify the version
number you want to select.  This version is then visited _unlocked_
(write-protected), so you can examine it before locking it.  Switching
branches in this way is allowed only when the file is not locked.

   You can omit the minor version number, thus giving only the branch
number; this takes you to the head version on the chosen branch.  If you
only type <RET>, Emacs goes to the highest version on the trunk.

   After you have switched to any branch (including the main branch),
you stay on it for subsequent VC commands, until you explicitly select
some other branch.


File: emacs,  Node: Creating Branches,  Next: Merging,  Prev: Switching Branches,  Up: Branches

23.8.6.2 Creating New Branches
..............................

To create a new branch from a head version (one that is the latest in
the branch that contains it), first select that version if necessary,
lock it with `C-x v v', and make whatever changes you want.  Then, when
you check in the changes, use `C-u C-x v v'.  This lets you specify the
version number for the new version.  You should specify a suitable
branch number for a branch starting at the current version.  For
example, if the current version is 2.5, the branch number should be
2.5.1, 2.5.2, and so on, depending on the number of existing branches at
that point.

   To create a new branch at an older version (one that is no longer the
head of a branch), first select that version (*note Switching
Branches::), then lock it with `C-x v v'.  You'll be asked to confirm,
when you lock the old version, that you really mean to create a new
branch--if you say no, you'll be offered a chance to lock the latest
version instead.

   Then make your changes and type `C-x v v' again to check in a new
version.  This automatically creates a new branch starting from the
selected version.  You need not specially request a new branch, because
that's the only way to add a new version at a point that is not the head
of a branch.

   After the branch is created, you "stay" on it.  That means that
subsequent check-ins create new versions on that branch.  To leave the
branch, you must explicitly select a different version with `C-u C-x v
v'.  To transfer changes from one branch to another, use the merge
command, described in the next section.


File: emacs,  Node: Merging,  Next: Multi-User Branching,  Prev: Creating Branches,  Up: Branches

23.8.6.3 Merging Branches
.........................

When you have finished the changes on a certain branch, you will often
want to incorporate them into the file's main line of development (the
trunk).  This is not a trivial operation, because development might
also have proceeded on the trunk, so that you must "merge" the changes
into a file that has already been changed otherwise.  VC allows you to
do this (and other things) with the `vc-merge' command.

`C-x v m (vc-merge)'
     Merge changes into the work file.

   `C-x v m' (`vc-merge') takes a set of changes and merges it into the
current version of the work file.  It firsts asks you in the minibuffer
where the changes should come from.  If you just type <RET>, Emacs
merges any changes that were made on the same branch since you checked
the file out (we call this "merging the news").  This is the common way
to pick up recent changes from the repository, regardless of whether
you have already changed the file yourself.

   You can also enter a branch number or a pair of version numbers in
the minibuffer.  Then `C-x v m' finds the changes from that branch, or
the differences between the two versions you specified, and merges them
into the current version of the current file.

   As an example, suppose that you have finished a certain feature on
branch 1.3.1.  In the meantime, development on the trunk has proceeded
to version 1.5.  To merge the changes from the branch to the trunk,
first go to the head version of the trunk, by typing `C-u C-x v v
<RET>'.  Version 1.5 is now current.  If locking is used for the file,
type `C-x v v' to lock version 1.5 so that you can change it.  Next,
type `C-x v m 1.3.1 <RET>'.  This takes the entire set of changes on
branch 1.3.1 (relative to version 1.3, where the branch started, up to
the last version on the branch) and merges it into the current version
of the work file.  You can now check in the changed file, thus creating
version 1.6 containing the changes from the branch.

   It is possible to do further editing after merging the branch, before
the next check-in.  But it is usually wiser to check in the merged
version, then lock it and make the further changes.  This will keep a
better record of the history of changes.

   When you merge changes into a file that has itself been modified, the
changes might overlap.  We call this situation a "conflict", and
reconciling the conflicting changes is called "resolving a conflict".

   Whenever conflicts occur during merging, VC detects them, tells you
about them in the echo area, and asks whether you want help in merging.
If you say yes, it starts an Ediff session (*note Ediff: (ediff)Top.).

   If you say no, the conflicting changes are both inserted into the
file, surrounded by "conflict markers".  The example below shows how a
conflict region looks; the file is called `name' and the current master
file version with user B's changes in it is 1.11.

     <<<<<<< name
       USER A'S VERSION
     =======
       USER B'S VERSION
     >>>>>>> 1.11

   Then you can resolve the conflicts by editing the file manually.  Or
you can type `M-x vc-resolve-conflicts' after visiting the file.  This
starts an Ediff session, as described above.  Don't forget to check in
the merged version afterwards.


File: emacs,  Node: Multi-User Branching,  Prev: Merging,  Up: Branches

23.8.6.4 Multi-User Branching
.............................

It is often useful for multiple developers to work simultaneously on
different branches of a file.  CVS allows this by default; for RCS, it
is possible if you create multiple source directories.  Each source
directory should have a link named `RCS' which points to a common
directory of RCS master files.  Then each source directory can have its
own choice of selected versions, but all share the same common RCS
records.

   This technique works reliably and automatically, provided that the
source files contain RCS version headers (*note Version Headers::).
The headers enable Emacs to be sure, at all times, which version number
is present in the work file.

   If the files do not have version headers, you must instead tell Emacs
explicitly in each session which branch you are working on.  To do this,
first find the file, then type `C-u C-x v v' and specify the correct
branch number.  This ensures that Emacs knows which branch it is using
during this particular editing session.


File: emacs,  Node: Remote Repositories,  Next: Snapshots,  Prev: Branches,  Up: Version Control

23.8.7 Remote Repositories
--------------------------

A common way of using CVS is to set up a central CVS repository on some
Internet host, then have each developer check out a personal working
copy of the files on his local machine.  Committing changes to the
repository, and picking up changes from other users into one's own
working area, then works by direct interactions with the CVS server.

   One difficulty is that access to the CVS server is often slow, and
that developers might need to work off-line as well.  VC is designed to
reduce the amount of network interaction necessary.

* Menu:

* Version Backups::        Keeping local copies of repository versions.
* Local Version Control::  Using another version system for local editing.


File: emacs,  Node: Version Backups,  Next: Local Version Control,  Up: Remote Repositories

23.8.7.1 Version Backups
........................

When VC sees that the CVS repository for a file is on a remote machine,
it automatically makes local backups of unmodified versions of the
file--"automatic version backups".  This means that you can compare the
file to the repository version (`C-x v ='), or revert to that version
(`C-x v u'), without any network interactions.

   The local copy of the unmodified file is called a "version backup"
to indicate that it corresponds exactly to a version that is stored in
the repository.  Note that version backups are not the same as ordinary
Emacs backup files (*note Backup::).  But they follow a similar naming
convention.

   For a file that comes from a remote CVS repository, VC makes a
version backup whenever you save the first changes to the file, and
removes it after you have committed your modified version to the
repository. You can disable the making of automatic version backups by
setting `vc-cvs-stay-local' to `nil' (*note CVS Options::).

   The name of the automatic version backup for version VERSION of file
FILE is `FILE.~VERSION.~'.  This is almost the same as the name used by
`C-x v ~' (*note Old Versions::), the only difference being the
additional dot (`.')  after the version number.  This similarity is
intentional, because both kinds of files store the same kind of
information.  The file made by `C-x v ~' acts as a "manual version
backup".

   All the VC commands that operate on old versions of a file can use
both kinds of version backups.  For instance, `C-x v ~' uses either an
automatic or a manual version backup, if possible, to get the contents
of the version you request.  Likewise, `C-x v =' and `C-x v u' use
either an automatic or a manual version backup, if one of them exists,
to get the contents of a version to compare or revert to.  If you
changed a file outside of Emacs, so that no automatic version backup
was created for the previous text, you can create a manual backup of
that version using `C-x v ~', and thus obtain the benefit of the local
copy for Emacs commands.

   The only difference in Emacs's handling of manual and automatic
version backups, once they exist, is that Emacs deletes automatic
version backups when you commit to the repository.  By contrast, manual
version backups remain until you delete them.


File: emacs,  Node: Local Version Control,  Prev: Version Backups,  Up: Remote Repositories

23.8.7.2 Local Version Control
..............................

When you make many changes to a file that comes from a remote
repository, it can be convenient to have version control on your local
machine as well.  You can then record intermediate versions, revert to
a previous state, etc., before you actually commit your changes to the
remote server.

   VC lets you do this by putting a file under a second, local version
control system, so that the file is effectively registered in two
systems at the same time.  For the description here, we will assume
that the remote system is CVS, and you use RCS locally, although the
mechanism works with any combination of version control systems ("back
ends").

   To make it work with other back ends, you must make sure that the
"more local" back end comes before the "more remote" back end in the
setting of `vc-handled-backends' (*note Customizing VC::).  By default,
this variable is set up so that you can use remote CVS and local RCS as
described here.

   To start using local RCS for a file that comes from a remote CVS
server, you must _register the file in RCS_, by typing `C-u C-x v v rcs
<RET>'.  (In other words, use `vc-next-action' with a prefix argument,
and specify RCS as the back end.)

   You can do this at any time; it does not matter whether you have
already modified the file with respect to the version in the CVS
repository.  If possible, VC tries to make the RCS master start with
the unmodified repository version, then checks in any local changes as
a new version.  This works if you have not made any changes yet, or if
the unmodified repository version exists locally as a version backup
(*note Version Backups::).  If the unmodified version is not available
locally, the RCS master starts with the modified version; the only
drawback to this is that you cannot compare your changes locally to
what is stored in the repository.

   The version number of the RCS master is derived from the current CVS
version, starting a branch from it.  For example, if the current CVS
version is 1.23, the local RCS branch will be 1.23.1.  Version 1.23 in
the RCS master will be identical to version 1.23 under CVS; your first
changes are checked in as 1.23.1.1.  (If the unmodified file is not
available locally, VC will check in the modified file twice, both as
1.23 and 1.23.1.1, to make the revision numbers consistent.)

   If you do not use locking under CVS (the default), locking is also
disabled for RCS, so that editing under RCS works exactly as under CVS.

   When you are done with local editing, you can commit the final
version back to the CVS repository by typing `C-u C-x v v cvs <RET>'.
This initializes the log entry buffer (*note Log Buffer::) to contain
all the log entries you have recorded in the RCS master; you can edit
them as you wish, and then commit in CVS by typing `C-c C-c'.  If the
commit is successful, VC removes the RCS master, so that the file is
once again registered under CVS only.  (The RCS master is not actually
deleted, just renamed by appending `~' to the name, so that you can
refer to it later if you wish.)

   While using local RCS, you can pick up recent changes from the CVS
repository into your local file, or commit some of your changes back to
CVS, without terminating local RCS version control.  To do this, switch
to the CVS back end temporarily, with the `C-x v b' command:

`C-x v b'
     Switch to another back end that the current file is registered
     under (`vc-switch-backend').

`C-u C-x v b BACKEND <RET>'
     Switch to BACKEND for the current file.

   `C-x v b' does not change the buffer contents, or any files; it only
changes VC's perspective on how to handle the file.  Any subsequent VC
commands for that file will operate on the back end that is currently
selected.

   If the current file is registered in more than one back end, typing
`C-x v b' "cycles" through all of these back ends.  With a prefix
argument, it asks for the back end to use in the minibuffer.

   Thus, if you are using local RCS, and you want to pick up some recent
changes in the file from remote CVS, first visit the file, then type
`C-x v b' to switch to CVS, and finally use `C-x v m <RET>' to merge
the news (*note Merging::).  You can then switch back to RCS by typing
`C-x v b' again, and continue to edit locally.

   But if you do this, the revision numbers in the RCS master no longer
correspond to those of CVS.  Technically, this is not a problem, but it
can become difficult to keep track of what is in the CVS repository and
what is not.  So we suggest that you return from time to time to
CVS-only operation, by committing your local changes back to the
repository using `C-u C-x v v cvs <RET>'.


File: emacs,  Node: Snapshots,  Next: Miscellaneous VC,  Prev: Remote Repositories,  Up: Version Control

23.8.8 Snapshots
----------------

A "snapshot" is a named set of file versions (one for each registered
file) that you can treat as a unit.  One important kind of snapshot is
a "release", a (theoretically) stable version of the system that is
ready for distribution to users.

* Menu:

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.


File: emacs,  Node: Making Snapshots,  Next: Snapshot Caveats,  Up: Snapshots

23.8.8.1 Making and Using Snapshots
...................................

There are two basic commands for snapshots; one makes a snapshot with a
given name, the other retrieves a named snapshot.

`C-x v s NAME <RET>'
     Define the last saved versions of every registered file in or
     under the current directory as a snapshot named NAME
     (`vc-create-snapshot').

`C-x v r NAME <RET>'
     For all registered files at or below the current directory level,
     select whatever versions correspond to the snapshot NAME
     (`vc-retrieve-snapshot').

     This command reports an error if any files are locked at or below
     the current directory, without changing anything; this is to avoid
     overwriting work in progress.

   A snapshot uses a very small amount of resources--just enough to
record the list of file names and which version belongs to the
snapshot.  Thus, you need not hesitate to create snapshots whenever
they are useful.

   You can give a snapshot name as an argument to `C-x v =' or `C-x v ~'
(*note Old Versions::).  Thus, you can use it to compare a snapshot
against the current files, or two snapshots against each other, or a
snapshot against a named version.


File: emacs,  Node: Snapshot Caveats,  Prev: Making Snapshots,  Up: Snapshots

23.8.8.2 Snapshot Caveats
.........................

VC's snapshot facilities are modeled on RCS's named-configuration
support.  They use RCS's native facilities for this, so snapshots made
using RCS through VC are visible even when you bypass VC.

   With CVS, Meta-CVS, and Subversion, VC also uses the native
mechanism provided by that back end to make snapshots and retrieve them
("tags" for CVS and Meta-CVS, "copies" for Subversion).

   For SCCS, VC implements snapshots itself.  The files it uses contain
name/file/version-number triples.  These snapshots are visible only
through VC.

   There is no support for VC snapshots using GNU Arch yet.

   A snapshot is a set of checked-in versions.  So make sure that all
the files are checked in and not locked when you make a snapshot.

   File renaming and deletion can create some difficulties with
snapshots.  This is not a VC-specific problem, but a general design
issue in version control systems that no one has solved very well yet.

   If you rename a registered file, you need to rename its master along
with it (the command `vc-rename-file' does this automatically).  If you
are using SCCS, you must also update the records of the snapshot, to
mention the file by its new name (`vc-rename-file' does this, too).  An
old snapshot that refers to a master file that no longer exists under
the recorded name is invalid; VC can no longer retrieve it.  It would
be beyond the scope of this manual to explain enough about RCS and SCCS
to explain how to update the snapshots by hand.

   Using `vc-rename-file' makes the snapshot remain valid for
retrieval, but it does not solve all problems.  For example, some of the
files in your program probably refer to others by name.  At the very
least, the makefile probably mentions the file that you renamed.  If you
retrieve an old snapshot, the renamed file is retrieved under its new
name, which is not the name that the makefile expects.  So the program
won't really work as retrieved.


File: emacs,  Node: Miscellaneous VC,  Next: Customizing VC,  Prev: Snapshots,  Up: Version Control

23.8.9 Miscellaneous Commands and Features of VC
------------------------------------------------

This section explains the less-frequently-used features of VC.

* Menu:

* Change Logs and VC::  Generating a change log file from log entries.
* Renaming and VC::     A command to rename both the source and master
                          file correctly.
* Version Headers::     Inserting version control headers into working files.


File: emacs,  Node: Change Logs and VC,  Next: Renaming and VC,  Up: Miscellaneous VC

23.8.9.1 Change Logs and VC
...........................

If you use RCS or CVS for a program and also maintain a change log file
for it (*note Change Log::), you can generate change log entries
automatically from the version control log entries:

`C-x v a'
     Visit the current directory's change log file and, for registered
     files in that directory, create new entries for versions checked
     in since the most recent entry in the change log file.
     (`vc-update-change-log').

     This command works with RCS or CVS only, not with any of the other
     back ends.

`C-u C-x v a'
     As above, but only find entries for the current buffer's file.

`M-1 C-x v a'
     As above, but find entries for all the currently visited files
     that are maintained with version control.  This works only with
     RCS, and it puts all entries in the log for the default directory,
     which may not be appropriate.

   For example, suppose the first line of `ChangeLog' is dated
1999-04-10, and that the only check-in since then was by Nathaniel
Bowditch to `rcs2log' on 1999-05-22 with log text `Ignore log messages
that start with `#'.'.  Then `C-x v a' visits `ChangeLog' and inserts
text like this:

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

You can then edit the new change log entry further as you wish.

   Some of the new change log entries may duplicate what's already in
ChangeLog.  You will have to remove these duplicates by hand.

   Normally, the log entry for file `foo' is displayed as `* foo: TEXT
OF LOG ENTRY'.  The `:' after `foo' is omitted if the text of the log
entry starts with `(FUNCTIONNAME): '.  For example, if the log entry
for `vc.el' is `(vc-do-command): Check call-process status.', then the
text in `ChangeLog' looks like this:

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

   When `C-x v a' adds several change log entries at once, it groups
related log entries together if they all are checked in by the same
author at nearly the same time.  If the log entries for several such
files all have the same text, it coalesces them into a single entry.
For example, suppose the most recent check-ins have the following log
entries:

* For `vc.texinfo': `Fix expansion typos.'
* For `vc.el': `Don't call expand-file-name.'
* For `vc-hooks.el': `Don't call expand-file-name.'

They appear like this in `ChangeLog':

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.

             * vc.el, vc-hooks.el: Don't call expand-file-name.

   Normally, `C-x v a' separates log entries by a blank line, but you
can mark several related log entries to be clumped together (without an
intervening blank line) by starting the text of each related log entry
with a label of the form `{CLUMPNAME} '.  The label itself is not
copied to `ChangeLog'.  For example, suppose the log entries are:

* For `vc.texinfo': `{expand} Fix expansion typos.'
* For `vc.el': `{expand} Don't call expand-file-name.'
* For `vc-hooks.el': `{expand} Don't call expand-file-name.'

Then the text in `ChangeLog' looks like this:

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.
             * vc.el, vc-hooks.el: Don't call expand-file-name.

   A log entry whose text begins with `#' is not copied to `ChangeLog'.
For example, if you merely fix some misspellings in comments, you can
log the change with an entry beginning with `#' to avoid putting such
trivia into `ChangeLog'.


File: emacs,  Node: Renaming and VC,  Next: Version Headers,  Prev: Change Logs and VC,  Up: Miscellaneous VC

23.8.9.2 Renaming VC Work Files and Master Files
................................................

When you rename a registered file, you must also rename its master file
correspondingly to get proper results.  Use `vc-rename-file' to rename
the source file as you specify, and rename its master file accordingly.
It also updates any snapshots (*note Snapshots::) that mention the
file, so that they use the new name; despite this, the snapshot thus
modified may not completely work (*note Snapshot Caveats::).

   Some back ends do not provide an explicit rename operation to their
repositories.  After issuing `vc-rename-file', use `C-x v v' on the
original and renamed buffers and provide the necessary edit log.

   You cannot use `vc-rename-file' on a file that is locked by someone
else.


File: emacs,  Node: Version Headers,  Prev: Renaming and VC,  Up: Miscellaneous VC

23.8.9.3 Inserting Version Control Headers
..........................................

Sometimes it is convenient to put version identification strings
directly into working files.  Certain special strings called "version
headers" are replaced in each successive version by the number of that
version, the name of the user who created it, and other relevant
information.  All of the back ends that VC supports have such a
mechanism, except GNU Arch.

   VC does not normally use the information contained in these headers.
The exception is RCS--with RCS, version headers are sometimes more
reliable than the master file to determine which version of the file
you are editing.  Note that in a multi-branch environment, version
headers are necessary to make VC behave correctly (*note Multi-User
Branching::).

   Searching for RCS version headers is controlled by the variable
`vc-consult-headers'.  If it is non-`nil' (the default), Emacs searches
for headers to determine the version number you are editing.  Setting
it to `nil' disables this feature.

   Note that although CVS uses the same kind of version headers as RCS
does, VC never searches for these headers if you are using CVS,
regardless of the above setting.

   You can use the `C-x v h' command (`vc-insert-headers') to insert a
suitable header string.

`C-x v h'
     Insert headers in a file for use with your version-control system.

   The default header string is `$Id$' for RCS and `%W%' for SCCS.  You
can specify other headers to insert by setting the variables
`vc-BACKEND-header' where BACKEND is `rcs' or `sccs'.

   Instead of a single string, you can specify a list of strings; then
each string in the list is inserted as a separate header on a line of
its own.

   It may be necessary to use apparently-superfluous backslashes when
writing the strings that you put in this variable.  For instance, you
might write `"$Id\$"' rather than `"$Id$"'.  The extra backslash
prevents the string constant from being interpreted as a header, if the
Emacs Lisp file containing it is maintained with version control.

   Each header is inserted surrounded by tabs, inside comment
delimiters, on a new line at point.  Normally the ordinary comment
start and comment end strings of the current mode are used, but for
certain modes, there are special comment delimiters for this purpose;
the variable `vc-comment-alist' specifies them.  Each element of this
list has the form `(MODE STARTER ENDER)'.

   The variable `vc-static-header-alist' specifies further strings to
add based on the name of the buffer.  Its value should be a list of
elements of the form `(REGEXP . FORMAT)'.  Whenever REGEXP matches the
buffer name, FORMAT is inserted as part of the header.  A header line
is inserted for each element that matches the buffer name, and for each
string specified by `vc-BACKEND-header'.  The header line is made by
processing the string from `vc-BACKEND-header' with the format taken
from the element.  The default value for `vc-static-header-alist' is as
follows:

     (("\\.c$" .
       "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
     #endif /* lint */\n"))

It specifies insertion of text of this form:


     #ifndef lint
     static char vcid[] = "STRING";
     #endif /* lint */

Note that the text above starts with a blank line.

   If you use more than one version header in a file, put them close
together in the file.  The mechanism in `revert-buffer' that preserves
markers may not handle markers positioned between two version headers.


File: emacs,  Node: Customizing VC,  Prev: Miscellaneous VC,  Up: Version Control

23.8.10 Customizing VC
----------------------

The variable `vc-handled-backends' determines which version control
systems VC should handle.  The default value is `(RCS CVS SVN SCCS GIT
HG Arch MCVS)', so it contains all six version systems that are
currently supported.  If you want VC to ignore one or more of these
systems, exclude its name from the list.  To disable VC entirely, set
this variable to `nil'.

   The order of systems in the list is significant: when you visit a
file registered in more than one system (*note Local Version
Control::), VC uses the system that comes first in
`vc-handled-backends' by default.  The order is also significant when
you register a file for the first time, see *note Registering::, for
details.

* Menu:

* General VC Options::  Options that apply to multiple back ends.
* RCS and SCCS::        Options for RCS and SCCS.
* CVS Options::         Options for CVS.


File: emacs,  Node: General VC Options,  Next: RCS and SCCS,  Up: Customizing VC

23.8.10.1 General Options
.........................

Emacs normally does not save backup files for source files that are
maintained with version control.  If you want to make backup files even
for files that use version control, set the variable
`vc-make-backup-files' to a non-`nil' value.

   Normally the work file exists all the time, whether it is locked or
not.  If you set `vc-keep-workfiles' to `nil', then checking in a new
version with `C-x v v' deletes the work file; but any attempt to visit
the file with Emacs creates it again.  (With CVS, work files are always
kept.)

   Editing a version-controlled file through a symbolic link can be
dangerous.  It bypasses the version control system--you can edit the
file without locking it, and fail to check your changes in.  Also, your
changes might overwrite those of another user.  To protect against
this, VC checks each symbolic link that you visit, to see if it points
to a file under version control.

   The variable `vc-follow-symlinks' controls what to do when a
symbolic link points to a version-controlled file.  If it is `nil', VC
only displays a warning message.  If it is `t', VC automatically
follows the link, and visits the real file instead, telling you about
this in the echo area.  If the value is `ask' (the default), VC asks
you each time whether to follow the link.

   If `vc-suppress-confirm' is non-`nil', then `C-x v v' and `C-x v i'
can save the current buffer without asking, and `C-x v u' also operates
without asking for confirmation.  (This variable does not affect `C-x v
c'; that operation is so drastic that it should always ask for
confirmation.)

   VC mode does much of its work by running the shell commands for RCS,
CVS and SCCS.  If `vc-command-messages' is non-`nil', VC displays
messages to indicate which shell commands it runs, and additional
messages when the commands finish.

   You can specify additional directories to search for version control
programs by setting the variable `vc-path'.  These directories are
searched before the usual search path.  It is rarely necessary to set
this variable, because VC normally finds the proper files automatically.


File: emacs,  Node: RCS and SCCS,  Next: CVS Options,  Prev: General VC Options,  Up: Customizing VC

23.8.10.2 Options for RCS and SCCS
..................................

By default, RCS uses locking to coordinate the activities of several
users, but there is a mode called "non-strict locking" in which you can
check-in changes without locking the file first.  Use `rcs -U' to
switch to non-strict locking for a particular file, see the `rcs'
manual page for details.

   When deducing the version control state of an RCS file, VC first
looks for an RCS version header string in the file (*note Version
Headers::).  If there is no header string, VC normally looks at the
file permissions of the work file; this is fast.  But there might be
situations when the file permissions cannot be trusted.  In this case
the master file has to be consulted, which is rather expensive.  Also
the master file can only tell you _if_ there's any lock on the file,
but not whether your work file really contains that locked version.

   You can tell VC not to use version headers to determine the file
status by setting `vc-consult-headers' to `nil'.  VC then always uses
the file permissions (if it is supposed to trust them), or else checks
the master file.

   You can specify the criterion for whether to trust the file
permissions by setting the variable `vc-mistrust-permissions'.  Its
value can be `t' (always mistrust the file permissions and check the
master file), `nil' (always trust the file permissions), or a function
of one argument which makes the decision.  The argument is the
directory name of the `RCS' subdirectory.  A non-`nil' value from the
function says to mistrust the file permissions.  If you find that the
file permissions of work files are changed erroneously, set
`vc-mistrust-permissions' to `t'.  Then VC always checks the master
file to determine the file's status.

   VC determines the version control state of files under SCCS much as
with RCS.  It does not consider SCCS version headers, though.  Thus,
the variable `vc-mistrust-permissions' affects SCCS use, but
`vc-consult-headers' does not.


File: emacs,  Node: CVS Options,  Prev: RCS and SCCS,  Up: Customizing VC

23.8.10.3 Options specific for CVS
..................................

By default, CVS does not use locking to coordinate the activities of
several users; anyone can change a work file at any time.  However,
there are ways to restrict this, resulting in behavior that resembles
locking.

   For one thing, you can set the `CVSREAD' environment variable (the
value you use makes no difference).  If this variable is defined, CVS
makes your work files read-only by default.  In Emacs, you must type
`C-x v v' to make the file writable, so that editing works in fact
similar as if locking was used.  Note however, that no actual locking
is performed, so several users can make their files writable at the
same time.  When setting `CVSREAD' for the first time, make sure to
check out all your modules anew, so that the file protections are set
correctly.

   Another way to achieve something similar to locking is to use the
"watch" feature of CVS.  If a file is being watched, CVS makes it
read-only by default, and you must also use `C-x v v' in Emacs to make
it writable.  VC calls `cvs edit' to make the file writable, and CVS
takes care to notify other developers of the fact that you intend to
change the file.  See the CVS documentation for details on using the
watch feature.

   When a file's repository is on a remote machine, VC tries to keep
network interactions to a minimum.  This is controlled by the variable
`vc-cvs-stay-local'.  There is another variable, `vc-stay-local', which
enables the feature also for other back ends that support it, including
CVS.  In the following, we will talk only about `vc-cvs-stay-local',
but everything applies to `vc-stay-local' as well.

   If `vc-cvs-stay-local' is `t' (the default), then VC uses only the
entry in the local CVS subdirectory to determine the file's state (and
possibly information returned by previous CVS commands).  One
consequence of this is that when you have modified a file, and somebody
else has already checked in other changes to the file, you are not
notified of it until you actually try to commit.  (But you can try to
pick up any recent changes from the repository first, using `C-x v m
<RET>', *note Merging::).

   When `vc-cvs-stay-local' is `t', VC also makes local version
backups, so that simple diff and revert operations are completely local
(*note Version Backups::).

   On the other hand, if you set `vc-cvs-stay-local' to `nil', then VC
queries the remote repository _before_ it decides what to do in
`vc-next-action' (`C-x v v'), just as it does for local repositories.
It also does not make any version backups.

   You can also set `vc-cvs-stay-local' to a regular expression that is
matched against the repository host name; VC then stays local only for
repositories from hosts that match the pattern.

   You can specify additional command line options to pass to all CVS
operations in the variable `vc-cvs-global-switches'.  These switches
are inserted immediately after the `cvs' command, before the name of
the operation to invoke.


File: emacs,  Node: Directories,  Next: Comparing Files,  Prev: Version Control,  Up: Files

23.9 File Directories
=====================

The file system groups files into "directories".  A "directory listing"
is a list of all the files in a directory.  Emacs provides commands to
create and delete directories, and to make directory listings in brief
format (file names only) and verbose format (sizes, dates, and authors
included).  Emacs also includes a directory browser feature called
Dired; see *note Dired::.

`C-x C-d DIR-OR-PATTERN <RET>'
     Display a brief directory listing (`list-directory').

`C-u C-x C-d DIR-OR-PATTERN <RET>'
     Display a verbose directory listing.

`M-x make-directory <RET> DIRNAME <RET>'
     Create a new directory named DIRNAME.

`M-x delete-directory <RET> DIRNAME <RET>'
     Delete the directory named DIRNAME.  It must be empty, or you get
     an error.

   The command to display a directory listing is `C-x C-d'
(`list-directory').  It reads using the minibuffer a file name which is
either a directory to be listed or a wildcard-containing pattern for
the files to be listed.  For example,

     C-x C-d /u2/emacs/etc <RET>

lists all the files in directory `/u2/emacs/etc'.  Here is an example
of specifying a file name pattern:

     C-x C-d /u2/emacs/src/*.c <RET>

   Normally, `C-x C-d' displays a brief directory listing containing
just file names.  A numeric argument (regardless of value) tells it to
make a verbose listing including sizes, dates, and owners (like `ls
-l').

   The text of a directory listing is mostly obtained by running `ls'
in an inferior process.  Two Emacs variables control the switches
passed to `ls': `list-directory-brief-switches' is a string giving the
switches to use in brief listings (`"-CF"' by default), and
`list-directory-verbose-switches' is a string giving the switches to
use in a verbose listing (`"-l"' by default).

   In verbose directory listings, Emacs adds information about the
amount of free space on the disk that contains the directory.  To do
this, it runs the program specified by `directory-free-space-program'
with arguments `directory-free-space-args'.


File: emacs,  Node: Comparing Files,  Next: Diff Mode,  Prev: Directories,  Up: Files

23.10 Comparing Files
=====================

The command `M-x diff' compares two files, displaying the differences
in an Emacs buffer named `*diff*'.  It works by running the `diff'
program, using options taken from the variable `diff-switches'.  The
value of `diff-switches' should be a string; the default is `"-c"' to
specify a context diff.  *Note Diff: (diff)Top, for more information
about `diff' output formats.

   The command `M-x diff-backup' compares a specified file with its most
recent backup.  If you specify the name of a backup file, `diff-backup'
compares it with the source file that it is a backup of.

   The command `M-x compare-windows' compares the text in the current
window with that in the next window.  (For more information about
windows in Emacs, *note Windows::.)  Comparison starts at point in each
window, after pushing each initial point value on the mark ring in its
respective buffer.  Then it moves point forward in each window, one
character at a time, until it reaches characters that don't match.
Then the command exits.

   If point in the two windows is followed by non-matching text when
the command starts, `M-x compare-windows' tries heuristically to
advance up to matching text in the two windows, and then exits.  So if
you use `M-x compare-windows' repeatedly, each time it either skips one
matching range or finds the start of another.

   With a numeric argument, `compare-windows' ignores changes in
whitespace.  If the variable `compare-ignore-case' is non-`nil', the
comparison ignores differences in case as well.  If the variable
`compare-ignore-whitespace' is non-`nil', `compare-windows' normally
ignores changes in whitespace, and a prefix argument turns that off.

   You can use `M-x smerge-mode' to turn on Smerge mode, a minor mode
for editing output from the `diff3' program.  This is typically the
result of a failed merge from a version control system "update" outside
VC, due to conflicting changes to a file.  Smerge mode provides
commands to resolve conflicts by selecting specific changes.

   *Note Emerge::, for the Emerge facility, which provides a powerful
interface for merging files.


File: emacs,  Node: Diff Mode,  Next: Misc File Ops,  Prev: Comparing Files,  Up: Files

23.11 Diff Mode
===============

Diff mode is used for the output of `M-x diff'; it is also useful for
editing patches and comparisons produced by the `diff' program.  To
select Diff mode manually, type `M-x diff-mode'.

   One general feature of Diff mode is that manual edits to the patch
automatically correct line numbers, including those in the hunk header,
so that you can actually apply the edited patch.  Diff mode treats each
hunk location as an "error message," so that you can use commands such
as `C-x '' to visit the corresponding source locations.  It also
provides the following commands to navigate, manipulate and apply parts
of patches:

`M-n'
     Move to the next hunk-start (`diff-hunk-next').

`M-p'
     Move to the previous hunk-start (`diff-hunk-prev').

`M-}'
     Move to the next file-start, in a multi-file patch
     (`diff-file-next').

`M-{'
     Move to the previous file-start, in a multi-file patch
     (`diff-file-prev').

`M-k'
     Kill the hunk at point (`diff-hunk-kill').

`M-K'
     In a multi-file patch, kill the current file part.
     (`diff-file-kill').

`C-c C-a'
     Apply this hunk to its target file (`diff-apply-hunk').  With a
     prefix argument of `C-u', revert this hunk.

`C-c C-c'
     Go to the source corresponding to this hunk (`diff-goto-source').

`C-c C-e'
     Start an Ediff session with the patch (`diff-ediff-patch').  *Note
     Ediff: (ediff)Top.

`C-c C-n'
     Restrict the view to the current hunk (`diff-restrict-view').
     *Note Narrowing::.  With a prefix argument of `C-u', restrict the
     view to the current patch of a multiple file patch.  To widen
     again, use `C-x n w'.

`C-c C-r'
     Reverse the direction of comparison for the entire buffer
     (`diff-reverse-direction').

`C-c C-s'
     Split the hunk at point (`diff-split-hunk').  This is for manually
     editing patches, and only works with the unified diff format.

`C-c C-u'
     Convert the entire buffer to unified format
     (`diff-context->unified').  With a prefix argument, convert
     unified format to context format.  In Transient Mark mode, when the
     mark is active, this command operates only on the region.

`C-c C-w'
     Refine the current hunk so that it disregards changes in whitespace
     (`diff-refine-hunk').

   `C-x 4 a' in Diff mode operates on behalf of the target file, but
gets the function name from the patch itself.  *Note Change Log::.
This is useful for making log entries for functions that are deleted by
the patch.


File: emacs,  Node: Misc File Ops,  Next: Compressed Files,  Prev: Diff Mode,  Up: Files

23.12 Miscellaneous File Operations
===================================

Emacs has commands for performing many other operations on files.  All
operate on one file; they do not accept wildcard file names.

   `M-x view-file' allows you to scan or read a file by sequential
screenfuls.  It reads a file name argument using the minibuffer.  After
reading the file into an Emacs buffer, `view-file' displays the
beginning.  You can then type <SPC> to scroll forward one windowful, or
<DEL> to scroll backward.  Various other commands are provided for
moving around in the file, but none for changing it; type `?' while
viewing for a list of them.  They are mostly the same as normal Emacs
cursor motion commands.  To exit from viewing, type `q'.  The commands
for viewing are defined by a special minor mode called View mode.

   A related command, `M-x view-buffer', views a buffer already present
in Emacs.  *Note Misc Buffer::.

   `M-x insert-file' (also `C-x i') inserts a copy of the contents of
the specified file into the current buffer at point, leaving point
unchanged before the contents and the mark after them.

   `M-x insert-file-literally' is like `M-x insert-file', except the
file is inserted "literally": it is treated as a sequence of ASCII
characters with no special encoding or conversion, similar to the `M-x
find-file-literally' command (*note Visiting::).

   `M-x write-region' is the inverse of `M-x insert-file'; it copies
the contents of the region into the specified file.  `M-x
append-to-file' adds the text of the region to the end of the specified
file.  *Note Accumulating Text::.  The variable
`write-region-inhibit-fsync' applies to these commands, as well as
saving files; see *note Customize Save::.

   `M-x delete-file' deletes the specified file, like the `rm' command
in the shell.  If you are deleting many files in one directory, it may
be more convenient to use Dired (*note Dired::).

   `M-x rename-file' reads two file names OLD and NEW using the
minibuffer, then renames file OLD as NEW.  If the file name NEW already
exists, you must confirm with `yes' or renaming is not done; this is
because renaming causes the old meaning of the name NEW to be lost.  If
OLD and NEW are on different file systems, the file OLD is copied and
deleted.

   If the argument NEW is just a directory name, the real new name is
in that directory, with the same non-directory component as OLD.  For
example, `M-x rename-file RET ~/foo RET /tmp RET' renames `~/foo' to
`/tmp/foo'.  The same rule applies to all the remaining commands in
this section.  All of them ask for confirmation when the new file name
already exists, too.

   The similar command `M-x add-name-to-file' is used to add an
additional name to an existing file without removing its old name.  The
new name is created as a "hard link" to the existing file.  The new
name must belong on the same file system that the file is on.  On
MS-Windows, this command works only if the file resides in an NTFS file
system.  On MS-DOS, it works by copying the file.

   `M-x copy-file' reads the file OLD and writes a new file named NEW
with the same contents.

   `M-x make-symbolic-link' reads two file names TARGET and LINKNAME,
then creates a symbolic link named LINKNAME, which points at TARGET.
The effect is that future attempts to open file LINKNAME will refer to
whatever file is named TARGET at the time the opening is done, or will
get an error if the name TARGET is nonexistent at that time.  This
command does not expand the argument TARGET, so that it allows you to
specify a relative name as the target of the link.

   Not all systems support symbolic links; on systems that don't
support them, this command is not defined.


File: emacs,  Node: Compressed Files,  Next: File Archives,  Prev: Misc File Ops,  Up: Files

23.13 Accessing Compressed Files
================================

Emacs automatically uncompresses compressed files when you visit them,
and automatically recompresses them if you alter them and save them.
Emacs recognizes compressed files by their file names.  File names
ending in `.gz' indicate a file compressed with `gzip'.  Other endings
indicate other compression programs.

   Automatic uncompression and compression apply to all the operations
in which Emacs uses the contents of a file.  This includes visiting it,
saving it, inserting its contents into a buffer, loading it, and byte
compiling it.

   To disable this feature, type the command `M-x
auto-compression-mode'.  You can disable it permanently by customizing
the variable `auto-compression-mode'.


File: emacs,  Node: File Archives,  Next: Remote Files,  Prev: Compressed Files,  Up: Files

23.14 File Archives
===================

A file whose name ends in `.tar' is normally an "archive" made by the
`tar' program.  Emacs views these files in a special mode called Tar
mode which provides a Dired-like list of the contents (*note Dired::).
You can move around through the list just as you would in Dired, and
visit the subfiles contained in the archive.  However, not all Dired
commands are available in Tar mode.

   If Auto Compression mode is enabled (*note Compressed Files::), then
Tar mode is used also for compressed archives--files with extensions
`.tgz', `.tar.Z' and `.tar.gz'.

   The keys `e', `f' and <RET> all extract a component file into its
own buffer.  You can edit it there, and if you save the buffer, the
edited version will replace the version in the Tar buffer.  `v'
extracts a file into a buffer in View mode.  `o' extracts the file and
displays it in another window, so you could edit the file and operate
on the archive simultaneously.  `d' marks a file for deletion when you
later use `x', and `u' unmarks a file, as in Dired.  `C' copies a file
from the archive to disk and `R' renames a file within the archive.
`g' reverts the buffer from the archive on disk.

   The keys `M', `G', and `O' change the file's permission bits, group,
and owner, respectively.

   If your display supports colors and the mouse, moving the mouse
pointer across a file name highlights that file name, indicating that
you can click on it.  Clicking `Mouse-2' on the highlighted file name
extracts the file into a buffer and displays that buffer.

   Saving the Tar buffer writes a new version of the archive to disk
with the changes you made to the components.

   You don't need the `tar' program to use Tar mode--Emacs reads the
archives directly.  However, accessing compressed archives requires the
appropriate uncompression program.

   A separate but similar Archive mode is used for archives produced by
the programs `arc', `jar', `lzh', `zip', and `zoo', which have
extensions corresponding to the program names.  Archive mode also works
for those `exe' files that are self-extracting executables.

   The key bindings of Archive mode are similar to those in Tar mode,
with the addition of the `m' key which marks a file for subsequent
operations, and `M-<DEL>' which unmarks all the marked files.  Also,
the `a' key toggles the display of detailed file information, for those
archive types where it won't fit in a single line.  Operations such as
renaming a subfile, or changing its mode or owner, are supported only
for some of the archive formats.

   Unlike Tar mode, Archive mode runs the archiving program to unpack
and repack archives.  Details of the program names and their options
can be set in the `Archive' Customize group.  However, you don't need
these programs to look at the archive table of contents, only to
extract or manipulate the subfiles in the archive.


File: emacs,  Node: Remote Files,  Next: Quoted File Names,  Prev: File Archives,  Up: Files

23.15 Remote Files
==================

You can refer to files on other machines using a special file name
syntax:

     /HOST:FILENAME
     /USER@HOST:FILENAME
     /USER@HOST#PORT:FILENAME
     /METHOD:USER@HOST:FILENAME
     /METHOD:USER@HOST#PORT:FILENAME

To carry out this request, Emacs uses either the FTP program or a
remote-login program such as `ssh', `rlogin', or `telnet'.  You can
always specify in the file name which method to use--for example,
`/ftp:USER@HOST:FILENAME' uses FTP, whereas `/ssh:USER@HOST:FILENAME'
uses `ssh'.  When you don't specify a method in the file name, Emacs
chooses the method as follows:

  1. If the host name starts with `ftp.' (with dot), then Emacs uses
     FTP.

  2. If the user name is `ftp' or `anonymous', then Emacs uses FTP.

  3. Otherwise, Emacs uses `ssh'.

Remote file access through FTP is handled by the Ange-FTP package, which
is documented in the following.  Remote file access through the other
methods is handled by the Tramp package, which has its own manual.
*Note The Tramp Manual: (tramp)Top.

   When the Ange-FTP package is used, Emacs logs in through FTP using
your user name or the name USER.  It may ask you for a password from
time to time; this is used for logging in on HOST.  The form using PORT
allows you to access servers running on a non-default TCP port.

   If you want to disable backups for remote files, set the variable
`ange-ftp-make-backup-files' to `nil'.

   By default, the auto-save files (*note Auto Save Files::) for remote
files are made in the temporary file directory on the local machine.
This is achieved using the variable `auto-save-file-name-transforms'.

   Normally, if you do not specify a user name in a remote file name,
that means to use your own user name.  But if you set the variable
`ange-ftp-default-user' to a string, that string is used instead.

   To visit files accessible by anonymous FTP, you use special user
names `anonymous' or `ftp'.  Passwords for these user names are handled
specially.  The variable `ange-ftp-generate-anonymous-password'
controls what happens: if the value of this variable is a string, then
that string is used as the password; if non-`nil' (the default), then
the value of `user-mail-address' is used; if `nil', then Emacs prompts
you for a password as usual.

   Sometimes you may be unable to access files on a remote machine
because a "firewall" in between blocks the connection for security
reasons.  If you can log in on a "gateway" machine from which the
target files _are_ accessible, and whose FTP server supports gatewaying
features, you can still use remote file names; all you have to do is
specify the name of the gateway machine by setting the variable
`ange-ftp-gateway-host', and set `ange-ftp-smart-gateway' to `t'.
Otherwise you may be able to make remote file names work, but the
procedure is complex.  You can read the instructions by typing `M-x
finder-commentary <RET> ange-ftp <RET>'.

   You can entirely turn off the FTP file name feature by removing the
entries `ange-ftp-completion-hook-function' and
`ange-ftp-hook-function' from the variable `file-name-handler-alist'.
You can turn off the feature in individual cases by quoting the file
name with `/:' (*note Quoted File Names::).


File: emacs,  Node: Quoted File Names,  Next: File Name Cache,  Prev: Remote Files,  Up: Files

23.16 Quoted File Names
=======================

You can "quote" an absolute file name to prevent special characters and
syntax in it from having their special effects.  The way to do this is
to add `/:' at the beginning.

   For example, you can quote a local file name which appears remote, to
prevent it from being treated as a remote file name.  Thus, if you have
a directory named `/foo:' and a file named `bar' in it, you can refer
to that file in Emacs as `/:/foo:/bar'.

   `/:' can also prevent `~' from being treated as a special character
for a user's home directory.  For example, `/:/tmp/~hack' refers to a
file whose name is `~hack' in directory `/tmp'.

   Quoting with `/:' is also a way to enter in the minibuffer a file
name that contains `$'.  In order for this to work, the `/:' must be at
the beginning of the minibuffer contents.  (You can also double each
`$'; see *note File Names with $::.)

   You can also quote wildcard characters with `/:', for visiting.  For
example, `/:/tmp/foo*bar' visits the file `/tmp/foo*bar'.

   Another method of getting the same result is to enter
`/tmp/foo[*]bar', which is a wildcard specification that matches only
`/tmp/foo*bar'.  However, in many cases there is no need to quote the
wildcard characters because even unquoted they give the right result.
For example, if the only file name in `/tmp' that starts with `foo' and
ends with `bar' is `foo*bar', then specifying `/tmp/foo*bar' will visit
only `/tmp/foo*bar'.


File: emacs,  Node: File Name Cache,  Next: File Conveniences,  Prev: Quoted File Names,  Up: Files

23.17 File Name Cache
=====================

You can use the "file name cache" to make it easy to locate a file by
name, without having to remember exactly where it is located.  When
typing a file name in the minibuffer, `C-<tab>'
(`file-cache-minibuffer-complete') completes it using the file name
cache.  If you repeat `C-<tab>', that cycles through the possible
completions of what you had originally typed.  (However, note that the
`C-<tab>' character cannot be typed on most text-only terminals.)

   The file name cache does not fill up automatically.  Instead, you
load file names into the cache using these commands:

`M-x file-cache-add-directory <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY to the file name cache.

`M-x file-cache-add-directory-using-find <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY and all of its nested
     subdirectories to the file name cache.

`M-x file-cache-add-directory-using-locate <RET> DIRECTORY <RET>'
     Add each file name in DIRECTORY and all of its nested
     subdirectories to the file name cache, using `locate' to find them
     all.

`M-x file-cache-add-directory-list <RET> VARIABLE <RET>'
     Add each file name in each directory listed in VARIABLE to the
     file name cache.  VARIABLE should be a Lisp variable such as
     `load-path' or `exec-path', whose value is a list of directory
     names.

`M-x file-cache-clear-cache <RET>'
     Clear the cache; that is, remove all file names from it.

   The file name cache is not persistent: it is kept and maintained
only for the duration of the Emacs session.  You can view the contents
of the cache with the `file-cache-display' command.


File: emacs,  Node: File Conveniences,  Next: Filesets,  Prev: File Name Cache,  Up: Files

23.18 Convenience Features for Finding Files
============================================

In this section, we introduce some convenient facilities for finding
recently-opened files, reading file names from a buffer, and viewing
image files.

   If you enable Recentf mode, with `M-x recentf-mode', the `File' menu
includes a submenu containing a list of recently opened files.  `M-x
recentf-save-list' saves the current `recent-file-list' to a file, and
`M-x recentf-edit-list' edits it.

   The `M-x ffap' command generalizes `find-file' with more powerful
heuristic defaults (*note FFAP::), often based on the text at point.
Partial Completion mode offers other features extending `find-file',
which can be used with `ffap'.  *Note Completion Options::.

   Visiting image files automatically selects Image mode.  This major
mode allows you to toggle between displaying the file as an image in
the Emacs buffer, and displaying its underlying text representation,
using the command `C-c C-c' (`image-toggle-display').  This works only
when Emacs can display the specific image type.  If the displayed image
is wider or taller than the frame, the usual point motion keys (`C-f',
`C-p', and so forth) cause different parts of the image to be displayed.

   See also the Image-Dired package (*note Image-Dired::) for viewing
images as thumbnails.


File: emacs,  Node: Filesets,  Prev: File Conveniences,  Up: Files

23.19 Filesets
==============

If you regularly edit a certain group of files, you can define them as
a "fileset".  This lets you perform certain operations, such as
visiting, `query-replace', and shell commands on all the files at once.
To make use of filesets, you must first add the expression
`(filesets-init)' to your `.emacs' file (*note Init File::).  This adds
a `Filesets' menu to the menu bar.

   The simplest way to define a fileset is by adding files to it one at
a time.  To add a file to fileset NAME, visit the file and type `M-x
filesets-add-buffer RET NAME RET'.  If there is no fileset NAME, this
creates a new one, which initially creates only the current file.  The
command `M-x filesets-remove-buffer' removes the current file from a
fileset.

   You can also edit the list of filesets directly, with `M-x
filesets-edit' (or by choosing `Edit Filesets' from the `Filesets'
menu).  The editing is performed in a Customize buffer (*note Easy
Customization::).  Filesets need not be a simple list of files--you can
also define filesets using regular expression matching file names.
Some examples of these more complicated filesets are shown in the
Customize buffer.  Remember to select `Save for future sessions' if you
want to use the same filesets in future Emacs sessions.

   You can use the command `M-x filesets-open' to visit all the files
in a fileset, and `M-x filesets-close' to close them.  Use `M-x
filesets-run-cmd' to run a shell command on all the files in a fileset.
These commands are also available from the `Filesets' menu, where each
existing fileset is represented by a submenu.


File: emacs,  Node: Buffers,  Next: Windows,  Prev: Files,  Up: Top

24 Using Multiple Buffers
*************************

The text you are editing in Emacs resides in an object called a
"buffer".  Each time you visit a file, a buffer is created to hold the
file's text.  Each time you invoke Dired, a buffer is created to hold
the directory listing.  If you send a message with `C-x m', a buffer
named `*mail*' is used to hold the text of the message.  When you ask
for a command's documentation, that appears in a buffer called `*Help*'.

   At any time, one and only one buffer is "current".  It is also
called the "selected buffer".  Often we say that a command operates on
"the buffer" as if there were only one; but really this means that the
command operates on the current buffer (most commands do).

   When Emacs has multiple windows, each window has its own chosen
buffer and displays it; at any time, only one of the windows is
selected, and its chosen buffer is the current buffer.  Each window's
mode line normally displays the name of the window's chosen buffer
(*note Windows::).

   Each buffer has a name, which can be of any length, and you can
select any buffer by giving its name.  Most buffers are made by
visiting files, and their names are derived from the files' names.  But
you can also create an empty buffer with any name you want.  A newly
started Emacs has a buffer named `*scratch*' which can be used for
evaluating Lisp expressions in Emacs.  The distinction between upper
and lower case matters in buffer names.

   Each buffer records individually what file it is visiting, whether
it is modified, and what major mode and minor modes are in effect in it
(*note Major Modes::).  Any Emacs variable can be made "local to" a
particular buffer, meaning its value in that buffer can be different
from the value in other buffers.  *Note Locals::.

   A buffer's size cannot be larger than some maximum, which is defined
by the largest buffer position representable by the "Emacs integer"
data type.  This is because Emacs tracks buffer positions using that
data type.  For 32-bit machines, the largest buffer size is 256
megabytes.

* Menu:

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::	        Renaming; changing read-onlyness; copying text.
* Kill Buffer::	        Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
			  and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer.
* Buffer Convenience::  Convenience and customization features for
                          buffer handling.


File: emacs,  Node: Select Buffer,  Next: List Buffers,  Up: Buffers

24.1 Creating and Selecting Buffers
===================================

`C-x b BUFFER <RET>'
     Select or create a buffer named BUFFER (`switch-to-buffer').

`C-x 4 b BUFFER <RET>'
     Similar, but select BUFFER in another window
     (`switch-to-buffer-other-window').

`C-x 5 b BUFFER <RET>'
     Similar, but select BUFFER in a separate frame
     (`switch-to-buffer-other-frame').

`C-x <LEFT>'
     Select the previous buffer in the list of existing buffers.

`C-x <RIGHT>'
     Select the next buffer in the list of existing buffers.

`C-u M-g M-g'
`C-u M-g g'
     Read a number N and move to line N in the most recently selected
     buffer other than the current buffer.

   To select the buffer named BUFNAME, type `C-x b BUFNAME <RET>'.
This runs the command `switch-to-buffer' with argument BUFNAME.  You
can use completion to enter the buffer name (*note Completion::).  An
empty argument to `C-x b' specifies the buffer that was current most
recently among those not now displayed in any window.

   For conveniently switching between a few buffers, use the commands
`C-x <LEFT>' and `C-x <RIGHT>'.  `C-x <RIGHT>' (`previous-buffer')
selects the previous buffer (following the order of most recent
selection in the current frame), while `C-x <LEFT>' (`next-buffer')
moves through buffers in the reverse direction.

   To select a buffer in a window other than the current one, type `C-x
4 b BUFNAME <RET>'.  This runs the command
`switch-to-buffer-other-window' which displays the buffer BUFNAME in
another window.  By default, if displaying the buffer causes two
vertically adjacent windows to be displayed, the heights of those
windows are evened out; to countermand that and preserve the window
configuration, set the variable `even-window-heights' to `nil'.

   Similarly, `C-x 5 b BUFFER <RET>' runs the command
`switch-to-buffer-other-frame' which selects a buffer in another frame.

   You can control how certain buffers are handled by these commands by
customizing the variables `special-display-buffer-names',
`special-display-regexps', `same-window-buffer-names', and
`same-window-regexps'.  See *note Force Same Window::, and *note
Special Buffer Frames::, for more about these variables.  In addition,
if the value of `display-buffer-reuse-frames' is non-`nil', and the
buffer you want to switch to is already displayed in some frame, Emacs
will just raise that frame.

   Most buffers are created by visiting files, or by Emacs commands that
want to display some text, but you can also create a buffer explicitly
by typing `C-x b BUFNAME <RET>'.  This makes a new, empty buffer that
is not visiting any file, and selects it for editing.  Such buffers are
used for making notes to yourself.  If you try to save one, you are
asked for the file name to use.  The new buffer's major mode is
determined by the value of `default-major-mode' (*note Major Modes::).

   Note that `C-x C-f', and any other command for visiting a file, can
also be used to switch to an existing file-visiting buffer.  *Note
Visiting::.

   `C-u M-g M-g', that is `goto-line' with a prefix argument of just
`C-u', reads a number N using the minibuffer, selects the most recently
selected buffer other than the current buffer in another window, and
then moves point to the beginning of line number N in that buffer.
This is mainly useful in a buffer that refers to line numbers in
another buffer: if point is on or just after a number, `goto-line' uses
that number as the default for N.  Note that prefix arguments other
than just `C-u' behave differently.  `C-u 4 M-g M-g' goes to line 4 in
the _current_ buffer, without reading a number from the minibuffer.
(Remember that `M-g M-g' without prefix argument reads a number N and
then moves to line number N in the current buffer.)

   Emacs uses buffer names that start with a space for internal
purposes.  It treats these buffers specially in minor ways--for
example, by default they do not record undo information.  It is best to
avoid using such buffer names yourself.


File: emacs,  Node: List Buffers,  Next: Misc Buffer,  Prev: Select Buffer,  Up: Buffers

24.2 Listing Existing Buffers
=============================

`C-x C-b'
     List the existing buffers (`list-buffers').

   To display a list of existing buffers, type `C-x C-b'.  Each line in
the list shows one buffer's name, major mode and visited file.  The
buffers are listed in the order that they were current; the buffers
that were current most recently come first.

   `*' in the first field of a line indicates the buffer is "modified."
If several buffers are modified, it may be time to save some with `C-x
s' (*note Save Commands::).  `%' indicates a read-only buffer.  `.'
marks the current buffer.  Here is an example of a buffer list:

     CRM Buffer                Size  Mode              File
     . * .emacs                3294  Emacs-Lisp        ~/.emacs
      %  *Help*                 101  Help
         search.c             86055  C                 ~/cvs/emacs/src/search.c
      %  src                  20959  Dired by name     ~/cvs/emacs/src/
       * *mail*                  42  Mail
      %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
      %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
         *scratch*              191  Lisp Interaction
       * *Messages*            1554  Fundamental

Note that the buffer `*Help*' was made by a help request; it is not
visiting any file.  The buffer `src' was made by Dired on the directory
`~/cvs/emacs/src/'.  You can list only buffers that are visiting files
by giving the command a prefix argument, as in `C-u C-x C-b'.

   `list-buffers' omits buffers whose names begin with a space, unless
they visit files: such buffers are used internally by Emacs.


File: emacs,  Node: Misc Buffer,  Next: Kill Buffer,  Prev: List Buffers,  Up: Buffers

24.3 Miscellaneous Buffer Operations
====================================

`C-x C-q'
     Toggle read-only status of buffer (`toggle-read-only').

`M-x rename-buffer <RET> NAME <RET>'
     Change the name of the current buffer.

`M-x rename-uniquely'
     Rename the current buffer by adding `<NUMBER>' to the end.

`M-x view-buffer <RET> BUFFER <RET>'
     Scroll through buffer BUFFER.

   A buffer can be "read-only", which means that commands to change its
contents are not allowed.  The mode line indicates read-only buffers
with `%%' or `%*' near the left margin.  Read-only buffers are usually
made by subsystems such as Dired and Rmail that have special commands
to operate on the text; also by visiting a file whose access control
says you cannot write it.

   If you wish to make changes in a read-only buffer, use the command
`C-x C-q' (`toggle-read-only').  It makes a read-only buffer writable,
and makes a writable buffer read-only.  This works by setting the
variable `buffer-read-only', which has a local value in each buffer and
makes the buffer read-only if its value is non-`nil'.  If you have
files under version control, you may find it convenient to bind `C-x
C-q' to `vc-toggle-read-only' instead.  Then, typing `C-x C-q' not only
changes the read-only flag, but it also checks the file in or out.
*Note Version Control::.

   `M-x rename-buffer' changes the name of the current buffer.  You
specify the new name as a minibuffer argument; there is no default.  If
you specify a name that is in use for some other buffer, an error
happens and no renaming is done.

   `M-x rename-uniquely' renames the current buffer to a similar name
with a numeric suffix added to make it both different and unique.  This
command does not need an argument.  It is useful for creating multiple
shell buffers: if you rename the `*shell*' buffer, then do `M-x shell'
again, it makes a new shell buffer named `*shell*'; meanwhile, the old
shell buffer continues to exist under its new name.  This method is
also good for mail buffers, compilation buffers, and most Emacs
features that create special buffers with particular names.  (With some
of these features, such as `M-x compile', `M-x grep' an `M-x info', you
need to switch to some other buffer before using the command, in order
for it to make a different buffer.)

   `M-x view-buffer' is much like `M-x view-file' (*note Misc File
Ops::) except that it examines an already existing Emacs buffer.  View
mode provides commands for scrolling through the buffer conveniently
but not for changing it.  When you exit View mode with `q', that
switches back to the buffer (and the position) which was previously
displayed in the window.  Alternatively, if you exit View mode with
`e', the buffer and the value of point that resulted from your perusal
remain in effect.

   The commands `M-x append-to-buffer' and `M-x insert-buffer' can be
used to copy text from one buffer to another.  *Note Accumulating
Text::.


File: emacs,  Node: Kill Buffer,  Next: Several Buffers,  Prev: Misc Buffer,  Up: Buffers

24.4 Killing Buffers
====================

If you continue an Emacs session for a while, you may accumulate a
large number of buffers.  You may then find it convenient to "kill" the
buffers you no longer need.  On most operating systems, killing a
buffer releases its space back to the operating system so that other
programs can use it.  Here are some commands for killing buffers:

`C-x k BUFNAME <RET>'
     Kill buffer BUFNAME (`kill-buffer').

`M-x kill-some-buffers'
     Offer to kill each buffer, one by one.

   `C-x k' (`kill-buffer') kills one buffer, whose name you specify in
the minibuffer.  The default, used if you type just <RET> in the
minibuffer, is to kill the current buffer.  If you kill the current
buffer, another buffer becomes current: one that was current in the
recent past but is not displayed in any window now.  If you ask to kill
a file-visiting buffer that is modified (has unsaved editing), then you
must confirm with `yes' before the buffer is killed.

   The command `M-x kill-some-buffers' asks about each buffer, one by
one.  An answer of `y' means to kill the buffer.  Killing the current
buffer or a buffer containing unsaved changes selects a new buffer or
asks for confirmation just like `kill-buffer'.

   The buffer menu feature (*note Several Buffers::) is also convenient
for killing various buffers.

   If you want to do something special every time a buffer is killed,
you can add hook functions to the hook `kill-buffer-hook' (*note
Hooks::).

   If you run one Emacs session for a period of days, as many people do,
it can fill up with buffers that you used several days ago.  The command
`M-x clean-buffer-list' is a convenient way to purge them; it kills all
the unmodified buffers that you have not used for a long time.  An
ordinary buffer is killed if it has not been displayed for three days;
however, you can specify certain buffers that should never be killed
automatically, and others that should be killed if they have been unused
for a mere hour.

   You can also have this buffer purging done for you, every day at
midnight, by enabling Midnight mode.  Midnight mode operates each day at
midnight; at that time, it runs `clean-buffer-list', or whichever
functions you have placed in the normal hook `midnight-hook' (*note
Hooks::).

   To enable Midnight mode, use the Customization buffer to set the
variable `midnight-mode' to `t'.  *Note Easy Customization::.


File: emacs,  Node: Several Buffers,  Next: Indirect Buffers,  Prev: Kill Buffer,  Up: Buffers

24.5 Operating on Several Buffers
=================================

The "buffer-menu" facility is like a "Dired for buffers"; it allows you
to request operations on various Emacs buffers by editing an Emacs
buffer containing a list of them.  You can save buffers, kill them
(here called "deleting" them, for consistency with Dired), or display
them.

`M-x buffer-menu'
     Begin editing a buffer listing all Emacs buffers.

`M-x buffer-menu-other-window.'
     Similar, but do it in another window.

   The command `buffer-menu' writes a list of all Emacs buffers(1) into
the buffer `*Buffer List*', and selects that buffer in Buffer Menu mode.

   The buffer is read-only, and can be changed only through the special
commands described in this section.  The usual Emacs cursor motion
commands can be used in the `*Buffer List*' buffer.  The following
commands apply to the buffer described on the current line.

`d'
     Request to delete (kill) the buffer, then move down.  The request
     shows as a `D' on the line, before the buffer name.  Requested
     deletions take place when you type the `x' command.

`C-d'
     Like `d' but move up afterwards instead of down.

`s'
     Request to save the buffer.  The request shows as an `S' on the
     line.  Requested saves take place when you type the `x' command.
     You may request both saving and deletion for the same buffer.

`x'
     Perform previously requested deletions and saves.

`u'
     Remove any request made for the current line, and move down.

`<DEL>'
     Move to previous line and remove any request made for that line.

   The `d', `C-d', `s' and `u' commands to add or remove flags also
move down (or up) one line.  They accept a numeric argument as a repeat
count.

   These commands operate immediately on the buffer listed on the
current line:

`~'
     Mark the buffer "unmodified."  The command `~' does this
     immediately when you type it.

`%'
     Toggle the buffer's read-only flag.  The command `%' does this
     immediately when you type it.

`t'
     Visit the buffer as a tags table.  *Note Select Tags Table::.

   There are also commands to select another buffer or buffers:

`q'
     Quit the buffer menu--immediately display the most recent formerly
     visible buffer in its place.

`<RET>'
`f'
     Immediately select this line's buffer in place of the `*Buffer
     List*' buffer.

`o'
     Immediately select this line's buffer in another window as if by
     `C-x 4 b', leaving `*Buffer List*' visible.

`C-o'
     Immediately display this line's buffer in another window, but don't
     select the window.

`1'
     Immediately select this line's buffer in a full-screen window.

`2'
     Immediately set up two windows, with this line's buffer selected in
     one, and the previously current buffer (aside from the buffer
     `*Buffer List*') displayed in the other.

`b'
     Bury the buffer listed on this line.

`m'
     Mark this line's buffer to be displayed in another window if you
     exit with the `v' command.  The request shows as a `>' at the
     beginning of the line.  (A single buffer may not have both a delete
     request and a display request.)

`v'
     Immediately select this line's buffer, and also display in other
     windows any buffers previously marked with the `m' command.  If
     you have not marked any buffers, this command is equivalent to `1'.

   There is also a command that affects the entire buffer list:

`T'
     Delete, or reinsert, lines for non-file buffers.  This command
     toggles the inclusion of such buffers in the buffer list.

   What `buffer-menu' actually does is create and switch to a suitable
buffer, and turn on Buffer Menu mode in it.  Everything else described
above is implemented by the special commands provided in Buffer Menu
mode.  One consequence of this is that you can switch from the `*Buffer
List*' buffer to another Emacs buffer, and edit there.  You can
reselect the `*Buffer List*' buffer later, to perform the operations
already requested, or you can kill it, or pay no further attention to
it.

   The list in the `*Buffer List*' buffer looks exactly like the buffer
list described in *note List Buffers::, because they really are the
same.  The only difference between `buffer-menu' and `list-buffers' is
that `buffer-menu' switches to the `*Buffer List*' buffer in the
selected window; `list-buffers' displays the same buffer in another
window.  If you run `list-buffers' (that is, type `C-x C-b') and select
the buffer list manually, you can use all of the commands described
here.

   Normally, the buffer `*Buffer List*' is not updated automatically
when buffers are created and killed; its contents are just text.  If
you have created, deleted or renamed buffers, the way to update
`*Buffer List*' to show what you have done is to type `g'
(`revert-buffer').  You can make this happen regularly every
`auto-revert-interval' seconds if you enable Auto Revert mode in this
buffer, as long as it is not marked modified.  Global Auto Revert mode
applies to the `*Buffer List*' buffer only if
`global-auto-revert-non-file-buffers' is non-`nil'.  *Note
global-auto-revert-non-file-buffers: Autorevert, for details.

   The command `buffer-menu-other-window' works the same as
`buffer-menu', except that it displays the buffers list in another
window.

   ---------- Footnotes ----------

   (1) Buffers which don't visit files and whose names begin with a
space are omitted: these are used internally by Emacs.


File: emacs,  Node: Indirect Buffers,  Next: Buffer Convenience,  Prev: Several Buffers,  Up: Buffers

24.6 Indirect Buffers
=====================

An "indirect buffer" shares the text of some other buffer, which is
called the "base buffer" of the indirect buffer.  In some ways it is
the analogue, for buffers, of a symbolic link between files.

`M-x make-indirect-buffer <RET> BASE-BUFFER <RET> INDIRECT-NAME <RET>'
     Create an indirect buffer named INDIRECT-NAME whose base buffer is
     BASE-BUFFER.  

`M-x clone-indirect-buffer <RET>'
     Create an indirect buffer that is a twin copy of the current
     buffer.

`C-x 4 c'
     Create an indirect buffer that is a twin copy of the current
     buffer, and select it in another window
     (`clone-indirect-buffer-other-window').

   The text of the indirect buffer is always identical to the text of
its base buffer; changes made by editing either one are visible
immediately in the other.  But in all other respects, the indirect
buffer and its base buffer are completely separate.  They have
different names, different values of point, different narrowing,
different markers, different major modes, and different local variables.

   An indirect buffer cannot visit a file, but its base buffer can.  If
you try to save the indirect buffer, that actually works by saving the
base buffer.  Killing the base buffer effectively kills the indirect
buffer, but killing an indirect buffer has no effect on its base buffer.

   One way to use indirect buffers is to display multiple views of an
outline.  *Note Outline Views::.

   A quick and handy way to make an indirect buffer is with the command
`M-x clone-indirect-buffer'.  It creates and selects an indirect buffer
whose base buffer is the current buffer.  With a numeric argument, it
prompts for the name of the indirect buffer; otherwise it uses the name
of the current buffer, with a `<N>' suffix added.  `C-x 4 c'
(`clone-indirect-buffer-other-window') works like `M-x
clone-indirect-buffer', but it selects the new buffer in another window.

   The more general way to make an indirect buffer is with the command
`M-x make-indirect-buffer'.  It creates an indirect buffer from buffer
BASE-BUFFER, under the name INDIRECT-NAME.  It prompts for both
BASE-BUFFER and INDIRECT-NAME using the minibuffer.


File: emacs,  Node: Buffer Convenience,  Prev: Indirect Buffers,  Up: Buffers

24.7 Convenience Features and Customization of Buffer Handling
==============================================================

This section describes several modes and features that make it more
convenient to switch between buffers.

* Menu:

* Uniquify::               Making buffer names unique with directory parts.
* Iswitchb::               Switching between buffers with substrings.
* Buffer Menus::           Configurable buffer menu.


File: emacs,  Node: Uniquify,  Next: Iswitchb,  Up: Buffer Convenience

24.7.1 Making Buffer Names Unique
---------------------------------

When several buffers visit identically-named files, Emacs must give the
buffers distinct names.  The usual method for making buffer names
unique adds `<2>', `<3>', etc. to the end of the buffer names (all but
one of them).

   Other methods work by adding parts of each file's directory to the
buffer name.  To select one, customize the variable
`uniquify-buffer-name-style' (*note Easy Customization::).

   To begin with, the `forward' naming method includes part of the
file's directory name at the beginning of the buffer name; using this
method, buffers visiting the files `/u/rms/tmp/Makefile' and
`/usr/projects/zaphod/Makefile' would be named `tmp/Makefile' and
`zaphod/Makefile', respectively (instead of `Makefile' and
`Makefile<2>').

   In contrast, the `post-forward' naming method would call the buffers
`Makefile|tmp' and `Makefile|zaphod', and the `reverse' naming method
would call them `Makefile\tmp' and `Makefile\zaphod'.  The nontrivial
difference between `post-forward' and `reverse' occurs when just one
directory name is not enough to distinguish two files; then `reverse'
puts the directory names in reverse order, so that `/top/middle/file'
becomes `file\middle\top', while `post-forward' puts them in forward
order after the file name, as in `file|top/middle'.

   Which rule to follow for putting the directory names in the buffer
name is not very important if you are going to _look_ at the buffer
names before you type one.  But as an experienced user, if you know the
rule, you won't have to look.  And then you may find that one rule or
another is easier for you to remember and apply quickly.


File: emacs,  Node: Iswitchb,  Next: Buffer Menus,  Prev: Uniquify,  Up: Buffer Convenience

24.7.2 Switching Between Buffers using Substrings
-------------------------------------------------

Iswitchb global minor mode provides convenient switching between
buffers using substrings of their names.  It replaces the normal
definitions of `C-x b', `C-x 4 b', `C-x 5 b', and `C-x 4 C-o' with
alternative commands that are somewhat "smarter."

   When one of these commands prompts you for a buffer name, you can
type in just a substring of the name you want to choose.  As you enter
the substring, Iswitchb mode continuously displays a list of buffers
that match the substring you have typed.

   At any time, you can type <RET> to select the first buffer in the
list.  So the way to select a particular buffer is to make it the first
in the list.  There are two ways to do this.  You can type more of the
buffer name and thus narrow down the list, excluding unwanted buffers
above the desired one.  Alternatively, you can use `C-s' and `C-r' to
rotate the list until the desired buffer is first.

   <TAB> while entering the buffer name performs completion on the
string you have entered, based on the displayed list of buffers.

   To enable Iswitchb mode, type `M-x iswitchb-mode', or customize the
variable `iswitchb-mode' to `t' (*note Easy Customization::).


File: emacs,  Node: Buffer Menus,  Prev: Iswitchb,  Up: Buffer Convenience

24.7.3 Customizing Buffer Menus
-------------------------------

`M-x bs-show'
     Make a list of buffers similarly to `M-x list-buffers' but
     customizable.

   `M-x bs-show' pops up a buffer list similar to the one normally
displayed by `C-x C-b' but which you can customize.  If you prefer this
to the usual buffer list, you can bind this command to `C-x C-b'.  To
customize this buffer list, use the `bs' Custom group (*note Easy
Customization::).

   MSB global minor mode ("MSB" stands for "mouse select buffer")
provides a different and customizable mouse buffer menu which you may
prefer.  It replaces the bindings of `mouse-buffer-menu', normally on
`C-Down-Mouse-1', and the menu bar buffer menu.  You can customize the
menu in the `msb' Custom group.


File: emacs,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

25 Multiple Windows
*******************

Emacs can split a frame into two or many windows.  Multiple windows can
display parts of different buffers, or different parts of one buffer.
Multiple frames always imply multiple windows, because each frame has
its own set of windows.  Each window belongs to one and only one frame.

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.
* Window Convenience::  Convenience functions for window handling.


File: emacs,  Node: Basic Window,  Next: Split Window,  Up: Windows

25.1 Concepts of Emacs Windows
==============================

Each Emacs window displays one Emacs buffer at any time.  A single
buffer may appear in more than one window; if it does, any changes in
its text are displayed in all the windows where it appears.  But these
windows can show different parts of the buffer, because each window has
its own value of point.

   At any time, one Emacs window is the "selected window"; the buffer
this window is displaying is the current buffer.  The terminal's cursor
shows the location of point in this window.  Each other window has a
location of point as well.  On text-only terminals, there is no way to
show where those locations are, since the terminal has only one cursor.
On a graphical display, the location of point in a non-selected window
is indicated by a hollow box; the cursor in the selected window is
blinking or solid.

   Commands to move point affect the value of point for the selected
Emacs window only.  They do not change the value of point in other Emacs
windows, even those showing the same buffer.  The same is true for
commands such as `C-x b' to switch buffers in the selected window; they
do not affect other windows at all.  However, there are other commands
such as `C-x 4 b' that select a different window and switch buffers in
it.  Also, all commands that display information in a window, including
(for example) `C-h f' (`describe-function') and `C-x C-b'
(`list-buffers'), work by switching buffers in a nonselected window
without affecting the selected window.

   When multiple windows show the same buffer, they can have different
regions, because they can have different values of point.  However,
they all have the same value for the mark, because each buffer has only
one mark position.

   Each window has its own mode line, which displays the buffer name,
modification status and major and minor modes of the buffer that is
displayed in the window.  The selected window's mode line appears in a
different color.  *Note Mode Line::, for full details on the mode line.


File: emacs,  Node: Split Window,  Next: Other Window,  Prev: Basic Window,  Up: Windows

25.2 Splitting Windows
======================

`C-x 2'
     Split the selected window into two windows, one above the other
     (`split-window-vertically').

`C-x 3'
     Split the selected window into two windows positioned side by side
     (`split-window-horizontally').

`C-Mouse-2'
     In the mode line or scroll bar of a window, split that window.

   The command `C-x 2' (`split-window-vertically') breaks the selected
window into two windows, one above the other.  Both windows start out
displaying the same buffer, with the same value of point.  By default
the two windows each get half the height of the window that was split; a
numeric argument specifies how many lines to give to the top window.

   `C-x 3' (`split-window-horizontally') breaks the selected window
into two side-by-side windows.  A numeric argument specifies how many
columns to give the one on the left.  If you are not using scrollbars,
a vertical line separates the two windows.  You can customize its color
with the face `vertical-border'.  Windows that are not the full width
of the screen have mode lines, but they are truncated.  On terminals
where Emacs does not support highlighting, truncated mode lines
sometimes do not appear in inverse video.

   You can split a window horizontally or vertically by clicking
`C-Mouse-2' in the mode line or the scroll bar.  The line of splitting
goes through the place where you click: if you click on the mode line,
the new scroll bar goes above the spot; if you click in the scroll bar,
the mode line of the split window is side by side with your click.

   When a window is less than the full width, text lines too long to
fit are frequent.  Continuing all those lines might be confusing, so if
the variable `truncate-partial-width-windows' is non-`nil', that forces
truncation in all windows less than the full width of the screen,
independent of the buffer being displayed and its value for
`truncate-lines'.  *Note Line Truncation::.

   Horizontal scrolling is often used in side-by-side windows.  *Note
Horizontal Scrolling::.

   If `split-window-keep-point' is non-`nil', the default, both of the
windows resulting from `C-x 2' inherit the value of point from the
window that was split.  This means that scrolling is inevitable.  If
this variable is `nil', then `C-x 2' tries to avoid scrolling the text
currently visible on the screen, by putting point in each window at a
position already visible in the window.  It also selects whichever
window contains the screen line that the cursor was previously on.
Some users prefer that mode on slow terminals.


File: emacs,  Node: Other Window,  Next: Pop Up Window,  Prev: Split Window,  Up: Windows

25.3 Using Other Windows
========================

`C-x o'
     Select another window (`other-window').  That is `o', not zero.

`C-M-v'
     Scroll the next window (`scroll-other-window').

`M-x compare-windows'
     Find next place where the text in the selected window does not
     match the text in the next window.

`Mouse-1'
     `Mouse-1', in a window's mode line, selects that window but does
     not move point in it (`mouse-select-window').

   To select a different window, click with `Mouse-1' on its mode line.
With the keyboard, you can switch windows by typing `C-x o'
(`other-window').  That is an `o', for "other," not a zero.  When there
are more than two windows, this command moves through all the windows
in a cyclic order, generally top to bottom and left to right.  After
the rightmost and bottommost window, it goes back to the one at the
upper left corner.  A numeric argument means to move several steps in
the cyclic order of windows.  A negative argument moves around the
cycle in the opposite order.  When the minibuffer is active, the
minibuffer is the last window in the cycle; you can switch from the
minibuffer window to one of the other windows, and later switch back and
finish supplying the minibuffer argument that is requested.  *Note
Minibuffer Edit::.

   The usual scrolling commands (*note Display::) apply to the selected
window only, but there is one command to scroll the next window.
`C-M-v' (`scroll-other-window') scrolls the window that `C-x o' would
select.  It takes arguments, positive and negative, like `C-v'.  (In
the minibuffer, `C-M-v' scrolls the window that contains the minibuffer
help display, if any, rather than the next window in the standard
cyclic order.)

   The command `M-x compare-windows' lets you compare two files or
buffers visible in two windows, by moving through them to the next
mismatch.  *Note Comparing Files::, for details.

   If you set `mouse-autoselect-window' to a non-`nil' value, moving
the mouse into a different window selects that window.  This feature is
off by default.


File: emacs,  Node: Pop Up Window,  Next: Force Same Window,  Prev: Other Window,  Up: Windows

25.4 Displaying in Another Window
=================================

`C-x 4' is a prefix key for commands that select another window
(splitting the window if there is only one) and select a buffer in that
window.  Different `C-x 4' commands have different ways of finding the
buffer to select.

`C-x 4 b BUFNAME <RET>'
     Select buffer BUFNAME in another window.  This runs
     `switch-to-buffer-other-window'.

`C-x 4 C-o BUFNAME <RET>'
     Display buffer BUFNAME in another window, but don't select that
     buffer or that window.  This runs `display-buffer'.

`C-x 4 f FILENAME <RET>'
     Visit file FILENAME and select its buffer in another window.  This
     runs `find-file-other-window'.  *Note Visiting::.

`C-x 4 d DIRECTORY <RET>'
     Select a Dired buffer for directory DIRECTORY in another window.
     This runs `dired-other-window'.  *Note Dired::.

`C-x 4 m'
     Start composing a mail message in another window.  This runs
     `mail-other-window'; its same-window analogue is `C-x m' (*note
     Sending Mail::).

`C-x 4 .'
     Find a tag in the current tags table, in another window.  This runs
     `find-tag-other-window', the multiple-window variant of `M-.'
     (*note Tags::).

`C-x 4 r FILENAME <RET>'
     Visit file FILENAME read-only, and select its buffer in another
     window.  This runs `find-file-read-only-other-window'.  *Note
     Visiting::.


File: emacs,  Node: Force Same Window,  Next: Change Window,  Prev: Pop Up Window,  Up: Windows

25.5 Forcing Display in the Same Window
=======================================

Certain Emacs commands switch to a specific buffer with special
contents.  For example, `M-x shell' switches to a buffer named
`*shell*'.  By convention, all these commands are written to pop up the
buffer in a separate window.  But you can specify that certain of these
buffers should appear in the selected window.

   If you add a buffer name to the list `same-window-buffer-names', the
effect is that such commands display that particular buffer by
switching to it in the selected window.  For example, if you add the
element `"*grep*"' to the list, the `grep' command will display its
output buffer in the selected window.

   The default value of `same-window-buffer-names' is not `nil': it
specifies buffer names `*info*', `*mail*' and `*shell*' (as well as
others used by more obscure Emacs packages).  This is why `M-x shell'
normally switches to the `*shell*' buffer in the selected window.  If
you delete this element from the value of `same-window-buffer-names',
the behavior of `M-x shell' will change--it will pop up the buffer in
another window instead.

   You can specify these buffers more generally with the variable
`same-window-regexps'.  Set it to a list of regular expressions; then
any buffer whose name matches one of those regular expressions is
displayed by switching to it in the selected window.  (Once again, this
applies only to buffers that normally get displayed for you in a
separate window.)  The default value of this variable specifies Telnet
and rlogin buffers.

   An analogous feature lets you specify buffers which should be
displayed in their own individual frames.  *Note Special Buffer
Frames::.


File: emacs,  Node: Change Window,  Next: Window Convenience,  Prev: Force Same Window,  Up: Windows

25.6 Deleting and Rearranging Windows
=====================================

`C-x 0'
     Delete the selected window (`delete-window').  The last character
     in this key sequence is a zero.

`C-x 1'
     Delete all windows in the selected frame except the selected window
     (`delete-other-windows').

`C-x 4 0'
     Delete the selected window and kill the buffer that was showing in
     it (`kill-buffer-and-window').  The last character in this key
     sequence is a zero.

`C-x ^'
     Make selected window taller (`enlarge-window').

`C-x }'
     Make selected window wider (`enlarge-window-horizontally').

`C-x {'
     Make selected window narrower (`shrink-window-horizontally').

`C-x -'
     Shrink this window if its buffer doesn't need so many lines
     (`shrink-window-if-larger-than-buffer').

`C-x +'
     Make all windows the same height (`balance-windows').

   To delete a window, type `C-x 0' (`delete-window').  (That is a
zero.)  The space occupied by the deleted window is given to an
adjacent window (but not the minibuffer window, even if that is active
at the time).  Once a window is deleted, its attributes are forgotten;
only restoring a window configuration can bring it back.  Deleting the
window has no effect on the buffer it used to display; the buffer
continues to exist, and you can select it in any window with `C-x b'.

   `C-x 4 0' (`kill-buffer-and-window') is a stronger command than `C-x
0'; it kills the current buffer and then deletes the selected window.

   `C-x 1' (`delete-other-windows') is more powerful in a different
way; it deletes all the windows except the selected one (and the
minibuffer); the selected window expands to use the whole frame except
for the echo area.

   To readjust the division of space among vertically adjacent windows,
use `C-x ^' (`enlarge-window').  It makes the currently selected window
one line bigger, or as many lines as is specified with a numeric
argument.  With a negative argument, it makes the selected window
smaller.  `C-x }' (`enlarge-window-horizontally') makes the selected
window wider by the specified number of columns.  `C-x {'
(`shrink-window-horizontally') makes the selected window narrower by
the specified number of columns.

   When you make a window bigger, the space comes from its peers.  If
this makes any window too small, it is deleted and its space is given
to an adjacent window.  The minimum size is specified by the variables
`window-min-height' and `window-min-width'.

   The command `C-x -' (`shrink-window-if-larger-than-buffer') reduces
the height of the selected window, if it is taller than necessary to
show the whole text of the buffer it is displaying.  It gives the extra
lines to other windows in the frame.

   You can also use `C-x +' (`balance-windows') to even out the heights
of all the windows in the selected frame.

   Mouse clicks on the mode line provide another way to change window
heights and to delete windows.  *Note Mode Line Mouse::.


File: emacs,  Node: Window Convenience,  Prev: Change Window,  Up: Windows

25.7 Window Handling Convenience Features and Customization
===========================================================

`M-x winner-mode' is a global minor mode that records the changes in
the window configuration (i.e. how the frames are partitioned into
windows), so that you can "undo" them.  To undo, use `C-c left'
(`winner-undo').  If you change your mind while undoing, you can redo
the changes you had undone using `C-c right' (`M-x winner-redo').
Another way to enable Winner mode is by customizing the variable
`winner-mode'.

   The Windmove commands move directionally between neighboring windows
in a frame.  `M-x windmove-right' selects the window immediately to the
right of the currently selected one, and similarly for the "left," "up,"
and "down" counterparts.  `M-x windmove-default-keybindings' binds
these commands to `S-right' etc.  (Not all terminals support shifted
arrow keys, however.)

   Follow minor mode (`M-x follow-mode') synchronizes several windows
on the same buffer so that they always display adjacent sections of
that buffer.  *Note Follow Mode::.

   `M-x scroll-all-mode' provides commands to scroll all visible
windows together.  You can also turn it on by customizing the variable
`scroll-all-mode'.  The commands provided are `M-x
scroll-all-scroll-down-all', `M-x scroll-all-page-down-all' and their
corresponding "up" equivalents.  To make this mode useful, you should
bind these commands to appropriate keys.


File: emacs,  Node: Frames,  Next: International,  Prev: Windows,  Up: Top

26 Frames and Graphical Displays
********************************

When using a graphical display, you can create multiple windows at the
system in a single Emacs session.  Each system-level window that
belongs to Emacs displays a "frame" which can contain one or several
Emacs windows.  A frame initially contains a single general-purpose
Emacs window which you can subdivide vertically or horizontally into
smaller windows.  A frame normally contains its own echo area and
minibuffer, but you can make frames that don't have these--they use the
echo area and minibuffer of another frame.

   To avoid confusion, we reserve the word "window" for the
subdivisions that Emacs implements, and never use it to refer to a
frame.

   Editing you do in one frame affects the other frames.  For instance,
if you put text in the kill ring in one frame, you can yank it in
another frame.  If you exit Emacs through `C-x C-c' in one frame, it
terminates all the frames.  To delete just one frame, use `C-x 5 0'
(that is zero, not `o').

   Emacs compiled for MS-DOS emulates some windowing functionality, so
that you can use many of the features described in this chapter.  *Note
MS-DOS Mouse::.

* Menu:

* Cut and Paste::       Mouse commands for cut and paste.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Frame Commands::      Iconifying, deleting, and switching frames.
* Speedbar::            How to make and use a speedbar frame.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Wheeled Mice::        Using mouse wheels for scrolling.
* Drag and Drop::       Using drag and drop to open files and insert text.
* Menu Bars::	        Enabling and disabling the menu bar.
* Tool Bars::           Enabling and disabling the tool bar.
* Dialog Boxes::        Controlling use of dialog boxes.
* Tooltips::            Displaying information at the current mouse position.
* Mouse Avoidance::     Moving the mouse pointer out of the way.
* Non-Window Terminals::  Multiple frames on terminals that show only one.
* Text-Only Mouse::     Using the mouse in text-only terminals.


File: emacs,  Node: Cut and Paste,  Next: Mouse References,  Up: Frames

26.1 Killing and Yanking on Graphical Displays
==============================================

This section describes facilities for selecting a region, killing, and
yanking using the mouse.

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Cut/Paste Other App:: Transfering text between Emacs and other apps.
* Word and Line Mouse:: Mouse commands for selecting whole words or lines.
* Secondary Selection:: Cutting without altering point and mark.
* Clipboard::           Using the clipboard for selections.


File: emacs,  Node: Mouse Commands,  Next: Cut/Paste Other App,  Up: Cut and Paste

26.1.1 Mouse Commands for Editing
---------------------------------

The mouse commands for selecting and copying a region are mostly
compatible with the `xterm' program.  You can use the same mouse
commands for copying between Emacs and other window-based programs.
Most of these commands also work in Emacs when you run it under an
`xterm' terminal.

   If you select a region with any of these mouse commands, and then
immediately afterward type the <DELETE> function key, it deletes the
region that you selected.  The <BACKSPACE> function key and the ASCII
character <DEL> do not do this; if you type any other key in between
the mouse command and <DELETE>, it does not do this.

`Mouse-1'
     Move point to where you click (`mouse-set-point').  This is
     normally the left button.

     Normally, Emacs does not distinguish between ordinary mouse clicks
     and clicks that select a frame.  When you click on a frame to
     select it, that also changes the selected window and cursor
     position according to the mouse click position.  On the X window
     system, you can change this behavior by setting the variable
     `x-mouse-click-focus-ignore-position' to `t'.  Then the first
     click selects the frame, but does not affect the selected window
     or cursor position.  If you click again in the same place, since
     that click will be in the selected frame, it will change the
     window or cursor position.

`Drag-Mouse-1'
     Set the region to the text you select by dragging, and copy it to
     the kill ring (`mouse-set-region').  You can specify both ends of
     the region with this single command.

     If you move the mouse off the top or bottom of the window while
     dragging, the window scrolls at a steady rate until you move the
     mouse back into the window.  This way, you can select regions that
     don't fit entirely on the screen.  The number of lines scrolled
     per step depends on how far away from the window edge the mouse
     has gone; the variable `mouse-scroll-min-lines' specifies a
     minimum step size.

     If the variable `mouse-drag-copy-region' is `nil', this mouse
     command does not copy the selected region into the kill ring.

`Mouse-2'
     Yank the last killed text, where you click (`mouse-yank-at-click').
     This is normally the middle button.

`Mouse-3'
     This command, `mouse-save-then-kill', has several functions
     depending on where you click and the status of the region.

     The most basic case is when you click `Mouse-1' in one place and
     then `Mouse-3' in another.  This selects the text between those two
     positions as the region.  It also copies the new region to the kill
     ring, so that you can copy it to someplace else.

     If you click `Mouse-1' in the text, scroll with the scroll bar, and
     then click `Mouse-3', it remembers where point was before scrolling
     (where you put it with `Mouse-1'), and uses that position as the
     other end of the region.  This is so that you can select a region
     that doesn't fit entirely on the screen.

     More generally, if you do not have a highlighted region, `Mouse-3'
     selects the text between point and the click position as the
     region.  It does this by setting the mark where point was, and
     moving point to where you click.

     If you have a highlighted region, or if the region was set just
     before by dragging button 1, `Mouse-3' adjusts the nearer end of
     the region by moving it to where you click.  The adjusted region's
     text also replaces the old region's text in the kill ring.

     If you originally specified the region using a double or triple
     `Mouse-1', so that the region is defined to consist of entire words
     or lines, then adjusting the region with `Mouse-3' also proceeds by
     entire words or lines.

     If you use `Mouse-3' a second time consecutively, at the same
     place, that kills the region already selected.

   The simplest way to kill text with the mouse is to press `Mouse-1'
at one end, then press `Mouse-3' twice at the other end.  *Note
Killing::.  To copy the text into the kill ring without deleting it
from the buffer, press `Mouse-3' just once--or just drag across the
text with `Mouse-1'.  Then you can copy it elsewhere by yanking it.

   To yank the killed or copied text somewhere else, move the mouse
there and press `Mouse-2'.  *Note Yanking::.  However, if
`mouse-yank-at-point' is non-`nil', `Mouse-2' yanks at point.  Then it
does not matter where you click, or even which of the frame's windows
you click on.  The default value is `nil'.  This variable also affects
yanking the secondary selection.

   Many graphical applications follow the convention that insertion
while text is selected deletes the selected text.  You can make Emacs
behave this way by enabling Delete Selection mode--with `M-x
delete-selection-mode' or using Custom.  Another effect of this mode is
that <DEL>, `C-d' and some other keys, when a selection exists, will
kill the whole selection.  It also enables Transient Mark mode (*note
Transient Mark::).


File: emacs,  Node: Cut/Paste Other App,  Next: Word and Line Mouse,  Prev: Mouse Commands,  Up: Cut and Paste

26.1.2 Cut and Paste with Other Window Applications
---------------------------------------------------

To copy text to another windowing application, kill it or save it in
the kill ring.  Then use the "paste" or "yank" command of the other
application to insert the text.

   To copy text from another windowing application, use its "cut" or
"copy" command to select the text you want.  Then yank it in Emacs with
`C-y' or `Mouse-2'.

   When Emacs puts text into the kill ring, or rotates text to the
front of the kill ring, it sets the "primary selection" in the window
system.  This is how other windowing applications can access the text.
On the X Window System, emacs also stores the text in the cut buffer,
but only if the text is short enough (the value of `x-cut-buffer-max'
specifies the maximum number of characters); putting long strings in
the cut buffer can be slow.

   The commands to yank the first entry in the kill ring actually check
first for a primary selection in another program; after that, they check
for text in the cut buffer.  If neither of those sources provides text
to yank, the kill ring contents are used.

   The standard coding system for X Window System selections is
`compound-text-with-extensions'.  To specify another coding system for
selections, use `C-x <RET> x' or `C-x <RET> X'.  *Note Communication
Coding::.


File: emacs,  Node: Word and Line Mouse,  Next: Secondary Selection,  Prev: Cut/Paste Other App,  Up: Cut and Paste

26.1.3 Mouse Commands for Words and Lines
-----------------------------------------

These variants of `Mouse-1' select entire words or lines at a time.

`Double-Mouse-1'
     This key sets the region around the word which you click on.  If
     you click on a character with "symbol" syntax (such as underscore,
     in C mode), it sets the region around the symbol surrounding that
     character.

     If you click on a character with open-parenthesis or
     close-parenthesis syntax, it sets the region around the
     parenthetical grouping which that character starts or ends.  If
     you click on a character with string-delimiter syntax (such as a
     singlequote or doublequote in C), it sets the region around the
     string constant (using heuristics to figure out whether that
     character is the beginning or the end of it).

`Double-Drag-Mouse-1'
     This key selects a region made up of the words you drag across.

`Triple-Mouse-1'
     This key sets the region around the line you click on.

`Triple-Drag-Mouse-1'
     This key selects a region made up of the lines you drag across.


File: emacs,  Node: Secondary Selection,  Next: Clipboard,  Prev: Word and Line Mouse,  Up: Cut and Paste

26.1.4 Secondary Selection
--------------------------

The "secondary selection" is another way of selecting text using the X
Window System.  It does not use point or the mark, so you can use it to
kill text without setting point or the mark.

`M-Drag-Mouse-1'
     Set the secondary selection, with one end at the place where you
     press down the button, and the other end at the place where you
     release it (`mouse-set-secondary').  The highlighting appears and
     changes as you drag.  You can control the appearance of the
     highlighting by customizing the `secondary-selection' face (*note
     Face Customization::).

     If you move the mouse off the top or bottom of the window while
     dragging, the window scrolls at a steady rate until you move the
     mouse back into the window.  This way, you can mark regions that
     don't fit entirely on the screen.

     This way of setting the secondary selection does not alter the
     kill ring.

`M-Mouse-1'
     Set one endpoint for the "secondary selection"
     (`mouse-start-secondary').

`M-Mouse-3'
     Make a secondary selection, using the place specified with
     `M-Mouse-1' as the other end (`mouse-secondary-save-then-kill').
     This also puts the selected text in the kill ring.  A second click
     at the same place kills the secondary selection just made.

`M-Mouse-2'
     Insert the secondary selection where you click
     (`mouse-yank-secondary').  This places point at the end of the
     yanked text.

   Double or triple clicking of `M-Mouse-1' operates on words and
lines, much like `Mouse-1'.

   If `mouse-yank-at-point' is non-`nil', `M-Mouse-2' yanks at point.
Then it does not matter precisely where you click, or even which of the
frame's windows you click on.  *Note Mouse Commands::.


File: emacs,  Node: Clipboard,  Prev: Secondary Selection,  Up: Cut and Paste

26.1.5 Using the Clipboard
--------------------------

Apart from the primary and secondary selection types, Emacs can handle
the "clipboard" selection type which is used by some applications,
particularly under OpenWindows and Gnome.

   The command `M-x menu-bar-enable-clipboard' makes the `Cut', `Paste'
and `Copy' menu items, as well as the keys of the same names, all use
the clipboard.

   You can customize the variable `x-select-enable-clipboard' to make
the Emacs yank functions consult the clipboard before the primary
selection, and to make the kill functions to store in the clipboard as
well as the primary selection.  Otherwise they do not access the
clipboard at all.  Using the clipboard is the default on MS-Windows and
Mac, but not on other systems.


File: emacs,  Node: Mouse References,  Next: Menu Mouse Clicks,  Prev: Cut and Paste,  Up: Frames

26.2 Following References with the Mouse
========================================

Some read-only Emacs buffers include references you can follow, or
commands you can activate.  These include names of files, of buffers,
of possible completions, of matches for a pattern, as well as the
buttons in Help buffers and customization buffers.  You can follow the
reference or activate the command by moving point to it and typing
<RET>.  You can also do this with the mouse, using either `Mouse-1' or
`Mouse-2'.

   Since yanking text into a read-only buffer is not allowed, these
buffers generally define `Mouse-2' to follow a reference or activate a
command.  For example, if you click `Mouse-2' on a file name in a Dired
buffer, you visit that file.  If you click `Mouse-2' on an error
message in the `*Compilation*' buffer, you go to the source code for
that error message.  If you click `Mouse-2' on a completion in the
`*Completions*' buffer, you choose that completion.

   However, most applications use `Mouse-1' to do this sort of thing,
so Emacs implements this too.  If you click `Mouse-1' quickly on a
reference or button, it follows or activates.  If you click slowly, it
moves point as usual.  Dragging, meaning moving the mouse while it is
held down, also has its usual behavior of setting the region.

   Normally, the `Mouse-1' click behavior is performed on links in any
window.  The variable `mouse-1-click-in-non-selected-windows' controls
whether `Mouse-1' has this behavior even in non-selected windows, or
only in the selected window.

   You can usually tell when `Mouse-1' and `Mouse-2' have this special
sort of meaning because the sensitive text highlights when you move the
mouse over it.  The variable `mouse-highlight' controls whether to do
this highlighting always (even when such text appears where the mouse
already is), never, or only immediately after you move the mouse.

   In Emacs versions before 22, only `Mouse-2' follows links and
`Mouse-1' always sets point.  If you prefer this older behavior, set
the variable `mouse-1-click-follows-link' to `nil'.  This variable also
lets you choose various other alternatives for following links with the
mouse.  Type `C-h v mouse-1-click-follows-link <RET>' for more details.


File: emacs,  Node: Menu Mouse Clicks,  Next: Mode Line Mouse,  Prev: Mouse References,  Up: Frames

26.3 Mouse Clicks for Menus
===========================

Several mouse clicks with the <CTRL> and <SHIFT> modifiers bring up
menus.

`C-Mouse-1'
     This menu is for selecting a buffer.

     The MSB ("mouse select buffer") global minor mode makes this menu
     smarter and more customizable.  *Note Buffer Menus::.

`C-Mouse-2'
     This menu is for specifying faces and other text properties for
     editing formatted text.  *Note Formatted Text::.

`C-Mouse-3'
     This menu is mode-specific.  For most modes if Menu-bar mode is on,
     this menu has the same items as all the mode-specific menu-bar
     menus put together.  Some modes may specify a different menu for
     this button.(1)  If Menu-bar mode is off, this menu contains all
     the items which would be present in the menu bar--not just the
     mode-specific ones--so that you can access them without having to
     display the menu bar.

`S-Mouse-1'
     This menu is for specifying the frame's default font.

   ---------- Footnotes ----------

   (1) Some systems use `Mouse-3' for a mode-specific menu.  We took a
survey of users, and found they preferred to keep `Mouse-3' for
selecting and killing regions.  Hence the decision to use `C-Mouse-3'
for this menu.  To use `Mouse-3' instead, do `(global-set-key [mouse-3]
'mouse-popup-menubar-stuff)'.


File: emacs,  Node: Mode Line Mouse,  Next: Creating Frames,  Prev: Menu Mouse Clicks,  Up: Frames

26.4 Mode Line Mouse Commands
=============================

You can use mouse clicks on window mode lines to select and manipulate
windows.

   Some areas of the mode line, such as the buffer name and the major
mode name, have their own special mouse bindings.  These areas are
highlighted when you hold the mouse over them, and information about
the special bindings will be displayed (*note Tooltips::).  This
section's commands do not apply in those areas.

`Mouse-1'
     `Mouse-1' on a mode line selects the window it belongs to.  By
     dragging `Mouse-1' on the mode line, you can move it, thus
     changing the height of the windows above and below.  Changing
     heights with the mouse in this way never deletes windows, it just
     refuses to make any window smaller than the minimum height.

`Mouse-2'
     `Mouse-2' on a mode line expands that window to fill its frame.

`Mouse-3'
     `Mouse-3' on a mode line deletes the window it belongs to.  If the
     frame has only one window, it buries the current buffer instead,
     and switches to another buffer.

`C-Mouse-2'
     `C-Mouse-2' on a mode line splits the window above horizontally,
     above the place in the mode line where you click.

   Using `Mouse-1' on the divider between two side-by-side mode lines,
you can move the vertical boundary left or right.  Using `C-Mouse-2' on
a scroll bar splits the corresponding window vertically.  *Note Split
Window::.


File: emacs,  Node: Creating Frames,  Next: Frame Commands,  Prev: Mode Line Mouse,  Up: Frames

26.5 Creating Frames
====================

The prefix key `C-x 5' is analogous to `C-x 4', with parallel
subcommands.  The difference is that `C-x 5' commands create a new
frame rather than just a new window in the selected frame (*note Pop Up
Window::).  If an existing visible or iconified frame already displays
the requested material, these commands use the existing frame, after
raising or deiconifying as necessary.

   The various `C-x 5' commands differ in how they find or create the
buffer to select:

`C-x 5 2'
     Create a new frame (`make-frame-command').

`C-x 5 b BUFNAME <RET>'
     Select buffer BUFNAME in another frame.  This runs
     `switch-to-buffer-other-frame'.

`C-x 5 f FILENAME <RET>'
     Visit file FILENAME and select its buffer in another frame.  This
     runs `find-file-other-frame'.  *Note Visiting::.

`C-x 5 d DIRECTORY <RET>'
     Select a Dired buffer for directory DIRECTORY in another frame.
     This runs `dired-other-frame'.  *Note Dired::.

`C-x 5 m'
     Start composing a mail message in another frame.  This runs
     `mail-other-frame'.  It is the other-frame variant of `C-x m'.
     *Note Sending Mail::.

`C-x 5 .'
     Find a tag in the current tag table in another frame.  This runs
     `find-tag-other-frame', the multiple-frame variant of `M-.'.
     *Note Tags::.

`C-x 5 r FILENAME <RET>'
     Visit file FILENAME read-only, and select its buffer in another
     frame.  This runs `find-file-read-only-other-frame'.  *Note
     Visiting::.

   You can control the appearance of new frames you create by setting
the frame parameters in `default-frame-alist'.  You can use the
variable `initial-frame-alist' to specify parameters that affect only
the initial frame.  *Note Initial Parameters: (elisp)Initial
Parameters, for more information.

   The easiest way to specify the principal font for all your Emacs
frames is with an X resource (*note Font X::), but you can also do it by
modifying `default-frame-alist' to specify the `font' parameter, as
shown here:

     (add-to-list 'default-frame-alist '(font . "10x20"))

Here's a similar example for specifying a foreground color:

     (add-to-list 'default-frame-alist '(foreground-color . "blue"))

By putting such customizations in your `~/.emacs' init file, you can
control the appearance of all the frames Emacs creates, including the
initial one.

